<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ include file="AutoMessagePackSerializerTest.Polymorphism.ttinclude" #>
<#@ assembly name="System.Core.dll" #>
<#@ assembly name="System.Numerics.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Collections.ObjectModel" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Numerics" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Runtime.InteropServices.ComTypes" #>
<#@ import namespace="System.Text" #>
<#
	// TODO -> ComplexTypeGenerated.tt
var flavors = new []{ "Field", "Context", "Expression" };

var constructorParamterSpecs =
	new []
	{
		new KeyValuePair<string, string>( "Byte", "( byte )2" ),
		new KeyValuePair<string, string>( "SByte", "( sbyte )-2" ),
		new KeyValuePair<string, string>( "Int16", "( short )-2" ),
		new KeyValuePair<string, string>( "UInt16", "( ushort )2" ),
		new KeyValuePair<string, string>( "Int32", "-2" ),
		new KeyValuePair<string, string>( "UInt32", "( uint )2" ),
		new KeyValuePair<string, string>( "Int64", "-2L" ),
		new KeyValuePair<string, string>( "UInt64", "( ulong )2L" ),
		new KeyValuePair<string, string>( "Single", "1.2f" ),
		new KeyValuePair<string, string>( "Double", "1.2" ),
		new KeyValuePair<string, string>( "Decimal", "1.2m" ),
		new KeyValuePair<string, string>( "Boolean", "true" ),
		new KeyValuePair<string, string>( "Char", "'A'" ),
		new KeyValuePair<string, string>( "String", "\"ABC\"" ),
	};

var fields =
	new Tuple<Object, string, string, bool>[]
	{
		new Tuple<Object, string, string, bool>( typeof( Object ), "NullField", "null", true ),
		new Tuple<Object, string, string, bool>( typeof( Boolean ), "TrueField", "true", true ),
		new Tuple<Object, string, string, bool>( typeof( Boolean ), "FalseField", "false", true ),
		new Tuple<Object, string, string, bool>( typeof( Byte ), "TinyByteField", "1", true ),
		new Tuple<Object, string, string, bool>( typeof( Byte ), "ByteField", "0x80", true ),
		new Tuple<Object, string, string, bool>( typeof( Byte ), "MaxByteField", "0xff", true ),
		new Tuple<Object, string, string, bool>( typeof( UInt16 ), "TinyUInt16Field", "0x100", true ),
		new Tuple<Object, string, string, bool>( typeof( UInt16 ), "MaxUInt16Field", "0xffff", true ),
		new Tuple<Object, string, string, bool>( typeof( Int32 ), "TinyInt32Field", "0x10000", true ),
		new Tuple<Object, string, string, bool>( typeof( Int32 ), "MaxInt32Field", "Int32.MaxValue", true ),
		new Tuple<Object, string, string, bool>( typeof( Int32 ), "MinInt32Field", "Int32.MinValue", true ),
		new Tuple<Object, string, string, bool>( typeof( Int64 ), "TinyInt64Field", "0x100000000", true ),
		new Tuple<Object, string, string, bool>( typeof( Int64 ), "MaxInt64Field", "Int64.MaxValue", true ),
		new Tuple<Object, string, string, bool>( typeof( Int64 ), "MinInt64Field", "Int64.MinValue", true ),
		new Tuple<Object, string, string, bool>( typeof( DateTime ), String.Empty, "DateTime.UtcNow", true ),
		new Tuple<Object, string, string, bool>( typeof( DateTimeOffset ), String.Empty, "DateTimeOffset.UtcNow", true ),
		new Tuple<Object, string, string, bool>( typeof( Uri ), String.Empty, "new Uri( \"http://example.com/\" )", true ),
		new Tuple<Object, string, string, bool>( typeof( Version ), "VersionConstructorMajorMinor", "new Version( 1, 2 )", true ),
		new Tuple<Object, string, string, bool>( typeof( Version ), "VersionConstructorMajorMinorBuild", "new Version( 1, 2, 3 )", true ),
		new Tuple<Object, string, string, bool>( typeof( Version ), "FullVersionConstructor", "new Version( 1, 2, 3, 4 )", true ),
		new Tuple<Object, string, string, bool>( typeof( CultureInfo ), "InvariantCultureField", "CultureInfo.InvariantCulture", true ),
		new Tuple<Object, string, string, bool>( typeof( CultureInfo ), "CurrentCultureField", "CultureInfo.CurrentCulture", true ),
		new Tuple<Object, string, string, bool>( typeof( FILETIME ), String.Empty, "ToFileTime( DateTime.UtcNow )", true ),
		new Tuple<Object, string, string, bool>( typeof( TimeSpan ), String.Empty, "TimeSpan.FromMilliseconds( 123456789 )", true ),
		new Tuple<Object, string, string, bool>( typeof( Guid ), String.Empty, "Guid.NewGuid()", true ),
		new Tuple<Object, string, string, bool>( typeof( Char ), String.Empty, "'\u3000'", true ),
		new Tuple<Object, string, string, bool>( typeof( Decimal ), String.Empty, "123456789.0987654321m", true ),
		new Tuple<Object, string, string, bool>( typeof( BigInteger ), String.Empty, "new BigInteger( UInt64.MaxValue ) + UInt64.MaxValue", true ),
		new Tuple<Object, string, string, bool>( typeof( Complex ), String.Empty, "new Complex( 1.3, 2.4 )", true ),
		new Tuple<Object, string, string, bool>( typeof( DictionaryEntry ), String.Empty, "new DictionaryEntry( new MessagePackObject( \"Key\" ), new MessagePackObject( \"Value\" ) )", true ),
		new Tuple<Object, string, string, bool>( typeof( KeyValuePair<String, DateTimeOffset> ), String.Empty, "new KeyValuePair<String, DateTimeOffset>( \"Key\", DateTimeOffset.UtcNow )", true ),
		new Tuple<Object, string, string, bool>( typeof( KeyValuePair<String, Complex> ), String.Empty, "new KeyValuePair<String, Complex>( \"Key\", new Complex( 1.3, 2.4 ) )", true ),
		new Tuple<Object, string, string, bool>( typeof( String ), String.Empty, "\"StringValue\"", true ),
		new Tuple<Object, string, string, bool>( typeof( Byte[] ), String.Empty, "new Byte[]{ 1, 2, 3, 4 }", true ),
		new Tuple<Object, string, string, bool>( typeof( Char[] ), String.Empty, "\"ABCD\".ToCharArray()", true ),
		new Tuple<Object, string, string, bool>( typeof( ArraySegment<Byte> ), String.Empty, "new ArraySegment<Byte>( new Byte[]{ 1, 2, 3, 4 } )", true ),
		new Tuple<Object, string, string, bool>( typeof( ArraySegment<Int32> ), String.Empty, "new ArraySegment<Int32>( new Int32[]{ 1, 2, 3, 4 } )", true ),
		new Tuple<Object, string, string, bool>( typeof( ArraySegment<Decimal> ), String.Empty, "new ArraySegment<Decimal>( new Decimal[]{ 1, 2, 3, 4 } )", true ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( typeof( Tuple<,,,> ).FullName, new [] { typeof( Int32 ).FullName, typeof( String ).FullName, "MsgPack.MessagePackObject", typeof( Object ).FullName } ), String.Empty, "new Tuple<Int32, String, MessagePackObject, Object>( 1, \"ABC\", new MessagePackObject( \"abc\" ), new MessagePackObject( \"123\" ) ) ", true ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( "MsgPack.Image", new String[ 0 ] ), String.Empty, "new Image(){ uri = \"http://example.com/logo.png\", title = \"logo\", width = 160, height = 120, size = 13612 }", true ),
		new Tuple<Object, string, string, bool>( typeof( List<DateTime> ), String.Empty, "new List<DateTime>(){ DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ), DateTime.UtcNow }", false ),
		new Tuple<Object, string, string, bool>( typeof( Dictionary<String, DateTime> ), String.Empty, "new Dictionary<String, DateTime>(){ { \"Yesterday\", DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ) }, { \"Today\", DateTime.UtcNow } }", false ),
		new Tuple<Object, string, string, bool>( typeof( Collection<DateTime> ), String.Empty, "new Collection<DateTime>(){ DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ), DateTime.UtcNow }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( "MsgPack.Serialization.StringKeyedCollection`1", new []{ typeof( DateTime ).FullName } ), String.Empty, "new StringKeyedCollection<DateTime>(){ DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ), DateTime.UtcNow }", false ),
		new Tuple<Object, string, string, bool>( typeof( ObservableCollection<DateTime> ), String.Empty, "new ObservableCollection<DateTime>(){ DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ), DateTime.UtcNow }", false ),
		new Tuple<Object, string, string, bool>( typeof( HashSet<DateTime> ), String.Empty, "new HashSet<DateTime>( DictionaryTestHelper.GetEqualityComparer<DateTime>() ){ DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ), DateTime.UtcNow }", false ),
		new Tuple<Object, string, string, bool>( typeof( ICollection<DateTime> ), String.Empty, "new SimpleCollection<DateTime>(){ DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ), DateTime.UtcNow }", false ),
		new Tuple<Object, string, string, bool>( typeof( ISet<DateTime> ), String.Empty, "new HashSet<DateTime>( DictionaryTestHelper.GetEqualityComparer<DateTime>() ){ DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ), DateTime.UtcNow }", false ),
		new Tuple<Object, string, string, bool>( typeof( IList<DateTime> ), String.Empty, "new List<DateTime>(){ DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ), DateTime.UtcNow }", false ),
		new Tuple<Object, string, string, bool>( typeof( IDictionary<String, DateTime> ), String.Empty, "new Dictionary<String, DateTime>(){ { \"Yesterday\", DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ) }, { \"Today\", DateTime.UtcNow } }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( "MsgPack.Serialization.AddOnlyCollection`1", new []{ typeof( DateTime ).FullName } ), String.Empty, "new AddOnlyCollection<DateTime>(){ DateTime.UtcNow.Subtract( TimeSpan.FromDays( 1 ) ), DateTime.UtcNow }", false ),
		new Tuple<Object, string, string, bool>( typeof( Object ), String.Empty, "new MessagePackObject( 1 )", true ),
		new Tuple<Object, string, string, bool>( typeof( Object[] ), String.Empty, "new Object []{ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", true ),
		new Tuple<Object, string, string, bool>( typeof( ArrayList ), String.Empty, "new ArrayList(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( typeof( Hashtable ), String.Empty, "new Hashtable(){ { new MessagePackObject( \"1\" ), new MessagePackObject( 1 ) }, { new MessagePackObject( \"2\" ), new MessagePackObject( 2 ) } }", false ),
		new Tuple<Object, string, string, bool>( typeof( List<Object> ), String.Empty, "new List<Object>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( typeof( Dictionary<Object, Object> ), String.Empty, "new Dictionary<Object, Object>(){ { new MessagePackObject( \"1\" ), new MessagePackObject( 1 ) }, { new MessagePackObject( \"2\" ), new MessagePackObject( 2 ) } }", false ),
		new Tuple<Object, string, string, bool>( typeof( Collection<Object> ), String.Empty, "new Collection<Object>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( "MsgPack.Serialization.StringKeyedCollection`1", new [] { typeof( Object ).FullName } ), String.Empty, "new StringKeyedCollection<Object>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( typeof( ObservableCollection<Object> ), String.Empty, "new ObservableCollection<Object>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( typeof( HashSet<Object> ), String.Empty, "new HashSet<Object>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( typeof( ICollection<Object> ), String.Empty, "new SimpleCollection<Object>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( typeof( ISet<Object> ), String.Empty, "new HashSet<Object>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( typeof( IList<Object> ), String.Empty, "new List<Object>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( typeof( IDictionary<Object, Object> ), String.Empty, "new Dictionary<Object, Object>(){ { new MessagePackObject( \"1\" ), new MessagePackObject( 1 ) }, { new MessagePackObject( \"2\" ), new MessagePackObject( 2 ) } }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( "MsgPack.Serialization.AddOnlyCollection`1", new [] { typeof( Object ).FullName } ), String.Empty, "new AddOnlyCollection<Object>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( "MsgPack.MessagePackObject", new String[ 0 ] ), String.Empty, "new MessagePackObject( 1 )", true ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( "MsgPack.MessagePackObject[]", new String[ 0 ] ), String.Empty, "new MessagePackObject []{ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", true ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( typeof( List<> ).FullName, new [] { "MsgPack.MessagePackObject" } ), String.Empty, "new List<MessagePackObject>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( typeof( Dictionary<,> ).FullName, new [] { "MsgPack.MessagePackObject", "MsgPack.MessagePackObject" } ), String.Empty, "new Dictionary<MessagePackObject, MessagePackObject>( DictionaryTestHelper.GetEqualityComparer<MessagePackObject>() ){ { new MessagePackObject( \"1\" ), new MessagePackObject( 1 ) }, { new MessagePackObject( \"2\" ), new MessagePackObject( 2 ) } }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( typeof( Collection<> ).FullName, new [] { "MsgPack.MessagePackObject" } ), String.Empty, "new Collection<MessagePackObject>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( "MsgPack.Serialization.StringKeyedCollection`1", new [] { "MsgPack.MessagePackObject" } ), String.Empty, "new StringKeyedCollection<MessagePackObject>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( typeof( ObservableCollection<> ).FullName, new [] { "MsgPack.MessagePackObject" } ), String.Empty, "new ObservableCollection<MessagePackObject>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( typeof( HashSet<> ).FullName, new [] { "MsgPack.MessagePackObject" } ), String.Empty, "new HashSet<MessagePackObject>( DictionaryTestHelper.GetEqualityComparer<MessagePackObject>() ){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( typeof( ICollection<> ).FullName, new [] { "MsgPack.MessagePackObject" } ), String.Empty, "new SimpleCollection<MessagePackObject>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( typeof( ISet<> ).FullName, new [] { "MsgPack.MessagePackObject" } ), String.Empty, "new HashSet<MessagePackObject>( DictionaryTestHelper.GetEqualityComparer<MessagePackObject>() ){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( typeof( IList<> ).FullName, new [] { "MsgPack.MessagePackObject" } ), String.Empty, "new List<MessagePackObject>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( typeof( IDictionary<,> ).FullName, new [] { "MsgPack.MessagePackObject", "MsgPack.MessagePackObject" } ), String.Empty, "new Dictionary<MessagePackObject, MessagePackObject>( DictionaryTestHelper.GetEqualityComparer<MessagePackObject>() ){ { new MessagePackObject( \"1\" ), new MessagePackObject( 1 ) }, { new MessagePackObject( \"2\" ), new MessagePackObject( 2 ) } }", false ),
		new Tuple<Object, string, string, bool>( new Tuple<String, String[]>( "MsgPack.Serialization.AddOnlyCollection`1", new [] { "MsgPack.MessagePackObject" } ), String.Empty, "new AddOnlyCollection<MessagePackObject>(){ new MessagePackObject( 1 ), new MessagePackObject( 2 ) }", false ),
	};

var desktopOnly =
	new HashSet<Type>()
	{
		typeof( ArrayList ),
		typeof( Hashtable )
	};

var notInSL =
	new HashSet<Type>()
	{
		typeof( FILETIME )
	};

var notInSLWP =
	new HashSet<String>()
	{
		ToTypeName( typeof( KeyValuePair<string, Complex> ) ),
		ToTypeName( typeof( BigInteger ) ),
		ToTypeName( typeof( Complex ) ),
	};


var notInNet35 =
	new HashSet<String>()
	{
		ToTypeName( new Tuple<String, String[]>( typeof( ObservableCollection<> ).FullName, new [] { "MsgPack.MessagePackObject" } ) ),
		ToTypeName( new Tuple<String, String[]>( typeof( ISet<> ).FullName, new [] { "MsgPack.MessagePackObject" } ) ),
		ToTypeName( typeof( ISet<Object> ) ),
		ToTypeName( typeof( ObservableCollection<object> ) ),
		ToTypeName( typeof( ISet<DateTime> ) ),
		ToTypeName( typeof( ObservableCollection<DateTime> ) ),
		ToTypeName( typeof( KeyValuePair<string, Complex> ) ),
		ToTypeName( new Tuple<String, String[]>( typeof( Tuple<,,,> ).FullName, new [] { "System.Int32", "System.String", "MsgPack.MessagePackObject", "System.Object" } ) ),
		ToTypeName( typeof( BigInteger ) ),
		ToTypeName( typeof( Complex ) ),
	};
#>
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2010-2016 FUJIWARA, Yusuke and contributors
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
// Contributors:
//    Samuel Cragg
//
#endregion -- License Terms --

#if UNITY_5 || UNITY_STANDALONE || UNITY_WEBPLAYER || UNITY_WII || UNITY_IPHONE || UNITY_ANDROID || UNITY_PS3 || UNITY_XBOX360 || UNITY_FLASH || UNITY_BKACKBERRY || UNITY_WINRT
#define UNITY
#endif

#pragma warning disable 3003
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.IO;
using System.Linq;
#if !NET35 && !WINDOWS_PHONE
using System.Numerics;
#endif
using System.Reflection;
#if !SILVERLIGHT
using System.Runtime.InteropServices.ComTypes;
#endif // !SILVERLIGHT
using System.Text;
using System.Text.RegularExpressions;

#if FEATURE_TAP
using System.Threading;
using System.Threading.Tasks;
#endif // FEATURE_TAP

#if !MSTEST
using NUnit.Framework;
#else
using TestFixtureAttribute = Microsoft.VisualStudio.TestPlatform.UnitTestFramework.TestClassAttribute;
using TestAttribute = Microsoft.VisualStudio.TestPlatform.UnitTestFramework.TestMethodAttribute;
using TimeoutAttribute = NUnit.Framework.TimeoutAttribute;
using Assert = NUnit.Framework.Assert;
using Is = NUnit.Framework.Is;
#endif

namespace MsgPack.Serialization
{
	public sealed class ComplexTypeGeneratedEnclosure : IVerifiable<ComplexTypeGeneratedEnclosure>
	{
		public string Name { get; set; }
		
		public ComplexTypeGenerated Nested { get; set; }
		
		public void Verify( ComplexTypeGeneratedEnclosure expected )
		{
			Assert.That( this.Name, Is.EqualTo( expected.Name ) );
			this.Nested.Verify( expected.Nested );
		}
		
		public ComplexTypeGeneratedEnclosure Initialize()
		{
			this.Name = "NAME";
			this.Nested = new ComplexTypeGenerated().Initialize();
			return this;
		}
	}
	
	public sealed class ComplexTypeGenerated : IVerifiable<ComplexTypeGenerated>
	{
<#
foreach( Tuple<Object, string, string, bool> item in fields )
{
	String typeName;
	if( item.Item1 is Type )
	{
		typeName = ToTypeName( item.Item1 as Type );
	}
	else
	{
		typeName = ToTypeName( item.Item1 as Tuple<String, String[]> );
	}
	var asType = item.Item1 as Type;
	if( asType != null && desktopOnly.Contains( asType ) )
	{
#>
#if !SILVERLIGHT && !NETSTANDARD1_1
<#
	}
	else if( notInNet35.Contains( typeName ) )
	{
		if(notInSLWP.Contains( typeName ) )
		{
#>
#if !NET35 && !WINDOWS_PHONE
<#
		}
		else
		{
#>
#if !NET35
<#
		}
	}
	else if( asType != null && notInSL.Contains( asType ) )
	{
#>
#if !SILVERLIGHT
<#
	}
#>
		private <#= typeName #> _<#= ToFieldName( item ) #><#= item.Item4 ? String.Empty : " = " + GetSimpleInitializer( item ) #>;
		
		public <#= typeName #> <#= ToFieldName( item ) #>
		{
			get { return this._<#= ToFieldName( item ) #>; }
<#
	if( item.Item4 )
	{
#>
			set { this._<#= ToFieldName( item ) #> = value; }
<#
	}
#>
		}
<#
	if( asType != null && desktopOnly.Contains( asType ) )
	{
#>
#endif // !SILVERLIGHT && !NETSTANDARD1_1
<#
	}
	else if( notInNet35.Contains( typeName ) )
	{
		if(notInSLWP.Contains( typeName ) )
		{
#>
#endif // !NET35 && !WINDOWS_PHONE
<#
		}
		else
		{
#>
#endif // !NET35
<#
		}
	}
	else if( asType != null && notInSL.Contains( asType ) )
	{
#>
#endif // !SILVERLIGHT
<#
	}
}
#>

		public ComplexTypeGenerated Initialize()
		{
<#
foreach( Tuple<Object, string, string, bool> item in fields )
{
	String typeName;
	if( item.Item1 is Type )
	{
		typeName = ToTypeName( item.Item1 as Type );
	}
	else
	{
		typeName = ToTypeName( item.Item1 as Tuple<String, String[]> );
	}
	var asType = item.Item1 as Type;
	if( asType != null && desktopOnly.Contains( asType ) )
	{
#>
#if !NETFX_CORE && !SILVERLIGHT
<#
	}
	else if( notInNet35.Contains( typeName ) )
	{
		if(notInSLWP.Contains( typeName ) )
		{
#>
#if !NET35 && !WINDOWS_PHONE
<#
		}
		else
		{
#>
#if !NET35
<#
		}
	}
	else if( asType != null && notInSL.Contains( asType ) )
	{
#>
#if !SILVERLIGHT
<#
	}
#>
			this._<#= ToFieldName( item ) #> = <#= item.Item3 #>;
<#
	if( asType != null && desktopOnly.Contains( asType ) )
	{
#>
#endif // !NETFX_CORE && !SILVERLIGHT
<#
	}
	else if( notInNet35.Contains( typeName ) )
	{
		if(notInSLWP.Contains( typeName ) )
		{
#>
#endif // !NET35 && !WINDOWS_PHONE
<#
		}
		else
		{
#>
#endif // !NET35
<#
		}
	}
	else if( asType != null && notInSL.Contains( asType ) )
	{
#>
#endif // !SILVERLIGHT
<#
	}
}
#>
			return this;
		}

#if !SILVERLIGHT

		private static FILETIME ToFileTime( DateTime dateTime )
		{
			var fileTime = dateTime.ToFileTimeUtc();
			return new FILETIME(){ dwHighDateTime = unchecked( ( int )( fileTime >> 32 ) ), dwLowDateTime = unchecked( ( int )( fileTime & 0xffffffff ) ) };
		}

#endif // !SILVERLIGHT

		public void Verify( ComplexTypeGenerated expected )
		{
<#
foreach( Tuple<Object, string, string, bool> item in fields )
{
	String typeName;
	if( item.Item1 is Type )
	{
		typeName = ToTypeName( item.Item1 as Type );
	}
	else
	{
		typeName = ToTypeName( item.Item1 as Tuple<String, String[]> );
	}
	var asType = item.Item1 as Type;
	if( asType != null && desktopOnly.Contains( asType ) )
	{
#>
#if !NETFX_CORE && !SILVERLIGHT
<#
	}
	else if( notInNet35.Contains( typeName ) )
	{
		if(notInSLWP.Contains( typeName ) )
		{
#>
#if !NET35 && !WINDOWS_PHONE
<#
		}
		else
		{
#>
#if !NET35
<#
		}
	}
	else if( asType != null && notInSL.Contains( asType ) )
	{
#>
#if !SILVERLIGHT
<#
	}
#>
			AutoMessagePackSerializerTest.Verify( expected._<#= ToFieldName( item ) #>, this._<#= ToFieldName( item ) #> );
<#
	if( asType != null && desktopOnly.Contains( asType ) )
	{
#>
#endif // !NETFX_CORE && !SILVERLIGHT
<#
	}
	else if( notInNet35.Contains( typeName ) )
	{
		if(notInSLWP.Contains( typeName ) )
		{
#>
#endif // !NET35 && !WINDOWS_PHONE
<#
		}
		else
		{
#>
#endif // !NET35
<#
		}
	}
	else if( asType != null && notInSL.Contains( asType ) )
	{
#>
#endif // !SILVERLIGHT
<#
	}
}
#>		
		}
	}

	public struct ListValueType<T> : IList<T>
	{
		private readonly List<T> _underlying;

		public T this[ int index ]
		{
			get
			{
				if ( this._underlying == null )
				{
					throw new ArgumentOutOfRangeException( "index" );
				}

				return this._underlying[ index ];
			}
			set
			{
				if ( this._underlying == null )
				{
					throw new ArgumentOutOfRangeException( "index" );
				}

				this._underlying[ index ] = value;
			}
		}

		public int Count
		{
			get { return this._underlying == null ? 0 : this._underlying.Count; }
		}

		public ListValueType( int capacity )
		{
			this._underlying = new List<T>( capacity );
		}

		public void Add( T item )
		{
			this._underlying.Add( item );
		}

		public void CopyTo( T[] array, int arrayIndex )
		{
			this._underlying.CopyTo( array, arrayIndex );
		}

		public IEnumerator<T> GetEnumerator()
		{
			if ( this._underlying == null )
			{
				yield break;
			}

			foreach ( var item in this._underlying )
			{
				yield return item;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}

		public int IndexOf( T item )
		{
			throw new NotImplementedException();
		}

		public void Insert( int index, T item )
		{
			throw new NotImplementedException();
		}

		public void RemoveAt( int index )
		{
			throw new NotImplementedException();
		}

		public void Clear()
		{
			throw new NotImplementedException();
		}

		public bool Contains( T item )
		{
			throw new NotImplementedException();
		}

		public bool IsReadOnly
		{
			get { throw new NotImplementedException(); }
		}

		public bool Remove( T item )
		{
			throw new NotImplementedException();
		}
	}

	public struct DictionaryValueType<TKey, TValue> : IDictionary<TKey, TValue>
	{
		private readonly Dictionary<TKey, TValue> _underlying;

		public int Count
		{
			get { return this._underlying == null ? 0 : this._underlying.Count; }
		}

		public TValue this[ TKey key ]
		{
			get
			{
				if ( this._underlying == null )
				{
					throw new NotSupportedException();
				}

				return this._underlying[ key ];
			}
			set
			{
				if ( this._underlying == null )
				{
					throw new NotSupportedException();
				}

				this._underlying[ key ] = value;
			}
		}

		public DictionaryValueType( int capacity )
		{
			this._underlying = new Dictionary<TKey, TValue>( capacity, DictionaryTestHelper.GetEqualityComparer<TKey>() );
		}

		public void Add( TKey key, TValue value )
		{
			if ( this._underlying == null )
			{
				throw new NotSupportedException();
			}

			this._underlying.Add( key, value );
		}

		public void CopyTo( KeyValuePair<TKey, TValue>[] array, int arrayIndex )
		{
			if ( this._underlying == null )
			{
				return;
			}

			( this._underlying as ICollection<KeyValuePair<TKey, TValue>> ).CopyTo( array, arrayIndex );
		}

		public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
		{
			if ( this._underlying == null )
			{
				yield break;
			}

			foreach ( var entry in this._underlying )
			{
				yield return entry;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}

		public bool ContainsKey( TKey key )
		{
			throw new NotImplementedException();
		}

		public ICollection<TKey> Keys
		{
			get { throw new NotImplementedException(); }
		}

		public bool Remove( TKey key )
		{
			throw new NotImplementedException();
		}

		public bool TryGetValue( TKey key, out TValue value )
		{
			throw new NotImplementedException();
		}

		public ICollection<TValue> Values
		{
			get { throw new NotImplementedException(); }
		}

		public void Add( KeyValuePair<TKey, TValue> item )
		{
			this.Add( item.Key, item.Value );
		}

		public void Clear()
		{
			throw new NotImplementedException();
		}

		public bool Contains( KeyValuePair<TKey, TValue> item )
		{
			throw new NotImplementedException();
		}


		public bool IsReadOnly
		{
			get { throw new NotImplementedException(); }
		}

		public bool Remove( KeyValuePair<TKey, TValue> item )
		{
			throw new NotImplementedException();
		}
	}

	
	internal static class AutoMessagePackSerializerTest
	{
		internal static void Verify<T>( T expected, T actual )
		{
			if ( expected == null )
			{
				Assert.That( actual, Is.Null );
				return;
			}

			if ( expected.GetType().GetIsGenericType() && expected.GetType().GetGenericTypeDefinition() == typeof( ArraySegment<> ) )
			{
				AssertArraySegmentEquals( expected, actual );
				return;
			}

			if ( expected is DateTime )
			{
				Assert.That(
					( DateTime )( object )expected == ( DateTime )( object )actual,
					"Expected:{1:O}({2},{3}){0}Actual :{4:O}({5},{6})",
					Environment.NewLine,
					expected,
					expected == null ? "(null)" : expected.GetType().FullName,
					( ( DateTime )( object )expected ).Kind,
					actual,
					actual == null ? "(null)" : actual.GetType().FullName,
					( ( DateTime )( object )actual ).Kind
				);
				return;
			}
			else if ( expected is DateTimeOffset )
			{
				Assert.That(
					( DateTimeOffset )( object )expected == ( DateTimeOffset )( object )actual,
					"Expected:{1:O}({2}){0}Actual :{3:O}({4})",
					Environment.NewLine,
					expected,
					expected == null ? "(null)" : expected.GetType().FullName,
					actual,
					actual == null ? "(null)" : actual.GetType().FullName
				);
				return;
			}

			if ( expected is IDictionary )
			{
				var actuals = ( IDictionary )actual;
				foreach ( DictionaryEntry entry in ( ( IDictionary )expected ) )
				{
					Assert.That( actuals.Contains( entry.Key ), "'{0}' is not in '[{1}]'", entry.Key, String.Join( ", ", actuals.Keys.OfType<object>().Select( o => o == null ? String.Empty : o.ToString() ).ToArray() ) );
					Verify( entry.Value, actuals[ entry.Key ] );
				}
				return;
			}

			if ( expected is IEnumerable )
			{
				var expecteds = ( ( IEnumerable )expected ).Cast<Object>().ToArray();
				var actuals = ( ( IEnumerable )actual ).Cast<Object>().ToArray();
				Assert.That( expecteds.Length, Is.EqualTo( actuals.Length ) );
				for ( int i = 0; i < expecteds.Length; i++ )
				{
					Verify( expecteds[ i ], actuals[ i ] );
				}
				return;
			}

#if !NET35
			if ( expected is IStructuralEquatable )
			{
				Assert.That(
					( ( IStructuralEquatable )expected ).Equals( actual, EqualityComparer<object>.Default ),
					"Expected:{1}({2}){0}Actual :{3}({4})",
					Environment.NewLine,
					expected,
					expected == null ? "(null)" : expected.GetType().FullName,
					actual,
					actual == null ? "(null)" : actual.GetType().FullName
				);
				return;
			}
#endif

#if !SILVERLIGHT
			if ( expected is FILETIME )
			{
				var expectedFileTime = ( FILETIME )( object )expected;
				var actualFileTime = ( FILETIME )( object )actual;
				Verify(
					DateTime.FromFileTimeUtc( ( ( ( long )expectedFileTime.dwHighDateTime ) << 32 ) | ( expectedFileTime.dwLowDateTime & 0xffffffff ) ),
					DateTime.FromFileTimeUtc( ( ( ( long )actualFileTime.dwHighDateTime ) << 32 ) | ( actualFileTime.dwLowDateTime & 0xffffffff ) )
				);
				return;
			}
#endif // !SILVERLIGHT

			if ( expected.GetType().GetIsGenericType() && expected.GetType().GetGenericTypeDefinition() == typeof( KeyValuePair<,> ) )
			{
#if !NET35 && !AOT && !SILVERLIGHT
				Verify( ( ( dynamic )expected ).Key, ( ( dynamic )actual ).Key );
				Verify( ( ( dynamic )expected ).Value, ( ( dynamic )actual ).Value );
#else
				Assert.Ignore( ".NET 3.5 does not support dynamic." );
#endif // !NET35 && !AOT && !SILVERLIGHT
				return;
			}

			if ( expected is DictionaryEntry )
			{
				var expectedEntry = ( DictionaryEntry )( object )expected;
				var actualEntry = ( DictionaryEntry )( object )actual;

				if ( expectedEntry.Key == null )
				{
					Assert.That( ( ( MessagePackObject )actualEntry.Key ).IsNil );
				}
				else
				{
					Verify( ( MessagePackObject )expectedEntry.Key, ( MessagePackObject )actualEntry.Key );
				}


				if ( expectedEntry.Value == null )
				{
					Assert.That( ( ( MessagePackObject )actualEntry.Value ).IsNil );
				}
				else
				{
					Verify( ( MessagePackObject )expectedEntry.Value, ( MessagePackObject )actualEntry.Value );
				}

				return;
			}

			Assert.That(
#if !UNITY
				EqualityComparer<T>.Default.Equals( expected, actual ),
#else
				AotHelper.GetEqualityComparer<T>().Equals( expected, actual ),
#endif // !UNITY
				"Expected:{1}({2}){0}Actual :{3}({4})",
				Environment.NewLine,
				expected,
				expected == null ? "(null)" : expected.GetType().FullName,
				actual,
				actual == null ? "(null)" : actual.GetType().FullName
			);
		}
		
		private static void AssertArraySegmentEquals( object x, object y )
		{
#if !NETFX_CORE && !NETSTANDARD1_1 && !NETSTANDARD1_3
			var type = typeof( ArraySegmentEqualityComparer<> ).MakeGenericType( x.GetType().GetGenericArguments()[ 0 ] );
			Assert.That(
				( bool )type.InvokeMember( "Equals", BindingFlags.InvokeMethod, null, Activator.CreateInstance( type ), new[] { x, y } ),
				"Expected:{1}{0}Actual :{2}",
				Environment.NewLine,
				x,
				y
			);
#else
			var elementType = x.GetType().GetTypeInfo().GenericTypeArguments[ 0 ];
			var type = typeof( ArraySegmentEqualityComparer<> ).MakeGenericType( elementType );
			Assert.That(
				( bool )type.GetRuntimeMethod( "Equals", new[] { x.GetType(), x.GetType() } ).Invoke( Activator.CreateInstance( type ), new[] { x, y } ),
				"Expected:{1}{0}Actual :{2}",
				Environment.NewLine,
				x,
				y
			);
#endif // !NETFX_CORE && !NETSTANDARD1_1 && !NETSTANDARD1_3
		}
	}
	
	public class WithAbstractInt32Collection
	{
		public IList<int> Collection { get; set; }
	}
	
	public class WithAbstractStringCollection
	{
		public IList<string> Collection { get; set; }
	}

	public class WithAbstractNonCollection
	{
		public Stream NonCollection { get; set; }
	}

	public class HasEnumerable
	{
		public IEnumerable<int> Numbers { get; set; }
	}

	public class AnnotatedDateTimes
	{
		public DateTime VanillaDateTimeProperty { get; set; }

		public DateTime VanillaDateTimeField;


		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.Default )]
		public DateTime DefaultDateTimeProperty { get; set; }

		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.Default )]
		public DateTime DefaultDateTimeField;


		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.Native )]
		public DateTime NativeDateTimeProperty { get; set; }

		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.Native )]
		public DateTime NativeDateTimeField;


		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.UnixEpoc )]
		public DateTime UnixEpocDateTimeProperty { get; set; }

		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.UnixEpoc )]
		public DateTime UnixEpocDateTimeField;

		
		
		public DateTimeOffset VanillaDateTimeOffsetProperty { get; set; }
		
		public DateTimeOffset VanillaDateTimeOffsetField;
		
		
		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.Default )]
		public DateTimeOffset DefaultDateTimeOffsetProperty { get; set; }
		
		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.Default )]
		public DateTimeOffset DefaultDateTimeOffsetField;
		
		
		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.Native )]
		public DateTimeOffset NativeDateTimeOffsetProperty { get; set; }
		
		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.Native )]
		public DateTimeOffset NativeDateTimeOffsetField;
		
		
		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.UnixEpoc )]
		public DateTimeOffset UnixEpocDateTimeOffsetProperty { get; set; }
		
		[MessagePackDateTimeMember( DateTimeConversionMethod = DateTimeMemberConversionMethod.UnixEpoc )]
		public DateTimeOffset UnixEpocDateTimeOffsetField;



		public AnnotatedDateTimes() {}

		public AnnotatedDateTimes( DateTimeOffset now )
		{
			VanillaDateTimeProperty = now.DateTime;
			VanillaDateTimeField = now.DateTime.AddDays( 1 );
			DefaultDateTimeProperty = now.DateTime.AddDays( 2 );
			DefaultDateTimeField = now.DateTime.AddDays( 3 );
			NativeDateTimeProperty = now.DateTime.AddDays( 4 );
			NativeDateTimeField = now.DateTime.AddDays( 5 );
			UnixEpocDateTimeProperty = now.DateTime.AddDays( 6 );
			UnixEpocDateTimeField = now.DateTime.AddDays( 7 );
			VanillaDateTimeOffsetProperty = now.AddDays( 8 );
			VanillaDateTimeOffsetField = now.AddDays( 9 );
			DefaultDateTimeOffsetProperty = now.AddDays( 10 );
			DefaultDateTimeOffsetField = now.AddDays( 11 );
			NativeDateTimeOffsetProperty = now.AddDays( 12 );
			NativeDateTimeOffsetField = now.AddDays( 13 );
			UnixEpocDateTimeOffsetProperty = now.AddDays( 14 );
			UnixEpocDateTimeOffsetField = now.AddDays( 15 );
		}
	}

	internal class DictionaryTestHelper
	{
		public static IEqualityComparer<T> GetEqualityComparer<T>()
		{
#if !UNITY
			return EqualityComparer<T>.Default;
#else
			return AotHelper.GetEqualityComparer<T>();
#endif // !UNITY
		}
	}

#if !UNITY
	// Mono 2.7.3 AOT fails when these classes are used...
	// Issue 119
	public abstract class GenericClass<T>
	{
		public T GenericField;
		public virtual T GenericProperty { get; internal set; }

		public GenericClass() {}
	}

	public class GenericValueClass : GenericClass<int> { }

	public class GenericReferenceClass : GenericClass<string> { }

	public abstract class GenericRecordClass<T>
	{
		public readonly T GenericField;

		private readonly T _genericProperty;
		public virtual T GenericProperty { get { return this._genericProperty; } }

		public GenericRecordClass( T genericField, T genericProperty )
		{
			this.GenericField = genericField;
			this._genericProperty = genericProperty;
		}
	}

	public class GenericRecordValueClass : GenericRecordClass<int>
	{
		public GenericRecordValueClass( int genericField, int genericProperty )
			: base( genericField, genericProperty )	{ }
	}

	public class GenericRecordReferenceClass : GenericRecordClass<string>
	{
		public GenericRecordReferenceClass( string genericField, string genericProperty )
			: base( genericField, genericProperty )	{ }
	}
#endif // !UNITY

	// Issue 150
	public class PackableUnpackableImplementedExplictly
		: IPackable, IUnpackable
#if FEATURE_TAP
		, IAsyncPackable, IAsyncUnpackable
#endif // FEATURE_TAP
	{
		public const string PackingPrefix = "Packed:";
		public const string UnpackingPrefix = "Unpacked:";
		public string Data { get; set; }

		private void PackToMessageCore( Packer packer )
		{
			packer.PackArrayHeader( 1 );
			packer.Pack( PackingPrefix + this.Data );
		}

		void IPackable.PackToMessage( Packer packer, PackingOptions options )
		{
			this.PackToMessageCore( packer );
		}

		private void UnpackFromMessageCore( Unpacker unpacker )
		{
			if ( !unpacker.IsArrayHeader )
			{
				SerializationExceptions.ThrowIsNotArrayHeader( unpacker );
			}

			if ( unpacker.LastReadData != 1 )
			{
				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker, typeof( PackableUnpackableImplementedExplictly ), 1 );
			}

			string data;
			if ( !unpacker.ReadString( out data ) )
			{
				SerializationExceptions.ThrowMissingItem( 0, unpacker );
			}

			this.Data = UnpackingPrefix + data;
		}

		void IUnpackable.UnpackFromMessage( Unpacker unpacker )
		{
			this.UnpackFromMessageCore( unpacker );
		}

#if FEATURE_TAP

		Task IAsyncPackable.PackToMessageAsync( Packer packer, PackingOptions options, CancellationToken cancellationToken )
		{
			return Task.Run( () => this.PackToMessageCore( packer ), cancellationToken );
		}

		Task IAsyncUnpackable.UnpackFromMessageAsync( Unpacker unpacker, CancellationToken cancellationToken )
		{
			return Task.Run( () => this.UnpackFromMessageCore( unpacker ), cancellationToken );
		}

#endif // FEATURE_TAP
	}

#pragma warning disable 0114
<#
foreach ( var collection in new []
	{
		"Enumerable",
		"Collection",
		"List",
		"Dictionary",
		"NonGenericEnumerable",
		"NonGenericCollection",
		"NonGenericList",
		"NonGenericDictionary"
	}
)
{
	foreach ( var isUnpackable in new [] { false, true } )
	{
		foreach ( var isPackable in new [] { false, true } )
		{
			if ( !isPackable && !isUnpackable )
			{
				continue;
			}

			var comnination = 
				isPackable
					? ( isUnpackable ? "PackableUnpackable" : "Packable" )
					: "Unpackable";
				var typeName = comnination + collection;
			var genericArgument = collection.StartsWith( "NonGeneric" ) ? String.Empty : "<int>";
#>
	public class <#= typeName #> : <#= collection#>Base<#= genericArgument#>
<#
			if ( isPackable )
			{
#>
	, IPackable
#if FEATURE_TAP
	, IAsyncPackable
#endif // FEATURE_TAP
<#
			}

			if ( isUnpackable )
			{
#>
	, IUnpackable
#if FEATURE_TAP
	, IAsyncUnpackable
#endif // FEATURE_TAP
<#
			}
#>
	{
		public int Capacity { get; private set; }

		public <#= typeName #>() : this( -1 ) { }

		public <#= typeName #>( int capacity )
		{
			this.Capacity = capacity;
		}

		public void Initialize( params int[] items )
		{
			foreach( var item in items )
			{
<#
			if ( collection.Contains( "Dictionary" ) )
			{
#>
				this.Underlying.Add( item, item );
<#
			}
			else
			{
#>
				this.Underlying.Add( item );
<#
			}
#>
			}
		}

		public int[] GetValues()
		{
			return
				this.Underlying
<#
			if ( collection.Contains( "Dictionary" ) )
			{
#>
				.Values
<#
			}

			if ( collection.StartsWith( "NonGeneric" ) )
			{
#>
				.Cast<int>()
<#
			}
#>
				.ToArray();
		}

<#
			if ( collection.Contains( "Enumerable" ) || collection.Contains( "NonGenericCollection" ) )
			{
#>
		// To avoid SerializationException
		public void Add( object item )
		{
			this.Underlying.Add( ( int )item );
		}
<#
			}
#>

<#
				if ( isPackable )
				{
#>
		public void PackToMessage( Packer packer, PackingOptions options )
		{
<#
			if ( collection.Contains( "Dictionary" ) )
			{
#>
				packer.PackMapHeader( 1 );
				packer.Pack( 0 );
				packer.Pack( 0 );
<#
			}
			else
			{
#>
				packer.PackArrayHeader( 1 );
				packer.Pack( 0 );
<#
			}
#>
		}

#if FEATURE_TAP
		public async Task PackToMessageAsync( Packer packer, PackingOptions options, CancellationToken cancellationToken )
		{
			await Task.Run( () => this.PackToMessage( packer, options ), cancellationToken ).ConfigureAwait( false );
		}
#endif // FEATURE_TAP

<#
			}

			if ( isUnpackable )
			{
#>
		public void UnpackFromMessage( Unpacker unpacker )
		{
<#
			if ( collection.Contains( "Dictionary" ) )
			{
#>
			this.Underlying.Add( 0, 0 );
			this.Underlying.Add( 1, 0 );
<#
			}
			else
			{
#>
			this.Underlying.Add( 0 );
			this.Underlying.Add( 0 );
<#
			}
#>
		}

#if FEATURE_TAP
		public async Task UnpackFromMessageAsync( Unpacker unpacker, CancellationToken cancellationToken )
		{
			await Task.Run( () => this.UnpackFromMessage( unpacker ), cancellationToken ).ConfigureAwait( false );
		}
#endif // FEATURE_TAP
<#
			}
#>
	}

<#
		} // isPackable
	} // isUnpackable
} // collection
#>
#pragma warning restore 0114

<#
GeneratePolymorphismTestTypes();
#>

	// Issue170
	public class ClassHasStaticField
	{
		public string m_string;
		public static int m_int = 1000;

		public ClassHasStaticField()
		{
			m_string = "dummy";
			m_int = 1000;
		}
	}

		
	// Issue 169
	public class GenericNonCollectionType : IEnumerable<int>
	{
		public int Property { get; set; }

		public IEnumerator<int> GetEnumerator()
		{
			yield break;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
	}

	public class NonGenericNonCollectionType : IEnumerable
	{
		public int Property { get; set; }

		public IEnumerator GetEnumerator()
		{
			yield break;
		}
	}

<#
foreach( var spec in
	new []
	{
		new { Prefix = "", 						IsCollection = false,	Type = "string", Default = "\"ABC\"" },
		new { Prefix = "AppendableCollection",	IsCollection = true,	Type = "List<string>", Default = "new List<string>()" },
	}
)
{
#>

	public class HasInitOnly<#= spec.Prefix #>FieldWithDefaultConstructor
	{
		public readonly <#= spec.Type #> Member;

		public void InitializeMember( <#= spec.Type #> member )
		{
#if SILVERLIGHT && !SILVERLIGHT_PRIVILEGED
			Assert.Inconclusive( "Cannot run this test in restricted Silverlight because of CAS." );
#endif // SILVERLIGHT && !SILVERLIGHT_PRIVILEGED

			this.GetType().GetRuntimeField( "Member" ).SetValue( this, member );
		}

		public HasInitOnly<#= spec.Prefix #>FieldWithDefaultConstructor()
		{
			this.Member = <#= spec.Default #>;
		}
	}

	public class HasInitOnly<#= spec.Prefix #>FieldWithRecordConstructor
	{
		public readonly <#= spec.Type #> Member;

		public HasInitOnly<#= spec.Prefix #>FieldWithRecordConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}
	}

	public class HasInitOnly<#= spec.Prefix #>FieldWithBothConstructor
	{
		private readonly bool _wasProperConstructorUsed;
		public readonly <#= spec.Type #> Member;

		public HasInitOnly<#= spec.Prefix #>FieldWithBothConstructor()
		{
			this.Member = <#= spec.Default #>;
<#
	if ( spec.IsCollection )
	{
#>
			// Collection is appendable, so default constructor should be used.
			this._wasProperConstructorUsed = true;
<#
	}
#>
		}

		public HasInitOnly<#= spec.Prefix #>FieldWithBothConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
<#
	if ( !spec.IsCollection )
	{
#>
			// Scalar is not appendable, so parameterful constructor should be used.
			this._wasProperConstructorUsed = true;
<#
	}
#>
		}

		public bool WasProperConstructorUsed()
		{
			return this._wasProperConstructorUsed;
		}
	}
	
	public class HasInitOnly<#= spec.Prefix #>FieldWithAnnotatedConstructor
	{
		private readonly bool _wasProperConstructorUsed;
		public readonly <#= spec.Type #> Member;

		public HasInitOnly<#= spec.Prefix #>FieldWithAnnotatedConstructor()
		{
			this.Member = <#= spec.Default #>;
		}

		public HasInitOnly<#= spec.Prefix #>FieldWithAnnotatedConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}
		
		[MessagePackDeserializationConstructor]
		public HasInitOnly<#= spec.Prefix #>FieldWithAnnotatedConstructor( int dummy ) : this( <#= spec.Default #> )
		{
			this._wasProperConstructorUsed = true;
		}

		public bool WasProperConstructorUsed()
		{
			return this._wasProperConstructorUsed;
		}
	}

	public class HasReadWrite<#= spec.Prefix #>FieldWithDefaultConstructor
	{
		public <#= spec.Type #> Member = <#= spec.Default #>;

		public void InitializeMember( <#= spec.Type #> member )
		{
			this.Member = member;
		}

		public HasReadWrite<#= spec.Prefix #>FieldWithDefaultConstructor()
		{
			this.Member = <#= spec.Default #>;
		}
	}

	public class HasReadWrite<#= spec.Prefix #>FieldWithRecordConstructor
	{
		public <#= spec.Type #> Member;

		public HasReadWrite<#= spec.Prefix #>FieldWithRecordConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}
	}

	public class HasReadWrite<#= spec.Prefix #>FieldWithBothConstructor
	{
		private readonly bool _wasProperConstructorUsed;
		public <#= spec.Type #> Member;

		public HasReadWrite<#= spec.Prefix #>FieldWithBothConstructor()
		{
			this.Member = <#= spec.Default #>;
			this._wasProperConstructorUsed = true;
		}

		public HasReadWrite<#= spec.Prefix #>FieldWithBothConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}

		public bool WasProperConstructorUsed()
		{
			return this._wasProperConstructorUsed;
		}
	}
	
	public class HasReadWrite<#= spec.Prefix #>FieldWithAnnotatedConstructor
	{
		private readonly bool _wasProperConstructorUsed;
		public <#= spec.Type #> Member;

		public HasReadWrite<#= spec.Prefix #>FieldWithAnnotatedConstructor()
		{
			this.Member = <#= spec.Default #>;
		}

		public HasReadWrite<#= spec.Prefix #>FieldWithAnnotatedConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}
		
		[MessagePackDeserializationConstructor]
		public HasReadWrite<#= spec.Prefix #>FieldWithAnnotatedConstructor( int dummy ) : this( <#= spec.Default #> )
		{
			this._wasProperConstructorUsed = true;
		}

		public bool WasProperConstructorUsed()
		{
			return this._wasProperConstructorUsed;
		}
	}

	public class HasGetOnly<#= spec.Prefix #>PropertyWithDefaultConstructor
	{
		private <#= spec.Type #> _member = <#= spec.Default #>;
		public <#= spec.Type #> Member { get { return this._member; } }

		public void InitializeMember( <#= spec.Type #> member )
		{
			this._member = member;
		}

		public HasGetOnly<#= spec.Prefix #>PropertyWithDefaultConstructor()
		{
			this._member = <#= spec.Default #>;
		}
	}

	public class HasGetOnly<#= spec.Prefix #>PropertyWithRecordConstructor
	{
		private readonly <#= spec.Type #> _member;
		public <#= spec.Type #> Member { get { return this._member; } }

		public HasGetOnly<#= spec.Prefix #>PropertyWithRecordConstructor( <#= spec.Type #> member )
		{
			this._member = member;
		}
	}

	public class HasGetOnly<#= spec.Prefix #>PropertyWithBothConstructor
	{
		private readonly bool _wasProperConstructorUsed;
		private readonly <#= spec.Type #> _member;
		public <#= spec.Type #> Member { get { return this._member; } }

		public HasGetOnly<#= spec.Prefix #>PropertyWithBothConstructor()
		{
			this._member = <#= spec.Default #>;
<#
	if ( spec.IsCollection )
	{
#>
			// Collection is appendable, so default constructor should be used.
			this._wasProperConstructorUsed = true;
<#
	}
#>
		}

		public HasGetOnly<#= spec.Prefix #>PropertyWithBothConstructor( <#= spec.Type #> member )
		{
			this._member = member;
<#
	if ( !spec.IsCollection )
	{
#>
			// Scalar is not appendable, so parameterful constructor should be used.
			this._wasProperConstructorUsed = true;
<#
	}
#>
		}

		public bool WasProperConstructorUsed()
		{
			return this._wasProperConstructorUsed;
		}
	}

	public class HasGetOnly<#= spec.Prefix #>PropertyWithAnnotatedConstructor
	{
		private readonly bool _wasProperConstructorUsed;
		private readonly <#= spec.Type #> _member;
		public <#= spec.Type #> Member { get { return this._member; } }

		public HasGetOnly<#= spec.Prefix #>PropertyWithAnnotatedConstructor()
		{
			this._member = <#= spec.Default #>;
		}

		public HasGetOnly<#= spec.Prefix #>PropertyWithAnnotatedConstructor( <#= spec.Type #> member )
		{
			this._member = member;
		}
		
		[MessagePackDeserializationConstructor]
		public HasGetOnly<#= spec.Prefix #>PropertyWithAnnotatedConstructor( int dummy ) : this( <#= spec.Default #> )
		{
			this._wasProperConstructorUsed = true;
		}

		public bool WasProperConstructorUsed()
		{
			return this._wasProperConstructorUsed;
		}
	}

	public class HasPrivateSetter<#= spec.Prefix #>PropertyWithDefaultConstructor
	{
		public <#= spec.Type #> Member { get; private set; }

		public void InitializeMember( <#= spec.Type #> member )
		{
			this.Member = member;
		}

		public HasPrivateSetter<#= spec.Prefix #>PropertyWithDefaultConstructor()
		{
			this.Member = <#= spec.Default #>;
		}
	}

	public class HasPrivateSetter<#= spec.Prefix #>PropertyWithRecordConstructor
	{
		public <#= spec.Type #> Member { get; private set; }

		public HasPrivateSetter<#= spec.Prefix #>PropertyWithRecordConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}
	}

	public class HasPrivateSetter<#= spec.Prefix #>PropertyWithBothConstructor
	{
		private readonly bool _wasProperConstructorUsed;
		public <#= spec.Type #> Member { get; private set; }

		public HasPrivateSetter<#= spec.Prefix #>PropertyWithBothConstructor()
		{
			this.Member = <#= spec.Default #>;
			// setter should be used via reflection for backward compatibility here.
			this._wasProperConstructorUsed = true;
		}

		public HasPrivateSetter<#= spec.Prefix #>PropertyWithBothConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}

		public bool WasProperConstructorUsed()
		{
			return this._wasProperConstructorUsed;
		}
	}

	public class HasPrivateSetter<#= spec.Prefix #>PropertyWithAnnotatedConstructor
	{
		private readonly bool _wasProperConstructorUsed;
		public <#= spec.Type #> Member { get; private set; }

		public HasPrivateSetter<#= spec.Prefix #>PropertyWithAnnotatedConstructor()
		{
			this.Member = <#= spec.Default #>;
		}

		public HasPrivateSetter<#= spec.Prefix #>PropertyWithAnnotatedConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}
		
		[MessagePackDeserializationConstructor]
		public HasPrivateSetter<#= spec.Prefix #>PropertyWithAnnotatedConstructor( int dummy ) : this( <#= spec.Default #> )
		{
			this._wasProperConstructorUsed = true;
		}

		public bool WasProperConstructorUsed()
		{
			return this._wasProperConstructorUsed;
		}
	}

	public class HasPublicSetter<#= spec.Prefix #>PropertyWithDefaultConstructor
	{
		public <#= spec.Type #> Member { get; set; }

		public void InitializeMember( <#= spec.Type #> member )
		{
			this.Member = member;
		}

		public HasPublicSetter<#= spec.Prefix #>PropertyWithDefaultConstructor()
		{
			this.Member = <#= spec.Default #>;
		}
	}

	public class HasPublicSetter<#= spec.Prefix #>PropertyWithRecordConstructor
	{
		public <#= spec.Type #> Member { get; set; }

		public HasPublicSetter<#= spec.Prefix #>PropertyWithRecordConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}
	}

	public class HasPublicSetter<#= spec.Prefix #>PropertyWithBothConstructor
	{
		private readonly bool _wasProperConstructorUsed;
		public <#= spec.Type #> Member { get; set; }

		public HasPublicSetter<#= spec.Prefix #>PropertyWithBothConstructor()
		{
			this.Member = <#= spec.Default #>;
			this._wasProperConstructorUsed = true;
		}

		public HasPublicSetter<#= spec.Prefix #>PropertyWithBothConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}

		public bool WasProperConstructorUsed()
		{
			return this._wasProperConstructorUsed;
		}
	}

	public class HasPublicSetter<#= spec.Prefix #>PropertyWithAnnotatedConstructor
	{
		private readonly bool _wasProperConstructorUsed;
		public <#= spec.Type #> Member { get; set; }

		public HasPublicSetter<#= spec.Prefix #>PropertyWithAnnotatedConstructor() { }

		public HasPublicSetter<#= spec.Prefix #>PropertyWithAnnotatedConstructor( <#= spec.Type #> member )
		{
			this.Member = member;
		}
		
		[MessagePackDeserializationConstructor]
		public HasPublicSetter<#= spec.Prefix #>PropertyWithAnnotatedConstructor( int dummy ) : this( <#= spec.Default #> )
		{
			this._wasProperConstructorUsed = true;
		}

		public bool WasProperConstructorUsed()
		{
			return this._wasProperConstructorUsed;
		}
	}
<#
}
#>

	public class WithAnotherNameConstructor
	{
		public readonly int ReadOnlySame;
		public readonly int ReadOnlyDiffer;

		public WithAnotherNameConstructor( int readonlysame, int the2 )
		{
			this.ReadOnlySame = readonlysame;
			this.ReadOnlyDiffer = the2;
		}
	}

	public class WithAnotherTypeConstructor
	{
		public readonly int ReadOnlySame;
		public readonly string ReadOnlyDiffer;

		public WithAnotherTypeConstructor( int readonlysame, int the2 )
		{
			this.ReadOnlySame = readonlysame;
			this.ReadOnlyDiffer = the2.ToString();
		}
	}

	public class WithConstructorAttribute
	{
		public readonly int Value;
		public readonly bool IsAttributePreferred;

		public WithConstructorAttribute( int value, bool isAttributePreferred )
		{
			this.Value = value;
			this.IsAttributePreferred = isAttributePreferred;
		}

		[MessagePackDeserializationConstructor]
		public WithConstructorAttribute( int value ) : this( value, true ) {}
	}

	public class WithMultipleConstructorAttributes
	{
		public readonly int Value;

		[MessagePackDeserializationConstructor]
		public WithMultipleConstructorAttributes( int value, string arg ) { }

		[MessagePackDeserializationConstructor]
		public WithMultipleConstructorAttributes( int value, bool arg ) { }
	}
#pragma warning disable 3001
<#
foreach ( var item in constructorParamterSpecs )
{
#>
		public class WithOptionalConstructorParameter<#= item.Key #>
		{
			public readonly <#= item.Key #> Value;

			public WithOptionalConstructorParameter<#= item.Key #>( <#= item.Key #> value = <#= item.Value #> )
			{
				this.Value = value;
			}
		}
<#
}
#>
#pragma warning restore 3001

	public class JustPackable : IPackable
	{
		public const string Dummy = "1";

		public int Int32Field { get; set; }

		public void PackToMessage( Packer packer, PackingOptions options )
		{
			packer.PackArrayHeader( 1 );
			packer.PackString( Dummy );
		}
	}

	public class JustUnpackable : IUnpackable
	{
		public const string Dummy = "1";

		public int Int32Field { get; set; }

		public void UnpackFromMessage( Unpacker unpacker )
		{
			unpacker.UnpackSubtreeData();
			this.Int32Field = Int32.Parse( Dummy );
		}
	}

	public class PackableUnpackable : IPackable, IUnpackable
	{
		public const string Dummy = "1";

		public int Int32Field { get; set; }

		public void PackToMessage( Packer packer, PackingOptions options )
		{
			packer.PackArrayHeader( 1 );
			packer.PackString( Dummy );
		}

		public void UnpackFromMessage( Unpacker unpacker )
		{
			unpacker.UnpackSubtreeData();
			this.Int32Field = Int32.Parse( Dummy );
		}
	}

#if FEATURE_TAP
#pragma warning disable 1998

	public class JustAsyncPackable : IAsyncPackable
	{
		public const string Dummy = "1";

		public int Int32Field { get; set; }

		public async Task PackToMessageAsync( Packer packer, PackingOptions options, CancellationToken cancellationToken )
		{
			packer.PackArrayHeader( 1 );
			packer.PackString( Dummy );
		}
	}

	public class JustAsyncUnpackable : IAsyncUnpackable
	{
		public const string Dummy = "1";

		public int Int32Field { get; set; }

		public async Task UnpackFromMessageAsync( Unpacker unpacker, CancellationToken cancellationToken )
		{
			unpacker.UnpackSubtreeData();
			this.Int32Field = Int32.Parse( Dummy );
		}
	}

	public class AsyncPackableUnpackable : IAsyncPackable, IAsyncUnpackable
	{
		public const string Dummy = "1";

		public int Int32Field { get; set; }

		public async Task PackToMessageAsync( Packer packer, PackingOptions options, CancellationToken cancellationToken )
		{
			packer.PackArrayHeader( 1 );
			packer.PackString( Dummy );
		}

		public async Task UnpackFromMessageAsync( Unpacker unpacker, CancellationToken cancellationToken )
		{
			unpacker.UnpackSubtreeData();
			this.Int32Field = Int32.Parse( Dummy );
		}
	}

	public class FullPackableUnpackable : IPackable, IUnpackable, IAsyncPackable, IAsyncUnpackable
	{
		public const string Dummy = "1";

		public int Int32Field { get; set; }

		public void PackToMessage( Packer packer, PackingOptions options )
		{
			packer.PackArrayHeader( 1 );
			packer.PackString( Dummy );
		}

		public void UnpackFromMessage( Unpacker unpacker )
		{
			unpacker.UnpackSubtreeData();
			this.Int32Field = Int32.Parse( Dummy );
		}

		public async Task PackToMessageAsync( Packer packer, PackingOptions options, CancellationToken cancellationToken )
		{
			this.PackToMessage( packer, options );
		}

		public async Task UnpackFromMessageAsync( Unpacker unpacker, CancellationToken cancellationToken )
		{
			this.UnpackFromMessage( unpacker );
		}
	}

#pragma warning restore 1998
#endif // FEATURE_TAP

	public class CustomDateTimeSerealizer : MessagePackSerializer<DateTime>
	{
		private const byte _typeCodeForDateTimeForUs = 1;

		public CustomDateTimeSerealizer()
			: base( SerializationContext.Default ) {}

		protected internal override void PackToCore( Packer packer, DateTime objectTree )
		{
			byte[] data;
			if ( BitConverter.IsLittleEndian )
			{
				data = BitConverter.GetBytes( objectTree.ToUniversalTime().Ticks ).Reverse().ToArray();
			}
			else
			{
				data = BitConverter.GetBytes( objectTree.ToUniversalTime().Ticks );
			}

			packer.PackExtendedTypeValue( _typeCodeForDateTimeForUs, data );
		}

		protected internal override DateTime UnpackFromCore( Unpacker unpacker )
		{
			var ext = unpacker.LastReadData.AsMessagePackExtendedTypeObject();
			Assert.That( ext.TypeCode, Is.EqualTo( 1 ) );
			return new DateTime( BigEndianBinary.ToInt64( ext.Body, 0 ) ).ToUniversalTime();
		}
	}

	// Issue #25

	public class Person : IEnumerable<Person>
	{
		public string Name { get; set; }

		internal IEnumerable<Person> Children { get; set; }

		public IEnumerator<Person> GetEnumerator()
		{
			return Children.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	public class PersonSerializer : MessagePackSerializer<Person>
	{
		public PersonSerializer()
			: base( SerializationContext.Default ) {}

		protected internal override void PackToCore( Packer packer, Person objectTree )
		{
			packer.PackMapHeader( 2 );
			packer.PackString( "Name" );
			packer.PackString( objectTree.Name );
			packer.PackString( "Children" );
			if ( objectTree.Children == null )
			{
				packer.PackNull();
			}
			else
			{
				this.PackPeople( packer, objectTree.Children );
			}
		}

		internal void PackPeople( Packer packer, IEnumerable<Person> people )
		{
			var children = people.ToArray();

			packer.PackArrayHeader( children.Length );
			foreach ( var child in children )
			{
				this.PackTo( packer, child );
			}
		}

		protected internal override Person UnpackFromCore( Unpacker unpacker )
		{
			Assert.That( unpacker.IsMapHeader );
			Assert.That( unpacker.ItemsCount, Is.EqualTo( 2 ) );
			var person = new Person();
			for ( int i = 0; i < 2; i++ )
			{
				string key;
				Assert.That( unpacker.ReadString( out key ) );
				switch ( key )
				{
					case "Name":
					{

						string name;
						Assert.That( unpacker.ReadString( out name ) );
						person.Name = name;
						break;
					}
					case "Children":
					{
						Assert.That( unpacker.Read() );
						if ( !unpacker.LastReadData.IsNil )
						{
							person.Children = this.UnpackPeople( unpacker );
						}
						break;
					}
				}
			}

			return person;
		}

		internal IEnumerable<Person> UnpackPeople( Unpacker unpacker )
		{
			Assert.That( unpacker.IsArrayHeader );
			var itemsCount = ( int )unpacker.ItemsCount;
			var people = new List<Person>( itemsCount );
			for ( int i = 0; i < itemsCount; i++ )
			{
				people.Add( this.UnpackFrom( unpacker ) );
			}

			return people;
		}
	}

	public class ChildrenSerializer : MessagePackSerializer<IEnumerable<Person>>
	{
		private readonly PersonSerializer _personSerializer = new PersonSerializer();

		public ChildrenSerializer()
			: base( SerializationContext.Default ) {}

		protected internal override void PackToCore( Packer packer, IEnumerable<Person> objectTree )
		{
			if ( objectTree is Person )
			{
				this._personSerializer.PackTo( packer, objectTree as Person );
			}
			else
			{
				this._personSerializer.PackPeople( packer, objectTree );
			}
		}

		protected internal override IEnumerable<Person> UnpackFromCore( Unpacker unpacker )
		{
			return this._personSerializer.UnpackPeople( unpacker );
		}
	}

	#region -- Issue 207 --

	public class ReadOnlyAndConstructor
	{
		public readonly Guid Id;

		public readonly List<int> Ints;

		public ReadOnlyAndConstructor( Guid id, List<int> ints )
		{
			this.Id = id;
			this.Ints = ints;
		}
	}

	public class GetOnlyAndConstructor
	{
		public Guid Id { get; }

		public List<int> Ints { get; }

		public GetOnlyAndConstructor( Guid id, List<int> ints )
		{
			this.Id = id;
			this.Ints = ints;
		}
	}

	#endregion -- Issue 207 --

	#region -- Asymmetric --

<#
foreach ( var typeName in new [] { "NoSettableNoConstructorsForAsymmetricTest", "NoSettableMultipleConstructorsForAsymmetricTest", "NoDefaultConstructorForAsymmetricTest" } )
{
#>
	public partial class <#= typeName #>
	{
		private string _value;

		public override bool Equals( object obj )
		{
			var other = obj as <#= typeName #>;
			if ( Object.ReferenceEquals( other, null ) )
			{
				return false;
			}

			return this._value == other._value;
		}

		public override int GetHashCode()
		{
			return this._value.GetHashCode();
		}
	}

<#
}
#>
	partial class NoSettableNoConstructorsForAsymmetricTest
	{
		public string Value { get { return this._value; } }

		public NoSettableNoConstructorsForAsymmetricTest() { }

		public NoSettableNoConstructorsForAsymmetricTest Initialize( string value )
		{
			this._value = value;
			return this;
		}
	}

	partial class NoSettableMultipleConstructorsForAsymmetricTest
	{
		public string Value { get { return this._value; } }

		public NoSettableMultipleConstructorsForAsymmetricTest( string value, bool other )
		{
			this._value = value;
		}

		public NoSettableMultipleConstructorsForAsymmetricTest( string value, int other )
		{
			this._value = value;
		}
	}
	
	partial class NoDefaultConstructorForAsymmetricTest
	{
		public string Value
		{
			get { return this._value; }
			set { this._value = value; }
		}

		public NoDefaultConstructorForAsymmetricTest( char value )
		{
			this._value = value.ToString();
		}
	}

<#
foreach ( var kind in
	new []
	{
		new { Type = "Enumerable",	IsDictionary = false },
		new { Type = "Collection", 	IsDictionary = false },
		new { Type = "List", 		IsDictionary = false },
		new { Type = "Dictionary", 	IsDictionary = true },
	}
)
{
	foreach ( var generic in new [] { true, false } )
	{
		var typeName = "Unconstructable" + ( generic ? String.Empty : "NonGeneric" ) + kind.Type + "ForAsymmetricTest";
#>

	public sealed class <#= typeName #> : <#= generic ? String.Empty : "NonGeneric" #><#= kind.Type #>Base<#= generic ? "<string>" : String.Empty #>
	{
		public <#= typeName #>( params <#= !kind.IsDictionary ? "string" : generic ? "KeyValuePair<string, string>" : "DictionaryEntry" #>[] items )
		{
			foreach ( var item in items )
			{
				this.Underlying.Add( <#= !kind.IsDictionary ? "item" : "item.Key, item.Value" #> );
			}
		}
	}

	partial class UnconstructableCollectionMemberObjectForAsymmetricTest
	{
		public readonly <#= typeName #> <#= typeName #>Field = new <#= typeName #>( <#= !kind.IsDictionary ? "\"A\"" : generic ? "new KeyValuePair<string, string>( \"A\", \"A\" )" : "new DictionaryEntry( \"A\", \"A\" )" #> );

		public <#= typeName #> <#= typeName #>Property { get{ return this.<#= typeName #>Field; } }
	}
<#
	}
}
#>

	public sealed partial class UnconstructableCollectionMemberObjectForAsymmetricTest
	{
		public UnconstructableCollectionMemberObjectForAsymmetricTest() { }
	}

	public sealed partial class UnsettableArrayMemberObjectForAsymmetricTest
	{
		public readonly string[] Field = new string[] { "A" };

		public string[] Property { get { return this.Field; } }

		public UnsettableArrayMemberObjectForAsymmetricTest() { }
	}

<#
foreach ( var spec in
	new []
	{
		new { Type = "NonGenericEnumerable", BaseType = "IEnumerable" },
		new { Type = "Enumerable", BaseType = "IEnumerable<string>" },
		new { Type = "NonGenericCollection", BaseType = "ICollection" },
	}
)
{
#>

	public sealed partial class Unappendable<#= spec.Type #>ForAsymmetricTest : <#= spec.BaseType #>
	{
		private readonly List<string> _underlying;

		public Unappendable<#= spec.Type #>ForAsymmetricTest( params string[] items )
		{
			this._underlying = new List<string>( items );
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return this._underlying.GetEnumerator();
		}
	}
<#
}
#>

	partial class UnappendableEnumerableForAsymmetricTest
	{
		IEnumerator<string> IEnumerable<string>.GetEnumerator()
		{
			return this._underlying.GetEnumerator();
		}
	}

	partial class UnappendableNonGenericCollectionForAsymmetricTest
	{
		public int Count { get { return this._underlying.Count; } }

		bool ICollection.IsSynchronized { get { return false; } }

		object ICollection.SyncRoot { get { return this; } }

		public void CopyTo( Array array, int index )
		{
			this._underlying.CopyTo( ( string[] )array, index );
		}
	}

	#endregion -- Asymmetric --

	#region -- Empty interfaces --

	// issue 202
<#
	foreach ( var isPackable in new [] { true, false } )
	{
		foreach ( var isUnpackable in new [] { true, false } )
		{
			foreach ( var isAsyncPackable in new [] { true, false } )
			{
				foreach ( var isAsyncUnpackable in new [] { true, false } )
				{
					var suffix =
						( isPackable ? "Packable" : String.Empty ) +
						( isUnpackable ? "Unpackable" : String.Empty ) +
						( isAsyncPackable ? "AsyncPackable" : String.Empty ) +
						( isAsyncUnpackable ? "AsyncUnpackable" : String.Empty );
					var interfaces =
						String.Join(
							", ",
							new []
							{
								( isPackable ? "IPackable" : String.Empty ),
								( isUnpackable ? "IUnpackable" : String.Empty ),
								( isAsyncPackable ? "IAsyncPackable" : String.Empty ),
								( isAsyncUnpackable ? "IAsyncUnpackable" : String.Empty )
							}.Where( x => x.Length > 0 ).ToArray()
						);
					var isAsync = isAsyncPackable || isAsyncUnpackable;

if ( isAsync )
{
#>
#if FEATURE_TAP

<#
}
#>
	public sealed class NoMembers<#= suffix #> <#= interfaces.Any() ? ":" : String.Empty #> <#= interfaces #>
	{
		private string _value;

		public NoMembers<#= suffix #>() { }

		public NoMembers<#= suffix #>( string value )
		{
			this._value = value;
		}

		public string GetValue()
		{
			return this._value;
		}

<#
					if ( isPackable )
					{
#>
		public void PackToMessage( Packer packer, PackingOptions options )
		{
			packer.PackArrayHeader( 1 );
			packer.PackString( this._value );
		}

<#
					}

					if ( isAsyncPackable )
					{
#>

		public async Task PackToMessageAsync( Packer packer, PackingOptions options, CancellationToken cancellationToken )
		{
			await packer.PackArrayHeaderAsync( 1, cancellationToken );
			await packer.PackStringAsync( this._value, cancellationToken );
		}

<#
					}

					if ( isUnpackable )
					{
#>
		public void UnpackFromMessage( Unpacker unpacker )
		{
			Assert.That( unpacker.IsArrayHeader );
			Assert.That( unpacker.LastReadData.AsInt32(), Is.EqualTo( 1 ) );
			Assert.That( unpacker.Read() );
			this._value = unpacker.LastReadData.AsString();
		}
<#
					}

					if ( isAsyncUnpackable )
					{
#>
		public async Task UnpackFromMessageAsync( Unpacker unpacker, CancellationToken cancellationToken )
		{
			Assert.That( unpacker.IsArrayHeader );
			Assert.That( unpacker.LastReadData.AsInt32(), Is.EqualTo( 1 ) );
			Assert.That( await unpacker.ReadAsync( cancellationToken ) );
			this._value = unpacker.LastReadData.AsString();
		}
<#
					}
#>
	}
<#
if ( isAsync )
{
#>

#endif // FEATURE_TAP

<#
}
				}
			}
		}
	}
#>

	#endregion -- Empty interfaces --

	#region -- Issue 233 (constructor based deserialization when the parameters are not in lexicol order) --

	public class EndpointList
	{
		public string StringOne { get; }

		public Dictionary<string, string[]> Endpoints { get; }

		public string StringTwo { get; }

		public EndpointList( string stringOne, Dictionary<string, string[]> endpoints, string stringTwo )
		{
			StringOne = stringOne;
			Endpoints = endpoints;
			StringTwo = stringTwo;
		}
	}

	#endregion -- Issue 233 (constructor based deserialization when the parameters are not in lexicol order) --
}

// Issue #108
namespace MsgPack.UnitTest.TestTypes
{
	public class OmittedType
	{
		public string Value { get; set; }

		public OmittedType() {}

		public override bool Equals( object obj )
		{
			var other = obj as OmittedType;
			if ( other == null )
			{
				return false;
			}

			return this.Value == other.Value;
		}

		public override int GetHashCode()
		{
			return this.Value == null ? 0 : this.Value.GetHashCode();
		}
	}
}

public class TypeInGlobalNamespace
{
	public string Value { get; set; }

	public TypeInGlobalNamespace() { }
}

// Issue 137
public class HasGlobalNamespaceType
{
	[MsgPack.Serialization.MessagePackRuntimeType]
	public TypeInGlobalNamespace GlobalType { get; set; }
}
<#+
private static string ToTypeName( Type type )
{
	if( !type.IsGenericType )
	{
		return type.Name;
	}
	
	return type.Name.Remove( type.Name.IndexOf( '`' ) ) + "<" + String.Join( ", ", type.GetGenericArguments().Select( item => item.Name ) ) + ">";
}

private static string ToTypeName( Tuple<string, string[]> tuple )
{
	if( tuple.Item2 == null || tuple.Item2.Length == 0 )
	{
		return tuple.Item1;
	}
	
	return tuple.Item1.Remove( tuple.Item1.IndexOf( '`' ) ) + "<" + String.Join( ", ", tuple.Item2 ) + ">";
}

private static string ToFieldName( Tuple<Object, string, string, bool> tuple )
{
	if( !String.IsNullOrWhiteSpace( tuple.Item2 ) )
	{
		return tuple.Item2;
	}
	else if( tuple.Item1 is Type )
	{
		var type = tuple.Item1 as Type;
		var typeName = ( type.IsArray ? type.GetElementType() : type ).Name;
		var suffix = type.IsArray ? "ArrayField" : "Field";
		
		int index = type.Name.IndexOf( '`' );
		if( index < 0 )
		{
			return typeName + suffix;
		}
		else
		{
			return typeName.Remove( index ) + String.Join( String.Empty, type.GetGenericArguments().Select( item => item.Name ) ) + suffix;
		}
	}
	else if( tuple.Item1 is Tuple<string, string[]> )
	{
		var items = tuple.Item1 as Tuple<string, string[]>;
		var first = items.Item1.Substring( items.Item1.LastIndexOf( '.' ) + 1 );
		int indexOfBackQuat = first.IndexOf( '`' );
		if( 0 <= indexOfBackQuat )
		{
			first = first.Remove( indexOfBackQuat );
		}
		
		int indexOfBracket = first.IndexOf( '[' );
		if( 0 <= indexOfBracket )
		{
			first = first.Remove( indexOfBracket ) + "Array";
		}

		return first + "_" + String.Join( "_", items.Item2.Select( item => item.Substring( item.LastIndexOf( '.' ) + 1 ) ) ) + "Field";
	}
	else
	{
		throw new NotImplementedException( tuple.Item1.GetType().FullName );
	}
}

private static string GetSimpleInitializer( Tuple<Object, string, string, bool> tuple )
{
	int index = tuple.Item3.IndexOf( '{' );
	if( index < 0 )
	{
		return tuple.Item3;
	}
	else
	{
		return tuple.Item3.Remove( index );
	}
}
#>