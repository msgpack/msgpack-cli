<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Linq" #>
<#+
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2010-2015 FUJIWARA, Yusuke
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
#endregion -- License Terms --

// Entry Point
private void GeneratePolymorphismTestParts()
{
	this.GeneratePolymorphismTestPartsCore( false, true );
}

private void GeneratePolymorphismTestTypes()
{
	this.GeneratePolymorphismTestPartsCore( true, false );
}

private IEnumerable<TestTargetType> GetSerialiazablePolymprohicTestTypeNames()
{
	return this.GeneratePolymorphismTestPartsCore( false, false );
}

private IEnumerable<TestTargetType> GeneratePolymorphismTestPartsCore( bool generateTypes, bool generateMethods )
{
	ICollection<TestTargetType> generatedSerializableTypeNames = new HashSet<TestTargetType>();

	Func<Member, bool, IEnumerable<string>> knownAttributeFactory =
		( Member member, bool asObject  ) => 
		{
			switch ( member.Targets )
			{
				case PolymorphismTargets.Item:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							member.ActualTypes.Select(
								( t, i ) =>
									String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownCollectionItemType( \"{0}\", typeof( {1} ) )]", i, t ) 
							)
						);
				}
				case PolymorphismTargets.Key:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							member.ActualTypes.Select(
								( t, i ) =>
									String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownDictionaryKeyType( \"{0}\", typeof( {1} ) )]", i, t ) 
								)
						);
				}
				case PolymorphismTargets.Key | PolymorphismTargets.Item:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							member.ActualTypes.Select( ( t, i ) => String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownDictionaryKeyType( \"{0}\", typeof( {1} ) )]", i, t ) ) 
						).Concat(
							member.ActualTypes.Select( ( t, i ) => String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownCollectionItemType( \"{0}\", typeof( {1} ) )]", i, t ) )
						);
				}
				case PolymorphismTargets.TupleItem:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							member.PolymorphicTupleItemTypes.SelectMany(
								kv =>
									kv.Value.Select(
										( t, i ) =>
											String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownTupleItemType( {0}, \"{1}\", typeof( {2} ) )]", kv.Key, i, t )
									)
							)
						);
				}
				case PolymorphismTargets.Member:
				{
					return member.ActualTypes.Select( ( t, i ) => String.Format( CultureInfo.InvariantCulture, "[MessagePackKnownType( \"{0}\", typeof( {1} ) )]", i, t ) );
				}
				default:
				{
					return Enumerable.Empty<string>();
				}
			}
		};
	Func<Member, bool, IEnumerable<string>> runtimeAttributeFactory = 
		( Member member, bool asObject ) => 
		{
			switch ( member.Targets )
			{
				case PolymorphismTargets.Item:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat( new[] { "[MessagePackRuntimeCollectionItemType]" } );
				}
				case PolymorphismTargets.Key:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat( new[] { "[MessagePackRuntimeDictionaryKeyType]" } );
				}
				case PolymorphismTargets.Key | PolymorphismTargets.Item:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							new[]
							{
								"[MessagePackRuntimeCollectionItemType]",
								"[MessagePackRuntimeDictionaryKeyType]"
							} 
						);
				}
				case PolymorphismTargets.TupleItem:
				{
					return
						( asObject
							? new[] { "[MessagePackRuntimeType]" }
							: new string[ 0 ]
						).Concat(
							member.PolymorphicTupleItemTypes.Select(
								kv => String.Format( CultureInfo.InvariantCulture, "[MessagePackRuntimeTupleItemType( {0} )]", kv.Key )
							)
						);
				}
				case PolymorphismTargets.Member:
				{
					return new [] { "[MessagePackRuntimeType]" };
				}
				default:
				{
					return Enumerable.Empty<string>();
				}
			}
		};

	var attributeTypes =
		new [] 
		{ 
			new { Name = "KnownType", AttributeFactory = knownAttributeFactory },
			new { Name = "RuntimeType", AttributeFactory = runtimeAttributeFactory },
		};
	var normalTypes =
		new []
		{
			Member.Of( "Reference",		"Version" ,			PolymorphismTargets.None,	null, @"null",					@"new Version( 1, 2, 3, 4 )" ),
			Member.Of( "Value",			"DateTime",			PolymorphismTargets.None,	null, @"default( DateTime )",	@"new DateTime( 1982, 1, 29, 15, 46, 12, DateTimeKind.Utc )" ),
			Member.Of( "Primitive",		"int",				PolymorphismTargets.None,	null, @"default( int )",		@"123" ),
			Member.Of( "String",		"string",			PolymorphismTargets.None,	null, @"null",					@"""ABC""" ),
			Member.Of( "Polymorphic",	"FileSystemEntry",	PolymorphismTargets.Member,	null, @"null",					@"new FileEntry { Name = ""file"", Size = 1 }", "FileEntry", "DirectoryEntry" ),
		};
	var collectionTypes =
		new []
		{
			Member.Of( "ListStaticItem",		"IList<string>",			PolymorphismTargets.None,	false,	@"new List<string>()",			@"new List<string>{ ""A"", ""B"" }" ),
			Member.Of( "ListPolymorphicItem",	"IList<FileSystemEntry>",	PolymorphismTargets.Item,	false,	@"new List<FileSystemEntry>()",	@"new List<FileSystemEntry>{ new FileEntry { Name = ""file"", Size = 1L }, new DirectoryEntry { Name = ""dir"", ChildCount = 1 } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "ListObjectItem",		"IList<object>",			PolymorphismTargets.Item,	false,	@"new List<object>()",			@"new List<object>{ new FileEntry { Name = ""file"", Size = 1L }, new DirectoryEntry { Name = ""dir"", ChildCount = 1 } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "ListPolymorphicItself",	"IList<string>",			PolymorphismTargets.Member,	false,	@"new Collection<string>()",	@"new Collection<string>{ ""A"", ""B"" }", "Collection<string>", "List<string>" ),
			Member.Of( "ListObjectItself",		"object",					PolymorphismTargets.Member,	true,	@"new Collection<string>()",	@"new Collection<string>{ ""A"", ""B"" }", "Collection<string>", "List<string>" ),
		};
	var dictionaryTypes =
		new []
		{
			Member.Of( "DictStaticKeyAndStaticItem",		"IDictionary<string, string>",						PolymorphismTargets.None,							false,	@"new Dictionary<string, string>()",					@"new Dictionary<string, string>{ { ""A"", ""A"" }, { ""B"", ""B"" } }" ),
			Member.Of( "DictPolymorphicKeyAndStaticItem",	"IDictionary<FileSystemEntry, string>",				PolymorphismTargets.Key,							false,	@"new Dictionary<FileSystemEntry, string>()",			@"new Dictionary<FileSystemEntry, string>{ { new FileEntry { Name = ""file"", Size = 1L }, ""A"" }, { new DirectoryEntry { Name = ""dir"", ChildCount = 1 }, ""B"" } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictObjectKeyAndStaticItem",		"IDictionary<object, string>",						PolymorphismTargets.Key,							false,	@"new Dictionary<object, string>()",					@"new Dictionary<object, string>{ { new FileEntry { Name = ""file"", Size = 1L }, ""A"" }, { new DirectoryEntry { Name = ""dir"", ChildCount = 1 }, ""B"" } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictStaticKeyAndPolymorphicItem",	"IDictionary<string, FileSystemEntry>",				PolymorphismTargets.Item,							false,	@"new Dictionary<string, FileSystemEntry>()",			@"new Dictionary<string, FileSystemEntry>{ { ""A"", new FileEntry { Name = ""file"", Size = 1L } }, { ""B"", new DirectoryEntry { Name = ""dir"", ChildCount = 1 } } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictStaticKeyAndObjectItem",		"IDictionary<string, object>",						PolymorphismTargets.Item,							false,	@"new Dictionary<string, object>()",					@"new Dictionary<string, object>{ { ""A"", new FileEntry { Name = ""file"", Size = 1L } }, { ""B"", new DirectoryEntry { Name = ""dir"", ChildCount = 1 } } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictPolymorphicKeyAndItem",			"IDictionary<FileSystemEntry, FileSystemEntry>",	PolymorphismTargets.Key | PolymorphismTargets.Item,	false,	@"new Dictionary<FileSystemEntry, FileSystemEntry>()",	@"new Dictionary<FileSystemEntry, FileSystemEntry>{ { new FileEntry { Name = ""A"", Size = 1L }, new FileEntry { Name = ""file"", Size = 1L } }, { new DirectoryEntry { Name = ""B"", ChildCount = 1 }, new DirectoryEntry { Name = ""dir"", ChildCount = 1 } } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictObjectKeyAndItem",				"IDictionary<object, object>",						PolymorphismTargets.Key | PolymorphismTargets.Item,	false,	@"new Dictionary<object, object>()",					@"new Dictionary<object, object>{ { new FileEntry { Name = ""A"", Size = 1L }, new FileEntry { Name = ""file"", Size = 1L } }, { new DirectoryEntry { Name = ""B"", ChildCount = 1 }, new DirectoryEntry { Name = ""dir"", ChildCount = 1 } } }", "FileEntry", "DirectoryEntry" ),
			Member.Of( "DictPolymorphicItself",				"IDictionary<string, string>",						PolymorphismTargets.Member,							false,	@"new Dictionary<string, string>()",					@"new Dictionary<string, string>{ { ""A"", ""A"" }, { ""B"", ""B"" } }", "Dictionary<string, string>", "SortedDictionary<string, string>" ),
			Member.Of( "DictObjectItself",					"object",											PolymorphismTargets.Member,							true,	@"new Dictionary<string, string>()",					@"new Dictionary<string, string>{ { ""A"", ""A"" }, { ""B"", ""B"" } }", "Dictionary<string, string>", "SortedDictionary<string, string>" ),
		};
	var tupleMembers =
		new []
		{
			Member.Of( "Tuple1Static",				"Tuple<string>", 
													false,
													@"Tuple.Create( ""1"" )" ),
			Member.Of( "Tuple1Polymorphic",			"Tuple<FileSystemEntry>",
													false,
													@"Tuple.Create( new FileEntry { Name = ""1"", Size = 1 } as FileSystemEntry )",
													new KeyValuePair<int, string[]>( 1, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple1ObjectItem",			"Tuple<object>",
													false,
													@"Tuple.Create( new FileEntry { Name = ""1"", Size = 1 } as object )",
													new KeyValuePair<int, string[]>( 1, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple1ObjectItself",		"object",
													true,
													@"Tuple.Create( new FileEntry { Name = ""1"", Size = 1 } as FileEntry )" // Tuple items can be polymorphic only when tuple itself declared as Tuple.
													), // Tuple items can be polymorphic only when tuple itself declared as Tuple.
			Member.Of( "Tuple7AllStatic",			"Tuple<string, string, string, string, string, string, string>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 7 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + " )" ),
			Member.Of( "Tuple7FirstPolymorphic",	"Tuple<FileSystemEntry, string, string, string, string, string, string>",
													false,
													@"Tuple.Create( new FileEntry { Name = ""1"", Size = 1 } as FileSystemEntry, " + String.Join( ", ", Enumerable.Range( 2, 6 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + ")",
													new KeyValuePair<int, string[]>( 1, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple7LastPolymorphic",		"Tuple<string, string, string, string, string, string, FileSystemEntry>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 6 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + @", new FileEntry { Name = ""7"", Size = 7 } as FileSystemEntry )",
													new KeyValuePair<int, string[]>( 7, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple7MidPolymorphic",		"Tuple<string, string, string, FileSystemEntry, string, string, string>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 3 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + @", new FileEntry { Name = ""4"", Size = 4 } as FileSystemEntry, " + String.Join( ", ", Enumerable.Range( 5, 3 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + ")",
													new KeyValuePair<int, string[]>( 4, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple7AllPolymorphic",		"Tuple<FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 7 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"new {0}Entry {{ Name = ""{1}"", {2} = {1} }} as FileSystemEntry", i % 2 == 1 ? "File" : "Directory", i, i % 2 == 1 ? "Size" : "ChildCount" ) ) ) + " )",
													Enumerable.Range( 1, 7 ).Select( i => new KeyValuePair<int, string[]>( i, new []{ "FileEntry", "DirectoryEntry" } ) ).ToArray() ),
			Member.Of( "Tuple8AllStatic",			"Tuple<string, string, string, string, string, string, string, Tuple<string>>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 7 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + @", ""8"" )" ),
			Member.Of( "Tuple8LastPolymorphic",		"Tuple<string, string, string, string, string, string, string, Tuple<FileSystemEntry>>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 7 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"""{0}""", i ) ) ) + @", new FileEntry { Name = ""8"", Size = 8 } as FileSystemEntry )",
													new KeyValuePair<int, string[]>( 8, new []{ "FileEntry", "DirectoryEntry" } ) ),
			Member.Of( "Tuple8AllPolymorphic",		"Tuple<FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, FileSystemEntry, Tuple<FileSystemEntry>>",
													false,
													@"Tuple.Create( " + String.Join( ", ", Enumerable.Range( 1, 7 ).Select( i => String.Format( CultureInfo.InvariantCulture, @"new {0}Entry {{ Name = ""{1}"", {2} = {1} }} as FileSystemEntry", i % 2 == 1 ? "File" : "Directory", i, i % 2 == 1 ? "Size" : "ChildCount" ) ) ) + @", new DirectoryEntry { Name = ""8"", ChildCount = 8 } as FileSystemEntry )",
													Enumerable.Range( 1, 8 ).Select( i => new KeyValuePair<int, string[]>( i, new []{ "FileEntry", "DirectoryEntry" } ) ).ToArray() ),
		};

	if ( generateTypes || generateMethods )
	{
#>
		#region -- Polymorphism --
<#+
	}

	foreach ( var attributeType in attributeTypes )
	{
		if ( generateTypes || generateMethods )
		{
#>
		#region ---- <#= attributeType.Name #> ----

		#region ------ <#= attributeType.Name #>.NormalTypes ------
<#+
		}

		foreach ( var member in normalTypes )
		{
			foreach ( var kind in new [] { TypeKind.ReadWriteProperty, TypeKind.ReadWriteField, TypeKind.GetOnlyPropertyAndConstructor, TypeKind.PrivateSetterPropertyAndConstructor, TypeKind.ReadOnlyFieldAndConstructor } )
			{
				var typeName = GeneratePolymorphicTestType( attributeType.Name + "_Normal_" + member.Name + kind, kind, member, attributeType.AttributeFactory, false, generateTypes );
				generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
				GeneratePolymorphicTestMethods( typeName, kind, member, generateMethods, false );
				
				var typeNameAsObject = GeneratePolymorphicTestType( attributeType.Name + "_" + member.Name + kind + "AsObject", kind, member, attributeType.AttributeFactory, true, generateTypes );
				
				if ( !WillFail( member.Targets, kind ) )
				{
					generatedSerializableTypeNames.Add(  new TestTargetType( typeNameAsObject, true ) );
				}

				GeneratePolymorphicTestMethods( typeNameAsObject, kind, member, generateMethods, true );
			}
		}

		if ( generateTypes || generateMethods )
		{
#>
		#endregion ------ <#= attributeType.Name #>.NormalTypes ------

		#region ------ <#= attributeType.Name #>.CollectionTypes ------
<#+
		}

		foreach( var member in collectionTypes )
		{
			// Note: combination of deserialization constructor and collection get/read only member is not valid.
			foreach ( var kind in new [] { TypeKind.ReadWriteProperty, TypeKind.ReadWriteField, TypeKind.GetOnlyCollectionProperty, TypeKind.PrivateSetterCollectionProperty, TypeKind.ReadOnlyCollectionField } )
			{
				var typeName = GeneratePolymorphicTestType( attributeType.Name + "_List_" + member.Name + kind, kind, member, attributeType.AttributeFactory, member.AsObject.Value, generateTypes );
				
				if ( !member.AsObject.Value || !WillFail( member.Targets, kind ) )
				{
					generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
				}
				
				GeneratePolymorphicTestMethods( typeName, kind, member, generateMethods, member.AsObject.Value );
			}
		}

		if ( generateTypes || generateMethods )
		{
#>
		#endregion ------ <#= attributeType.Name #>.CollectionTypes ------

		#region ------ <#= attributeType.Name #>.DictionaryTypes ------
<#+
		}

		foreach( var member in dictionaryTypes )
		{
			// Note: combination of deserialization constructor and collection get/read only member is not valid.
			foreach ( var kind in new [] { TypeKind.ReadWriteProperty, TypeKind.ReadWriteField, TypeKind.GetOnlyCollectionProperty, TypeKind.PrivateSetterCollectionProperty, TypeKind.ReadOnlyCollectionField } )
			{
				var typeName = GeneratePolymorphicTestType( attributeType.Name + "_Dict_" + member.Name + kind, kind, member, attributeType.AttributeFactory, member.AsObject.Value, generateTypes );
				
				if ( !member.AsObject.Value || !WillFail( member.Targets, kind ) )
				{
					generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
				}

				GeneratePolymorphicTestMethods( typeName, kind, member, generateMethods, member.AsObject.Value );
			}
		}

		if ( generateTypes || generateMethods )
		{
#>
		#endregion ------ <#= attributeType.Name #>.DictionaryTypes ------

#if !NET35 && !UNITY
		#region ------ <#= attributeType.Name #>.TupleTypes ------
<#+
		}

		foreach ( var member in tupleMembers )
		{
			foreach ( var kind in new [] { TypeKind.ReadWriteProperty, TypeKind.ReadWriteField, TypeKind.GetOnlyPropertyAndConstructor, TypeKind.PrivateSetterPropertyAndConstructor, TypeKind.ReadOnlyFieldAndConstructor } )
			{
				var typeName = GeneratePolymorphicTestType( attributeType.Name + "_Tuple_" + member.Name + kind, kind, member, attributeType.AttributeFactory, member.AsObject.Value, generateTypes );
				
				if ( !member.AsObject.Value || !WillFail( member.Targets, kind ) )
				{
					generatedSerializableTypeNames.Add( new TestTargetType( typeName, false ) );
				}

				GeneratePolymorphicTestMethods( typeName, kind, member, generateMethods, member.AsObject.Value );
			}

		}

		if ( generateTypes || generateMethods )
		{
#>
		#endregion ------ <#= attributeType.Name #>.TupleTypes ------
#endif // #if !NET35 && !UNITY

		#endregion ---- <#= attributeType.Name #> ----
<#+
		}
	}

	// Mixed Patterns
	GeneratePolymorphicTestsForMixed( generateTypes, generateMethods, generatedSerializableTypeNames );

	// Error Patterns
	GenerateErrorPatterns( generateTypes, generateMethods, generatedSerializableTypeNames );

	if ( generateTypes )
	{
		// Add static generated types
		generatedSerializableTypeNames.Add( new TestTargetType( "IFileSystemEntry", true ) );
		generatedSerializableTypeNames.Add( new TestTargetType( "AbstractFileSystemEntry", true ) );
		generatedSerializableTypeNames.Add( new TestTargetType( "FileEntry", true ) );
		generatedSerializableTypeNames.Add( new TestTargetType( "DirectoryEntry", true ) );
#>

	public interface IFileSystemEntry { }

	public abstract class AbstractFileSystemEntry : IFileSystemEntry { }

	public abstract class FileSystemEntry : AbstractFileSystemEntry, IComparable<FileSystemEntry>
	{
		public string Name { get; set; }

		public override bool Equals( object obj )
		{
			var other = obj as FileSystemEntry;
			if ( Object.ReferenceEquals( other, null ) )
			{
				return false;
			}

			return this.Name == other.Name;
		}

		public override int GetHashCode()
		{
			return ( this.Name ?? String.Empty ).GetHashCode();
		}

		int IComparable<FileSystemEntry>.CompareTo( FileSystemEntry other )
		{
			return String.Compare( this.Name, other.Name, StringComparison.Ordinal );
		}
	}

	public class FileEntry : FileSystemEntry
	{
		public long Size { get; set; }

		public override bool Equals( object obj )
		{
			var other = obj as FileEntry;
			if ( Object.ReferenceEquals( other, null ) )
			{
				return false;
			}

			return this.Name == other.Name && this.Size == other.Size;
		}

		public override int GetHashCode()
		{
			return ( this.Name ?? String.Empty ).GetHashCode() ^ this.Size.GetHashCode();
		}

		public override string ToString()
		{
			return "File(Name=" + this.Name + ", Size=" + this.Size + ")";
		}
	}

	public class DirectoryEntry : FileSystemEntry
	{
		public int ChildCount { get; set; }

		public override bool Equals( object obj )
		{
			var other = obj as DirectoryEntry;
			if ( Object.ReferenceEquals( other, null ) )
			{
				return false;
			}

			return this.Name == other.Name && this.ChildCount == other.ChildCount;
		}

		public override int GetHashCode()
		{
			return ( this.Name ?? String.Empty ).GetHashCode() ^ this.ChildCount.GetHashCode();
		}

		public override string ToString()
		{
			return "Directory(Name=" + this.Name + ", ChildCount=" + this.ChildCount + ")";
		}
	}

<#+
	}

	if ( generateMethods )
	{
#>
		// Issue 137
		[Test]
		[Category( "PolymorphicSerialization" )]
		public void TestGlobalNamespace()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			var target = new HasGlobalNamespaceType { GlobalType = new TypeInGlobalNamespace { Value = "ABC" } };
			var serializer = context.GetSerializer<HasGlobalNamespaceType>();
				
			using ( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );

				Assert.That( result, Is.Not.Null );
				Assert.That( result, Is.Not.SameAs( target ) );
				Assert.That( result.GlobalType, Is.Not.Null );
				Assert.That( result.GlobalType, Is.Not.SameAs( target.GlobalType ) );
				Assert.That( result.GlobalType.Value, Is.EqualTo( target.GlobalType.Value ) );
			}
		}

#if FEATURE_TAP
		[Test]
		[Category( "PolymorphicSerialization" )]
		public async Task TestGlobalNamespaceAsync()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			var target = new HasGlobalNamespaceType { GlobalType = new TypeInGlobalNamespace { Value = "ABC" } };
			var serializer = context.GetSerializer<HasGlobalNamespaceType>();
				
			using ( var buffer = new MemoryStream() )
			{
				await serializer.PackAsync( buffer, target );
				buffer.Position = 0;
				var result = await serializer.UnpackAsync( buffer );

				Assert.That( result, Is.Not.Null );
				Assert.That( result, Is.Not.SameAs( target ) );
				Assert.That( result.GlobalType, Is.Not.Null );
				Assert.That( result.GlobalType, Is.Not.SameAs( target.GlobalType ) );
				Assert.That( result.GlobalType.Value, Is.EqualTo( target.GlobalType.Value ) );
			}
		}

#endif // FEATURE_TAP
<#+
	}

GeneratePolymorohismExtensionTests( generateTypes, generateMethods );

	if ( generateTypes || generateMethods )
	{
#>

		#endregion -- Polymorphism --
<#+
	}

	return generatedSerializableTypeNames;
}

// Types
private string GeneratePolymorphicTestType( string suffix, TypeKind kind, Member member, Func<Member, bool, IEnumerable<string>> attributeFactory, bool asObject, bool generateTypes )
{
	var typeName = "PolymorphicMemberType" + suffix;

	if ( generateTypes )
	{
#>
#if !UNITY

	public class <#= typeName #>
	{
<#+
		GenerateMember( kind, member, attributeFactory, asObject );
#>

<#+
		GenerateConstructor( typeName, kind, asObject, member );
#>
	}

#endif // !UNITY
<#+
	}

	return typeName;
}

// Types (private)
private void GenerateMember( TypeKind kind, Member member, Func<Member, bool, IEnumerable<string>> attributeFactory, bool asObject )
{

	if ( ( kind & TypeKind.PropertyOrFieldMask ) == TypeKind.Field )
	{
		GenerateAttributes( member, attributeFactory, asObject );
#>
		public <#= ( kind & TypeKind.IsReadOnly ) == TypeKind.IsReadOnly ? "readonly" : String.Empty #> <#= asObject ? "object" : member.Type #> <#=  GetMemberNameGenerator( kind )( member.Name ) #>;
<#+
	}
	else
	{
		var backingField = GetMemberNameGenerator( TypeKind.Property )( member.Name );

#>
		private <#= asObject ? "object" : member.Type #> <#=  backingField #>;

<#+
		GenerateAttributes( member, attributeFactory, asObject );
#>
		public <#= asObject ? "object" : member.Type #> <#=  GetMemberNameGenerator( TypeKind.Field )( member.Name ) #>
		{
			get { return this.<#= backingField #>; }
<#+
		if ( ( kind & TypeKind.HasSetter ) == TypeKind.HasSetter )
		{
#>
			<#= ( kind & TypeKind.IsPublicSetter ) == TypeKind.IsPublicSetter ? String.Empty : "private" #> set { this.<#= backingField #> = value; }
<#+
		}
#>
		}
<#+
	}
}

private void GenerateAttributes( Member member, Func<Member, bool, IEnumerable<string>> attributeFactory, bool asObject )
{
	foreach ( var attribute in attributeFactory( member, asObject ) )
	{
#>
		<#= attribute #>
<#+
	}
}

private void GenerateConstructor( string typeName, TypeKind kind, bool asObject, params Member[] members )
{
#>

		<#= ( kind & TypeKind.HasConstructor ) == TypeKind.HasConstructor ? "public" : "private" #> <#= typeName #>( <#=  String.Join( ", ", members.Select( member => ( asObject ? "object" : member.Type ) + " " + member.Name ) ) #> ) 
		{
<#+
	foreach ( var member in members )
	{
#>
			this.<#=  GetMemberNameGenerator( kind )( member.Name ) #> = <#= member.Name #>;
<#+
	}
#>
		}
<#+
	if ( ( kind & TypeKind.HasConstructor ) == 0 )
	{
#>

		public <#= typeName #>()
		{
<#+
	foreach ( var member in members )
	{
#>
			this.<#=  GetMemberNameGenerator( kind )( member.Name ) #> = <#= member.EmptyValue #>;
<#+
	}
#>
		}

		public static <#= typeName #> Initialize()
		{
			return new <#= typeName #>( <#= String.Join( ", ", members.Select( m => m.InitialValue ) ) #> );
		}
<#+
	}
	else
	{
#>
		public <#= typeName #>() {}
<#+
	}
}

private static bool WillFail( PolymorphismTargets targets, TypeKind kind )
{
	return
		targets != PolymorphismTargets.None
		&& ( kind & TypeKind.HasConstructor ) == 0
		&& (
			( ( kind & TypeKind.HasSetter ) == 0 && ( kind & TypeKind.PropertyOrFieldMask ) == TypeKind.Property )
			|| ( kind & TypeKind.IsReadOnly ) != 0
		);
}

// Methods
private void GeneratePolymorphicTestMethods( string targetType, TypeKind kind, Member member, bool generateMethods, bool asObject )
{
	if ( !generateMethods )
	{
		return;
	}

	var label = "Success";
	var exceptionInCreation = default( string );
	var shouldBeMpo = false;
	if ( asObject )
	{
		switch ( member.Targets )
		{
			case PolymorphismTargets.None:
			{
				shouldBeMpo = true;
				label = "AsMpo";
				break;
			}
			default:
			{
				if ( WillFail( member.Targets, kind ) )
				{
					label = "Fail";
					exceptionInCreation = "SerializationException";
				}

				break;
			}
		}
	}
#>

#if !UNITY

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void Test<#= targetType + "_" + label #>()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
<#+
	if ( ( kind & TypeKind.HasConstructor ) == TypeKind.HasConstructor )
	{
#>
			var target = new <#= targetType #>( <#= member.InitialValue #> );
<#+
	}
	else
	{
#>
			var target = <#= targetType #>.Initialize();
<#+
	}

	if ( exceptionInCreation != null )
	{
#>
			Assert.Throws<#= "<" + exceptionInCreation + ">" #>( () => context.GetSerializer<#= "<" + targetType + ">" #>() );
<#+
	}
	else
	{
		var mustBePrivileged =
			member.AsObject.GetValueOrDefault() && ( member.Name.StartsWith( "List" ) || member.Name.StartsWith( "Dict" ) ) // For comatibility, list and dict will be required privilege
			&& ( kind & TypeKind.HasSetter ) != 0 && ( kind & TypeKind.IsPublicSetter ) == 0;
		if ( mustBePrivileged )
		{
#>
#if SILVERLIGHT && !SILVERLIGHT_PRIVILEGED
			Assert.Throws<SerializationException>( () => context.GetSerializer<#= "<" + targetType + ">" #>() );
#else
<#+
		}
#>
			var serializer = context.GetSerializer<#= "<" + targetType + ">" #>();
				
			using ( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );

				Assert.That( result, Is.Not.Null );
				Assert.That( result, Is.Not.SameAs( target ) );
<#+
		if ( shouldBeMpo )
		{
#>
				Assert.That( result.<#= member.Name #>, Is.InstanceOf( typeof( MessagePackObject ) ) );
<#+
		}
		else
		{
			if ( member.PolymorphicTupleItemTypes.Length > 0 && asObject )
			{
#>
				// Tuple items cannot be polymorphic when the member itself declared as Object.
<#+
			}
			else
			{
#>
				Assert.That( result.<#= member.Name #>, Is.EqualTo( target.<#= member.Name #> ) );
<#+
			}
#>
				Assert.That( result.<#= member.Name #>, Is.InstanceOf( target.<#= member.Name #>.GetType() ) );
<#+
		}
#>
			}
<#+
		if ( mustBePrivileged )
		{
#>
#endif // SILVERLIGHT && !SILVERLIGHT_PRIVILEGED
<#+
		}
	}
#>
		}

#endif // !UNITY

<#+
}

// Mixed Pattern
private void GeneratePolymorphicTestsForMixed( bool generateTypes, bool generateMethods, ICollection<TestTargetType> generatedSerializableTypeNames )
{
	/*
		Tests only popular cases:
		Normal : Plane, Runtime/Object, Known
		List : Plain, Plain & Item-Known, Container-Known & Item-Runtime/Object, 
		Dictionary : Plain, Plaiun & Key-Plain & Item-Known, Container-Known & Key-Plain & Item-Runtime/Object, 
		Tuple : (Plane, Known, Runtime, Object)
	 */
	var members =
		new []
		{
			new { Name = "NormalVanilla",	Type = "string",			InitialValue = @"""ABC""",										Attributes = new string[ 0 ], IsTuple = false },
			new { Name = "NormalRuntime",	Type = "FileSystemEntry",	InitialValue = @"new FileEntry { Name = ""File"", Size = 1 }",	Attributes = new [] { "[MessagePackRuntimeType]" }, IsTuple = false },
			new { Name = "NormalKnown",		Type = "FileSystemEntry",	InitialValue = @"new FileEntry { Name = ""File"", Size = 2 }",	Attributes = new [] { "[MessagePackKnownType( \"1\", typeof( FileEntry ) )]", "[MessagePackKnownType( \"2\", typeof( DirectoryEntry ) )]" }, IsTuple = false },
			new { Name = "ObjectRuntime",	Type = "Object",			InitialValue = @"new FileEntry { Name = ""File"", Size = 3 }",	Attributes = new [] { "[MessagePackRuntimeType]" }, IsTuple = false },
			new { Name = "ObjectRuntimeOmittedType",	Type = "Object",			InitialValue = @"new MsgPack.UnitTest.TestTypes.OmittedType { Value = ""ABC"" }",	Attributes = new [] { "[MessagePackRuntimeType]" }, IsTuple = false },
			new { Name = "ListVanilla",						Type = "IList<string>",				InitialValue = @"new List<string> { ""ABC"" }",													Attributes = new string[ 0 ], IsTuple = false },
			new { Name = "ListKnownItem",					Type = "IList<FileSystemEntry>",	InitialValue = @"new List<FileSystemEntry> { new FileEntry { Name = ""File"", Size = 1 } }",	Attributes = new [] { "[MessagePackKnownCollectionItemType( \"1\", typeof( FileEntry ) )]", "[MessagePackKnownCollectionItemType( \"2\", typeof( DirectoryEntry ) )]" }, IsTuple = false },
			new { Name = "ListKnwonContainerRuntimeItem",	Type = "IList<FileSystemEntry>",	InitialValue = @"new List<FileSystemEntry> { new FileEntry { Name = ""File"", Size = 2 } }",	Attributes = new [] { "[MessagePackKnownType( \"1\", typeof( Collection<FileSystemEntry> ) )]", "[MessagePackKnownType( \"2\", typeof( List<FileSystemEntry> ) )]", "[MessagePackRuntimeCollectionItemType]" }, IsTuple = false },
			new { Name = "ListObjectRuntimeItem",			Type = "IList<object>",				InitialValue = @"new List<object> { new FileEntry { Name = ""File"", Size = 3 } }",				Attributes = new [] { "[MessagePackRuntimeCollectionItemType]" }, IsTuple = false },
			new { Name = "DictionaryVanilla",						Type = "IDictionary<string, string>",			InitialValue = @"new Dictionary<string, string> { { ""Key"", ""ABC"" } }",												Attributes = new string[ 0 ], IsTuple = false },
			new { Name = "DictionaryKnownValue",					Type = "IDictionary<string, FileSystemEntry>",	InitialValue = @"new Dictionary<string, FileSystemEntry> { { ""Key"", new FileEntry { Name = ""File"", Size = 1 } } }",	Attributes = new [] { "[MessagePackKnownCollectionItemType( \"1\", typeof( FileEntry ) )]", "[MessagePackKnownCollectionItemType( \"2\", typeof( DirectoryEntry ) )]" }, IsTuple = false },
			new { Name = "DictionaryKnownContainerRuntimeValue",	Type = "IDictionary<string, FileSystemEntry>",	InitialValue = @"new Dictionary<string, FileSystemEntry> { { ""Key"", new FileEntry { Name = ""File"", Size = 2 } } }",	Attributes = new [] { "[MessagePackKnownType( \"1\", typeof( SortedDictionary<string, FileSystemEntry> ) )]", "[MessagePackKnownType( \"2\", typeof( Dictionary<string, FileSystemEntry> ) )]", "[MessagePackRuntimeCollectionItemType]" }, IsTuple = false },
			new { Name = "DictionaryObjectRuntimeValue",			Type = "IDictionary<string, object>",			InitialValue = @"new Dictionary<string, object> { { ""Key"", new FileEntry { Name = ""File"", Size = 3 } } }",			Attributes = new [] { "[MessagePackRuntimeCollectionItemType]" }, IsTuple = false },
			new { Name = "Tuple",	Type = "Tuple<string, FileSystemEntry, FileSystemEntry, object>", InitialValue = @"Tuple.Create<string, FileSystemEntry, FileSystemEntry, object>( ""ABC"", new FileEntry { Name = ""File"", Size = 1 }, new FileEntry { Name = ""File"", Size = 3 }, new FileEntry { Name = ""File"", Size = 3 } )", Attributes = new [] { "[MessagePackKnownTupleItemType( 2, \"1\", typeof( FileEntry ) )]", "[MessagePackKnownTupleItemType( 2, \"2\", typeof( DirectoryEntry ) )]", "[MessagePackRuntimeTupleItemType( 3 )]","[MessagePackRuntimeTupleItemType( 4 )]" }, IsTuple = true },
		};

	const string typeName = "PolymorphicMemberTypeMixed";

	// Add static generated types
	generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
	if ( generateTypes )
	{
#>
	public class <#= typeName #>
	{
<#+
		foreach ( var member in members )
		{
			if ( member.IsTuple )
			{
#>
#if !NET35 && !UNITY
<#+
			}

			foreach ( var attribute in member.Attributes )
			{
#>
		<#= attribute #>
<#+
			}
#>
		public <#= member.Type #> <#= member.Name #> { get; set; }
<#+
			if ( member.IsTuple )
			{
#>
#endif // !NET35 && !UNITY
<#+
			}
		}
#>

		public <#= typeName #>() { }
	}
<#+
	}

	if ( generateMethods )
	{
#>

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void Test<#= typeName #>_Success()
		{
				var context = NewSerializationContext( PackerCompatibilityOptions.None );
				var target = new <#= typeName #>();
<#+
		foreach ( var member in members )
		{
			if ( member.IsTuple )
			{
#>
#if !NET35 && !UNITY
<#+
			}
#>
				target.<#= member.Name #> = <#= member.InitialValue #>;
<#+
			if ( member.IsTuple )
			{
#>
#endif // !NET35 && !UNITY
<#+
			}
		}
#>
				var serializer = context.GetSerializer<#= "<" + typeName + ">" #>();
				
				using ( var buffer = new MemoryStream() )
				{
					serializer.Pack( buffer, target );
					buffer.Position = 0;
					var result = serializer.Unpack( buffer );

					Assert.That( result, Is.Not.Null );
					Assert.That( result, Is.Not.SameAs( target ) );
<#+
		foreach ( var member in members )
		{
			if ( member.IsTuple )
			{
#>
#if !NET35 && !UNITY
<#+
			}
#>
					Assert.That( result.<#= member.Name #>, Is.EqualTo( target.<#= member.Name #> ), "<#= member.Name #>" );
					Assert.That( result.<#= member.Name #>, Is.InstanceOf( target.<#= member.Name #>.GetType() ), "<#= member.Name #>" );
<#+
			if ( member.IsTuple )
			{
#>
#endif // !NET35 && !UNITY
<#+
			}
		}
#>
				}
		}

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void Test<#= typeName #>_Null_Success()
		{
				var context = NewSerializationContext( PackerCompatibilityOptions.None );
				var target = new <#= typeName #>();
				var serializer = context.GetSerializer<#= "<" + typeName + ">" #>();
				
				using ( var buffer = new MemoryStream() )
				{
					serializer.Pack( buffer, target );
					buffer.Position = 0;
					var result = serializer.Unpack( buffer );

					Assert.That( result, Is.Not.Null );
					Assert.That( result, Is.Not.SameAs( target ) );
<#+
		foreach ( var member in members )
		{
			if ( member.IsTuple )
			{
#>
#if !NET35 && !UNITY
<#+
			}
#>
					Assert.That( result.<#= member.Name #>, Is.Null );
<#+
			if ( member.IsTuple )
			{
#>
#endif // !NET35 && !UNITY
<#+
			}
		}
#>
				}
		}
<#+
	}
}

// Error Pattern
private void GenerateErrorPatterns( bool generateTypes, bool generateMethods, ICollection<TestTargetType> generatedSerializableTypeNames )
{
	var abstractTypes =
		new []
		{ 
			new { Name = "AbstractClass", Type = "AbstractFileSystemEntry", ShouldRegister = true, },
			new { Name = "Interface", Type ="IFileSystemEntry", ShouldRegister = false, },
		};
	/*
		Cartesian of
		{Abstract Class | Interface } x { No Attributes | Knwon Attributes | Runtime Attribute } x { Member | Collection Container (Member) | Collection Items | Dictionary Keys}
	 */
	foreach ( var declarationType in abstractTypes )
	{
		foreach ( var pattern in
			// Note: Collection concrete types must be default collection type.
			new []
			{
				new { Name = "Member",		Qualifier = String.Empty,		TypeFormat = default( string ),				InitializerFormat = "new FileEntry { Name = \"file\", Size = 1 }" },
				new { Name = "ListItem",	Qualifier = "CollectionItem",	TypeFormat = "IList<{0}>",					InitializerFormat = "new List<{0}>{{ new FileEntry {{ Name = \"file\", Size = 1 }} }}" },
				new { Name = "DictKey",		Qualifier = "DictionaryKey",	TypeFormat = "IDictionary<{0}, string>",	InitializerFormat = "new Dictionary<{0}, string> {{ {{ new FileEntry {{ Name = \"file\", Size = 1 }}, \"ABC\" }} }}" },
			}
		)
		{
			foreach ( var attribute in 
				new [] 
				{
					new { Name = "NoAttribute",	Attribute = default( string ) },
					new { Name = "KnownType",	Attribute = String.Format( CultureInfo.InvariantCulture, "[MessagePackKnown{0}Type( \"1\", typeof( FileEntry ) )]", pattern.Qualifier ) }, 
					new { Name = "RuntimeType",	Attribute = String.Format( CultureInfo.InvariantCulture, "[MessagePackRuntime{0}Type]", pattern.Qualifier ) },
				}
			)
			{
				var typeName = declarationType.Name + pattern.Name + attribute.Name;
				if ( attribute.Attribute != null )
				{
					// will success
					generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
				}

				if ( generateTypes )
				{
					GenerateAbstractTypeTestClass( typeName, attribute.Attribute, pattern.TypeFormat == null ? declarationType.Type : String.Format( CultureInfo.InvariantCulture, pattern.TypeFormat, declarationType.Type ) );
				}

				if ( generateMethods )
				{
					GenerateAbstractTypeTestMethod( 
						typeName, 
						pattern.TypeFormat == null ? pattern.InitializerFormat : String.Format( CultureInfo.InvariantCulture, pattern.InitializerFormat, declarationType.Type ), 
						null, 
						null,
						pattern.TypeFormat != null, 
						attribute.Attribute != null 
					);
				}
			}
		}
	}

	// Cannot be created because open generic type.
	// generatedSerializableTypeNames.Add( "EchoKeyedCollection<>" );
	if ( generateTypes )
	{
#>

	public class EchoKeyedCollection<TKey, T> : KeyedCollection<TKey, T>
	{
		protected override TKey GetKeyForItem( T item )
		{
			// should be same
			return ( TKey )( object )item;
		}
	}
<#+
	}

	foreach ( var declarationType in 
		new []
		{ 
			new { Name = "AbstractClass", Type = "KeyedCollection<string, string>" },
			new { Name = "Interface", Type ="IList<string>" },
		}
	)
	{
		foreach ( var attribute in 
			new [] 
			{
				new { Name = "NoAttribute",	Attribute = default( string ) },
				new { Name = "KnownType",	Attribute = "[MessagePackKnownType( \"1\", typeof( EchoKeyedCollection<string, string> ) )]" }, 
				new { Name = "RuntimeType", Attribute = "[MessagePackRuntimeType]" },
			}
		)
		{
			var typeName = declarationType.Name + "Collection" + attribute.Name;
			generatedSerializableTypeNames.Add( new TestTargetType( typeName, true ) );
			if ( generateTypes )
			{
				GenerateAbstractTypeTestClass( typeName, attribute.Attribute, declarationType.Type );
			}

			if ( generateMethods )
			{
				GenerateAbstractTypeTestMethod( typeName, "new EchoKeyedCollection<string, string> { \"ABC\" }", declarationType.Type, "EchoKeyedCollection<string, string>", true, true );
			}
		}
	}

	/*
		Cartesian of
		{Abstract Class | Interface } x {Knwon Attributes | Runtime Attribute } for Tuple Items
	 */
	generatedSerializableTypeNames.Add( new TestTargetType( "TupleAbstractType", false ) );
	if ( generateTypes )
	{
#>
#if !NET35 && !UNITY

	public class TupleAbstractType
	{
		[MessagePackKnownTupleItemType( 1, "1", typeof( FileEntry ) )]
		[MessagePackKnownTupleItemType( 2, "1", typeof( FileEntry ) )]
		[MessagePackRuntimeTupleItemType( 3 )]
		[MessagePackRuntimeTupleItemType( 4 )]
		public Tuple<AbstractFileSystemEntry, IFileSystemEntry, AbstractFileSystemEntry, IFileSystemEntry> Value { get; set; }

		public TupleAbstractType() { }
	}

#endif // !NET35 && !UNITY
<#+
	}

	if ( generateMethods )
	{
#>
#if !NET35 && !UNITY
		[Test]
		[Category( "PolymorphicSerialization" )]
		public void TestTupleAbstractType_Success()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			var target = new TupleAbstractType { Value = Tuple.Create( <#= String.Join( ", ", Enumerable.Range( 1, 4 ).Select( i => String.Format( CultureInfo.InvariantCulture, "new FileEntry {{ Name = \"{0}\", Size = {0} }} as {1}FileSystemEntry", i, i % 2 == 1 ? "Abstract" : "I" ) ) ) #> ) };
			var serializer = context.GetSerializer<TupleAbstractType>();

			using ( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );

				Assert.That( result, Is.Not.Null );
				Assert.That( result, Is.Not.SameAs( target ) );
				Assert.That( result.Value, Is.EqualTo( target.Value ) );
				Assert.That( result.Value, Is.InstanceOf( target.Value.GetType() ) );
			}
		}
#endif // !NET35 && !UNITY
<#+
	}

	/*
		Cartesian of
		{Dup. Known | Dup. Runtime | Knwon and Runtime} x { Member | Collection Items | Collection Keys | Tuple Items}
	 */
	foreach ( var testCase in 
		new []
		{
			new { Name = "DuplicatedKnown", Known = 2, Runtime = 0 },
			new { Name = "KnownAndRuntime", Known = 1, Runtime = 1 },
			// Note: *RuntimeAttribute cannot be duplicate except tuple thanks to AllowMultiple = false
		}
	)
	{
		var typeNameMember = testCase.Name + "Member";
		if ( generateTypes )
		{
			GenerateAttributeErrorTestClass( typeNameMember, testCase.Known, testCase.Runtime, "FileSystemEntry", "FileEntry", String.Empty );
		}

		if ( generateMethods )
		{
			GenerateAttributeErrorTestMethod( testCase.Name + "Member", typeNameMember );
		}

		var typeNameCollectionItems = testCase.Name + "CollectionItem";
		if ( generateTypes )
		{
			GenerateAttributeErrorTestClass( typeNameCollectionItems, testCase.Known, testCase.Runtime, "IList<FileSystemEntry>", "FileEntry", "CollectionItem" );
		}

		if ( generateMethods )
		{
			GenerateAttributeErrorTestMethod( testCase.Name + "CollectionItem", typeNameCollectionItems );
		}

		var typeNameDictionaryKeys = testCase.Name + "DictionaryKey";
		if ( generateTypes )
		{
			 GenerateAttributeErrorTestClass( typeNameDictionaryKeys, testCase.Known, testCase.Runtime, "IDictionary<FileSystemEntry, string>", "FileEntry", "DictionaryKey" );
		}

		if ( generateMethods )
		{
			GenerateAttributeErrorTestMethod( testCase.Name + "DictionaryKey", typeNameDictionaryKeys );
		}
		
		var tupleItemClassName = testCase.Name + "TupleItem";
		if ( generateTypes )
		{
#>
#if !NET35 && !UNITY
	public class <#= tupleItemClassName #>
	{
<#+
	for ( var i = 0; i < testCase.Known; i++ )
	{
#>
		[MessagePackKnownTupleItemType( 1, "1", typeof( FileEntry ) )]
<#+
	}

	for ( var i = 0; i < testCase.Runtime; i++ )
	{
#>
		[MessagePackRuntimeTupleItemType( 1 )]
<#+
	}
#>
		public Tuple<FileSystemEntry> Value  { get; set; }

		public <#= tupleItemClassName #>() { }
	}
#endif // !NET35 && !UNITY
<#+
		}

		if ( generateMethods )
		{
#>
#if !NET35 && !UNITY
<#+
			GenerateAttributeErrorTestMethod( testCase.Name + "TupleItem", tupleItemClassName );
#>
#endif // !NET35 && !UNITY
<#+
		}
	}
}

private void GenerateAbstractTypeTestClass( string typeName, string attribute, string declarationType )
{
#>

	public class <#= typeName #>
	{
<#+
			if ( attribute != null )
			{
#>
		<#= attribute #>
<#+
			}
#>
		public <#= declarationType #> Value { get; set; }

		public <#= typeName #>() { }
	}
<#+
}

private void GenerateAbstractTypeTestMethod( string typeName, string initializer, string abstractCollectionType, string concreteCollectionType, bool isCollection, bool success )
{
#>

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void Test<#= typeName #>_<#= success ? "Success" : "Fail" #>()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
<#+
	if ( abstractCollectionType != null && concreteCollectionType != null )
	{
#>
			context.DefaultCollectionTypes.Register( typeof( <#= abstractCollectionType #> ), typeof( <#= concreteCollectionType #> ) );
<#+
	}
#>
			var target = new <#= typeName #> { Value = <#= initializer #> };

<#+
	if ( success )
	{
#>
			var serializer = context.GetSerializer<#= "<" + typeName + ">" #>();

			using ( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );

				Assert.That( result, Is.Not.Null );
				Assert.That( result, Is.Not.SameAs( target ) );
<#+
		if ( isCollection )
		{
#>
				Assert.That( result.Value.Count, Is.EqualTo( target.Value.Count ) );
				Assert.That( result.Value, Is.InstanceOf( target.Value.GetType() ) );
				Assert.That( result.Value, Is.EquivalentTo( target.Value ) );
<#+
		}
		else
		{
#>
				Assert.That( result.Value, Is.EqualTo( target.Value ) );
				Assert.That( result.Value, Is.InstanceOf( target.Value.GetType() ) );
<#+
		}
#>
			}
<#+
	}
	else
	{
#>
			Assert.Throws<NotSupportedException>( ()=> context.GetSerializer<#= "<" + typeName + ">" #>() );
<#+
	}
#>
		}
<#+
}

private void GenerateAttributeErrorTestClass( string typeName, int knownAttributeCount, int runtimeAttributeCount, string memberType, string knownType, string attributeQualifier )
{
#>

	public class <#= typeName #>
	{
<#+
	for ( var i = 0; i < knownAttributeCount; i++ )
	{
#>
		[MessagePackKnown<#= attributeQualifier #>Type( "1", typeof( <#= knownType #> ) )]
<#+
	}

	for ( var i = 0; i < runtimeAttributeCount; i++ )
	{
#>
		[MessagePackRuntime<#= attributeQualifier #>Type]
<#+
	}
#>
		public <#= memberType #> Value  { get; set; }

		public <#= typeName #>() { }
	}
<#+
}

private void GenerateAttributeErrorTestMethod(  string testCaseName, string typeName )
{
#>

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void TestAttribute_<#= testCaseName #>_Fail()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			var target = new <#= typeName #>();
			Assert.Throws<SerializationException>( ()=> context.GetSerializer<#= "<" + typeName + ">" #>() );
		}
<#+
}

private void GeneratePolymorohismExtensionTests( bool generateTypes, bool generateMethods )
{
	bool[] Bools = new [] { true, false };
	string[] PolymorphismKinds = new [] { "Known", "Runtime" };
	string[] TypeKinds = new [] { String.Empty, "Collection", "Dictionary" };
	string[] Results = new [] { null, "Known", "Runtime" };
	var attributeFormats =
		new Dictionary<string, string>
		{
			{ "Known", "[MessagePackKnownType( \"A\", typeof( {0}TypePolymorphic{1} ) )]" },
			{ "Runtime", "[MessagePackRuntimeType( VerifierType = typeof( DefaultTypeVerifier ), VerifierMethodName = \"AllowOnly{0}TypePolymorphic{1}\" )]" },
		};

	var polymorphicOverrideTestCases =
		TypeKinds.SelectMany( TypeKind =>
			PolymorphismKinds.SelectMany( PolymorphismKind =>
				Results.Select( Result =>
					new
					{
						TypeKind,
						PolymorphismKind,
						InterfaceName = "I" + PolymorphismKind + "TypePolymorphic" + TypeKind,
						MemberName = PolymorphismKind + "TypePolymorphic" + TypeKind + ( Result ?? "Vanilla" ),
						Result,
						Attribute = Result == null ? null : String.Format( CultureInfo.InvariantCulture, attributeFormats[ Result ], Result, TypeKind ),
					}
				)
			)
		).ToArray();
	
	var typeVerifierSpecs =
		Bools.Select( IsPublicType =>
			new
			{
				IsPublicType,
				VerifierTypeName = ( IsPublicType ? "Public" : "NonPublic" ) + "TypeVerifier",
				Methods =
					Bools.SelectMany( IsStaticMethod =>
						Bools.Select( IsPublicMethod =>
							new
							{
								IsStaticMethod,
								IsPublicMethod,
								VerifierMethodName = ( IsPublicMethod ? "Public" : "Private" ) + ( IsStaticMethod ? "Static" : "Instance" ) + "AllowAll"
							}
						)
					).ToArray()
			}
		).ToArray();

	var defaultTypeVerifierSpecs =
		PolymorphismKinds.SelectMany( polymorphismKind =>
			TypeKinds.Select( typeKind =>
				new
				{
					VerifierMethodName = "AllowOnly" +  polymorphismKind + "TypePolymorphic" + typeKind,
					AllowedType = polymorphismKind + "TypePolymorphic" + typeKind
				}
			)
		).ToArray();

	if ( generateTypes )
	{
#>

#region -- Polymorphic Attributes in Type and Member --

	[MessagePackKnownType( "1", typeof( KnownTypePolymorphic ) )]
	[MessagePackKnownType( "2", typeof( PolymorphicValueA ) )]
	[MessagePackKnownType( "3", typeof( PolymorphicValueB ) )]
	public interface IKnownTypePolymorphic : IPolymorphicValue { }

	[MessagePackRuntimeType]
	public interface IRuntimeTypePolymorphic : IPolymorphicValue { }

	[MessagePackKnownType( "1", typeof( KnownTypePolymorphicCollection ) )]
	[MessagePackKnownCollectionItemType( "1", typeof( PolymorphicValueA ) )]
	[MessagePackKnownCollectionItemType( "2", typeof( PolymorphicValueB ) )]
	public interface IKnownTypePolymorphicCollection : ICollection<IKnownTypePolymorphic> { }

	public class KnownTypePolymorphicCollection : List<IKnownTypePolymorphic>, IKnownTypePolymorphicCollection { }

	[MessagePackRuntimeType]
	[MessagePackRuntimeCollectionItemType]
	public interface IRuntimeTypePolymorphicCollection : ICollection<IRuntimeTypePolymorphic> { }

	public class RuntimeTypePolymorphicCollection : List<IRuntimeTypePolymorphic>, IRuntimeTypePolymorphicCollection { }

	[MessagePackKnownType( "1", typeof( KnownTypePolymorphicDictionary ) )]
	[MessagePackKnownDictionaryKeyType( "1", typeof( PolymorphicValueA ) )]
	[MessagePackKnownDictionaryKeyType( "2", typeof( PolymorphicValueB ) )]
	[MessagePackKnownCollectionItemType( "1", typeof( PolymorphicValueA ) )]
	[MessagePackKnownCollectionItemType( "2", typeof( PolymorphicValueB ) )]
	public interface IKnownTypePolymorphicDictionary : IDictionary<IKnownTypePolymorphic, IKnownTypePolymorphic> { }

	public class KnownTypePolymorphicDictionary : Dictionary<IKnownTypePolymorphic, IKnownTypePolymorphic> , IKnownTypePolymorphicDictionary { }

	[MessagePackRuntimeType]
	[MessagePackRuntimeDictionaryKeyType]
	[MessagePackRuntimeCollectionItemType]
	public interface IRuntimeTypePolymorphicDictionary : IDictionary<IRuntimeTypePolymorphic, IRuntimeTypePolymorphic> { }

	public class RuntimeTypePolymorphicDictionary : Dictionary<IRuntimeTypePolymorphic, IRuntimeTypePolymorphic> , IRuntimeTypePolymorphicDictionary { }

	[MessagePackRuntimeType( VerifierType = typeof( PublicTypeVerifier ) )]
	public class RuntimeTypePolymorphicWithInvalidVerifierNoMethods : PolymorphicValueBase { }

	[MessagePackRuntimeType( VerifierType = typeof( PublicTypeVerifier ), VerifierMethodName = "VoidReturn" )]
	public class RuntimeTypePolymorphicWithInvalidVerifierVoidReturnMethod : PolymorphicValueBase { }

	[MessagePackRuntimeType( VerifierType = typeof( PublicTypeVerifier ), VerifierMethodName = "NoParameters" )]
	public class RuntimeTypePolymorphicWithInvalidVerifierNoParametersMethod : PolymorphicValueBase { }

	[MessagePackRuntimeType( VerifierType = typeof( PublicTypeVerifier ), VerifierMethodName = "ExtraParameters" )]
	public class RuntimeTypePolymorphicWithInvalidVerifierExtraParametersMethod : PolymorphicValueBase { }

	public interface IPolymorphicValue
	{
		string Value { get; set; }
	}

	public abstract class PolymorphicValueBase : IPolymorphicValue
	{
		public string Value { get; set; }

		protected PolymorphicValueBase() { }

		public override bool Equals( object obj )
		{
			var other = obj as PolymorphicValueBase;
			if ( other == null )
			{
				return false;
			}
			
			return this.Value == other.Value;
		}

		public override int GetHashCode()
		{
			return this.Value == null ? 0 : this.Value.GetHashCode();
		}
	}

	public sealed class KnownTypePolymorphic : PolymorphicValueBase, IKnownTypePolymorphic { }

	public sealed class RuntimeTypePolymorphic : PolymorphicValueBase, IRuntimeTypePolymorphic { }

	public sealed class PolymorphicValueA : PolymorphicValueBase, IKnownTypePolymorphic, IRuntimeTypePolymorphic { }

	public sealed class PolymorphicValueB : PolymorphicValueBase, IKnownTypePolymorphic, IRuntimeTypePolymorphic { }

	[MessagePackRuntimeType( VerifierType = typeof( <#= typeVerifierSpecs[ 0 ].VerifierTypeName #> ), VerifierMethodName = "WithoutDangerous" )]
	public interface IRuntimeTypePolymorphicWithVerification : IRuntimeTypePolymorphic { }

	public sealed class DangerousClass : PolymorphicValueBase, IKnownTypePolymorphic, IRuntimeTypePolymorphicWithVerification
	{
		static DangerousClass()
		{
			Assert.Fail( "Dangerous call." );
		}
	}

	public class PolymorphicHolder
	{
<#+
		foreach( var testCase in polymorphicOverrideTestCases )
		{
			if( testCase.Attribute != null )
			{
#>
		<#= testCase.Attribute #>
<#+
			}
#>
		public <#= testCase.InterfaceName #> <#= testCase.MemberName #>Field;

<#+
			if( testCase.Attribute != null )
			{
#>
		<#= testCase.Attribute #>
<#+
			}
#>
		public <#= testCase.InterfaceName #> <#= testCase.MemberName #>Property { get; set; }

<#+
		} // foreach ( var testCase in ...

		foreach ( var typeSpec in typeVerifierSpecs )
		{
			foreach ( var methodSpec in typeSpec.Methods )
			{
#>
		[MessagePackRuntimeType( VerifierType = typeof( <#= typeSpec.VerifierTypeName #> ), VerifierMethodName = "<#= methodSpec.VerifierMethodName #>" )]
		public IRuntimeTypePolymorphic For<#= typeSpec.VerifierTypeName #><#= methodSpec.VerifierMethodName #> { get; set; }

<#+
			}
		}
#>
		public PolymorphicHolder() { }
	}  // PolymorphicHolder
<#+

		// Verifier
		foreach ( var typeSpec in typeVerifierSpecs )
		{
#>

#if !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
	<#= typeSpec.IsPublicType ? "public" : "internal" #>
#else
	public
#endif // !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
	sealed class <#= typeSpec.VerifierTypeName #>
	{
		private static readonly Regex VerificationRegex =
			new Regex( 	"^" + Regex.Escape( typeof( <#= typeSpec.VerifierTypeName #> ).Namespace ) + @"\.(Known|Runtime)Polymorphic(Collection|Dictionary)?$" );
<#+
			foreach ( var methodSpec in typeSpec.Methods )
			{
#>
#if !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
		<#= methodSpec.IsPublicMethod ? "public" : "private" #>
#else
		public
#endif // !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
		<#= methodSpec.IsStaticMethod ? " static" : String.Empty #> bool <#= methodSpec.VerifierMethodName #>( PolymorphicTypeVerificationContext context )
		{
			Assert.NotNull( context );
			Assert.That( context.LoadingTypeFullName, Is.Not.Empty );
			Assert.That( context.LoadingAssemblyFullName, Is.Not.Empty );
			Assert.That( context.LoadingAssemblyName, Is.Not.Null );
			Assert.That( context.LoadingAssemblyFullName, Is.EqualTo( context.LoadingAssemblyName.ToString() ) );

			return true;
		}

<#+
			} // foreach ( var methodSpec in ...
#>
		public static void VoidReturn( PolymorphicTypeVerificationContext context ) { }

		public static bool NoParameters()
		{
			return false;
		}

		public static bool ExtraParameters( PolymorphicTypeVerificationContext context, object state )
		{
			return false;
		}

		public static bool WithoutDangerous( PolymorphicTypeVerificationContext context )
		{
			return VerificationRegex.IsMatch( context.LoadingTypeFullName );
		}
	} // <#= typeSpec.VerifierTypeName #>
	
<#+
		} // foreach ( var typeSpec in ...
#>
	public static class DefaultTypeVerifier
	{
<#+
			foreach( var spec in defaultTypeVerifierSpecs )
			{
#>
		public static bool <#= spec.VerifierMethodName #>( PolymorphicTypeVerificationContext context )
		{
			return context.LoadingTypeFullName == typeof( <#= spec.AllowedType #> ).FullName;
		}

<#+
			}
#>
	}

<#+
		// end Verifier
#>

#endregion -- Polymorphic Attributes in Type and Member --

<#+
	} // if generateTypes

	if ( generateMethods )
	{
#>

#region -- Polymorphic Attributes in Type and Member --

		private static void SetUpDefaultCollectionsForPolymorphism( SerializationContext context )
		{
			context.DefaultCollectionTypes.Register( typeof( IKnownTypePolymorphicCollection ), typeof( KnownTypePolymorphicCollection ) );
			context.DefaultCollectionTypes.Register( typeof( IRuntimeTypePolymorphicCollection ), typeof( RuntimeTypePolymorphicCollection ) );
			context.DefaultCollectionTypes.Register( typeof( IKnownTypePolymorphicDictionary ), typeof( KnownTypePolymorphicDictionary ) );
			context.DefaultCollectionTypes.Register( typeof( IRuntimeTypePolymorphicDictionary ), typeof( RuntimeTypePolymorphicDictionary ) );
		}

		[Test]
		[Category( "PolymorphicSerialization" )]
		public void TestPolymorphismAttributesInType()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			SetUpDefaultCollectionsForPolymorphism( context );
			context.GetSerializer<IKnownTypePolymorphic>();
			context.GetSerializer<IRuntimeTypePolymorphic>();
			context.GetSerializer<IKnownTypePolymorphicCollection>();
			context.GetSerializer<IRuntimeTypePolymorphicCollection>();
			context.GetSerializer<IKnownTypePolymorphicDictionary>();
			context.GetSerializer<IRuntimeTypePolymorphicDictionary>();
		}
<#+
		foreach ( var testCase in polymorphicOverrideTestCases )
		{
			foreach ( var suffix in new [] { "Field", "Property" } )
			{
				var failsOnPack = testCase.PolymorphismKind == "Runtime" && testCase.Result == "Known";
#>
		[Test]
		[Category( "PolymorphicSerialization" )]
		public void Test<#= testCase.PolymorphismKind #>Type<#= testCase.TypeKind #>_AttributeIs<#= testCase.Result ?? "Nothing" #>_<#= suffix #>_<#= testCase.Result ?? testCase.PolymorphismKind #><#= failsOnPack ? "_Fail" : String.Empty #>()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			context.SerializationMethod = SerializationMethod.Map;
			SetUpDefaultCollectionsForPolymorphism( context );

			var target = new PolymorphicHolder();
			target.<#= testCase.MemberName #><#= suffix #> = new <#= testCase.PolymorphismKind #>TypePolymorphic<#= testCase.TypeKind #>();
			var serializer = context.GetSerializer<PolymorphicHolder>();
			
			using ( var buffer = new MemoryStream() )
			{
<#+
				if ( failsOnPack )
				{
#>
				var ex = Assert.Catch<SerializationException>( () => serializer.Pack( buffer ,target ) );
#if !UNITY && !XAMARIN
				Assert.That( ex.Message, Does.Contain( "is not defined as known type" ) );
#else
				Assert.That( ex.Message.Contains( "is not defined as known type" ), ex.Message );
#endif // !UNITY && !XAMARIN
<#+
				}
				else
				{
#>
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var serializedObject = Unpacking.UnpackObject( buffer );
				Assert.That( serializedObject.IsDictionary, Is.True, serializedObject.ToString() );
				var serializedMember = serializedObject.AsDictionary()[ "<#= testCase.MemberName #><#= suffix #>" ];
				Assert.That( serializedMember.IsArray, Is.True, serializedObject.ToString() );
				Assert.That( serializedMember.AsList().Count, Is.EqualTo( 2 ), serializedMember.ToString() );
				var typeHeader = serializedMember.AsList()[ 0 ];
<#+
					if ( ( testCase.Result ?? testCase.PolymorphismKind ) == "Known" )
					{
#>
				Assert.That( typeHeader.IsTypeOf<string>().GetValueOrDefault(), Is.True, typeHeader.ToString() ); // known type header
<#+
						if ( testCase.Result == testCase.PolymorphismKind )
						{
#>
				// Verify override in member value.
				Assert.That( typeHeader.AsString(), Is.EqualTo( "A" ), typeHeader.ToString() );
<#+
						}
					}
					else
					{
						// There are no way to verify override...
#>
				Assert.That( typeHeader.IsArray, typeHeader.ToString() );
				Assert.That( typeHeader.AsList().Count, Is.EqualTo( 6 ), typeHeader.ToString() ); // runtime type header
<#+
					} // if ( ( testCase.Result ?? testCase.PolymorphismKind ) == "Known" )
				} // if ( failsOnPack )
#>
			}
		}

<#+
			} // foreach ( var suffix in new [] { "Field", "Property" } )
		} // foreach( var testCase in polymorphicOverrideTestCases )
		
#>

#endregion -- Polymorphic Attributes in Type and Member --

#region -- TypeVerifier cases --

<#+

		foreach ( var typeSpec in typeVerifierSpecs )
		{
			foreach ( var methodSpec in typeSpec.Methods )
			{
#>
		[Test]
		[Category( "PolymorphicSerialization" )]
		public void TestTypeVerifierSelection_<#= typeSpec.IsPublicType ? "Public" : "NonPublic" #>VerifierType_<#= methodSpec.IsPublicMethod ? "Public" : "NonPublic" #><#= methodSpec.IsStaticMethod ? "Static" : "Instance" #>Method_OK()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			SetUpDefaultCollectionsForPolymorphism( context );
			var target = new PolymorphicHolder { For<#= typeSpec.VerifierTypeName #><#= methodSpec.VerifierMethodName #> = new PolymorphicValueA { Value = "Foo" } };
			var serializer = context.GetSerializer<PolymorphicHolder>();
			
			using ( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var deserialized = serializer.Unpack( buffer );
				Assert.That( deserialized.For<#= typeSpec.VerifierTypeName #><#= methodSpec.VerifierMethodName #>, Is.Not.Null );
				Assert.That( deserialized.For<#= typeSpec.VerifierTypeName #><#= methodSpec.VerifierMethodName #>.Value, Is.EqualTo( "Foo" ) );
			}
		}

<#+
			} // foreach ( var methodSpec in typeSpec.Methods )
		} // foreach ( var typeSpec in typeVerifierSpecs )

		foreach ( var reason in
			new []
			{
				"NoMethods",
				"VoidReturnMethod",
				"NoParametersMethod",
				"ExtraParametersMethod",
			}
		)
		{
			var typeName = "RuntimeTypePolymorphicWithInvalidVerifier" + reason;
#>
		[Test]
		[Category( "PolymorphicSerialization" )]
		public void TestSpecifiedTypeVerifierIsNotFound_Because<#= reason #>_Fail()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			var target = new <#= typeName #> { Value = "Foo" };
			
			var ex = Assert.Catch<SerializationException>( () => context.GetSerializer<<#= typeName #>>() );
#if !UNITY && !XAMARIN
			Assert.That( ex.Message, Does.StartWith( "VerifierMethodName cannot be null " ).Or.StartWith( "A public static or instance method " ) );
#else
			Assert.That( ex.Message.StartsWith( "VerifierMethodName cannot be null " ) || ex.Message.StartsWith( "A public static or instance method " ), ex.Message );
#endif // !UNITY && !XAMARIN
		}

<#+
		} // foreach ( var typeName in ...

#>
		[Test]
		[Category( "PolymorphicSerialization" )]
		public void TestTypeVerifierDoesNotLoadTypeItself()
		{
			var context = NewSerializationContext( PackerCompatibilityOptions.None );
			var serializer = context.GetSerializer<IRuntimeTypePolymorphicWithVerification>();
			
			using ( var buffer = new MemoryStream() )
			using ( var packer = Packer.Create( buffer ) )
			{
				Polymorphic.TypeInfoEncoder.Encode( packer, typeof( DangerousClass ) );
				packer.PackArrayHeader( 1 );
				packer.PackString( "Foo" ); // Value
				buffer.Position = 0;
				var ex = Assert.Catch<SerializationException>( () => serializer.Unpack( buffer ) );
#if !UNITY && !XAMARIN
				Assert.That( ex.Message, Does.StartWith( "Type verifier rejects type " ) );
#else
				Assert.That( ex.Message.StartsWith( "Type verifier rejects type " ), ex.Message );
#endif // !UNITY && !XAMARIN
			}
		}

#endregion -- TypeVerifier cases --

<#+
	} // if generateMethods
}

// Helper Methods
private static Func<string, string> GetMemberNameGenerator( TypeKind kind )
{
	return
		( kind & TypeKind.PropertyOrFieldMask ) == TypeKind.Field
		? new Func<string, string> ( parameter => Char.ToUpperInvariant( parameter[ 0 ] ) + parameter.Substring( 1 ) )
		: new Func<string, string> ( parameter => "_" + parameter );
}

// Internal Types
private struct Member
{
	public readonly string Name;
	public readonly string Type;
	public readonly PolymorphismTargets Targets;
	public readonly string[] ActualTypes;
	public readonly string InitialValue;
	public readonly string EmptyValue;
	public readonly KeyValuePair<int, string[]>[] PolymorphicTupleItemTypes;
	public readonly bool? AsObject;

	private Member( string name, string type, PolymorphismTargets targets, bool? asObject, string[] actualTypes, string emptyValue, string initialValue, KeyValuePair<int, string[]>[] polymorphicTupleItemTypes )
	{
		this.Name = name;
		this.Type = type;
		this.Targets = targets;
		this.ActualTypes = actualTypes;
		this.InitialValue = initialValue;
		this.EmptyValue = emptyValue;
		this.PolymorphicTupleItemTypes = polymorphicTupleItemTypes;
		this.AsObject = asObject;
	}

	public static Member Of( string name, string type, PolymorphismTargets targets, bool? asObject, string emptyValue, string initialValue, params string[] actualTypes )
	{
		return new Member( name, type, targets, asObject, actualTypes, emptyValue, initialValue, new KeyValuePair<int, string[]>[ 0 ] );
	}

	public static Member Of( string name, string type, bool? asObject, string initialValue, params KeyValuePair<int, string[]>[] polymorphicTupleItemTypes )
	{
		return new Member( name, type, PolymorphismTargets.TupleItem, asObject, null, "null", initialValue, polymorphicTupleItemTypes );
	}
}

private enum TypeKind
{
	PropertyOrFieldMask = 0xF,
	Field = 0x1,
	Property = 0x2,

	HasSetter = 0x10,
	IsPublicSetter = 0x20,

	IsReadOnly = 0x100,

	HasConstructor = 0x1000,

	NameIndicator = 0x10000000, // For ToString() support

	ReadWriteProperty = Property | HasSetter | IsPublicSetter | NameIndicator,
	ReadWriteField= Field| NameIndicator,
	GetOnlyCollectionProperty = Property| NameIndicator,
	PrivateSetterCollectionProperty = Property | HasSetter | NameIndicator,
	ReadOnlyCollectionField = Field | IsReadOnly| NameIndicator,
	GetOnlyPropertyAndConstructor = Property | HasConstructor | NameIndicator,
	PrivateSetterPropertyAndConstructor = Property | HasSetter | HasConstructor | NameIndicator,
	ReadOnlyFieldAndConstructor = Field | IsReadOnly | HasConstructor | NameIndicator,
}

private enum PolymorphismTargets
{
	None = 0,
	Member = 0x1,
	Key = 0x2,
	Item = 0x4,
	TupleItem = 0x8
}

public class TestTargetType
{
	public string Name { get; private set; }
	public bool IsNet35Supported { get; private set; }

	public TestTargetType( string name, bool isNet35Supported )
	{
		this.Name = name;
		this.IsNet35Supported = isNet35Supported;
	}
}
#>
