<#@include file="AutoMessagePackSerializerTest.Polymorphism.ttinclude" #>
<#+ 
void Geneate( string serializationMethod, string emitterFlavor, string builderTypeName, bool canDump, string language = "" )
{
	GenerateCore( serializationMethod, emitterFlavor, builderTypeName, language, canDump, false );
}

void GeneateForIos( string serializationMethod )
{
	GenerateCore( serializationMethod, "GenerationBased", null, String.Empty, false, true );
}

private void GenerateCore( string serializationMethod, string emitterFlavor, string builderTypeName, string language, bool canDump, bool forIos )
{
	var testClassName = serializationMethod + language + emitterFlavor + ( String.IsNullOrWhiteSpace( builderTypeName ) ? "Reflection" : "Auto" ) + "MessagePackSerializerTest";

	var constructorParamterSpecs =
		new []
		{
			new KeyValuePair<string, string>( "Byte", "( byte )2" ),
			new KeyValuePair<string, string>( "SByte", "( sbyte )-2" ),
			new KeyValuePair<string, string>( "Int16", "( short )-2" ),
			new KeyValuePair<string, string>( "UInt16", "( ushort )2" ),
			new KeyValuePair<string, string>( "Int32", "-2" ),
			new KeyValuePair<string, string>( "UInt32", "( uint )2" ),
			new KeyValuePair<string, string>( "Int64", "-2L" ),
			new KeyValuePair<string, string>( "UInt64", "( ulong )2L" ),
			new KeyValuePair<string, string>( "Single", "1.2f" ),
			new KeyValuePair<string, string>( "Double", "1.2" ),
			new KeyValuePair<string, string>( "Decimal", "1.2m" ),
			new KeyValuePair<string, string>( "Boolean", "true" ),
			new KeyValuePair<string, string>( "Char", "'A'" ),
			new KeyValuePair<string, string>( "String", "\"ABC\"" ),
		};
#>
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2010-2017 FUJIWARA, Yusuke and contributors
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
// Contributors:
//    Samuel Cragg
//
#endregion -- License Terms --

#if UNITY_5 || UNITY_STANDALONE || UNITY_WEBPLAYER || UNITY_WII || UNITY_IPHONE || UNITY_ANDROID || UNITY_PS3 || UNITY_XBOX360 || UNITY_FLASH || UNITY_BKACKBERRY || UNITY_WINRT
#define UNITY
#endif

#pragma warning disable 3003
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Linq;
#if !NET35 && !WINDOWS_PHONE
using System.Numerics;
#endif // !NET35 && !WINDOWS_PHONE
using System.Reflection;
#if !SILVERLIGHT
using System.Runtime.InteropServices.ComTypes;
#endif // !SILVERLIGHT
using System.Runtime.Serialization;
using System.Text;
<#+
if ( serializationMethod == "Map" && !forIos )
{
#>
using System.Text.RegularExpressions;
<#+
}
#>
#if FEATURE_TAP
using System.Threading;
using System.Threading.Tasks;
#endif // FEATURE_TAP
#if !SILVERLIGHT && !AOT && !NETSTANDARD1_1 && !NETSTANDARD1_3 && !XAMARIN
using MsgPack.Serialization.CodeDomSerializers;
#endif // !SILVERLIGHT && !AOT && !NETSTANDARD1_1 && !NETSTANDARD1_3 && !XAMARIN
#if !SILVERLIGHT && !AOT && !NETSTANDARD1_1
using MsgPack.Serialization.EmittingSerializers;
#endif // !SILVERLIGHT && !AOT && !NETSTANDARD1_1
#if SILVERLIGHT
// For DateTime.ToBinary() extension method
using MsgPack.Serialization.DefaultSerializers;
#endif // SILVERLIGHT
#if !MSTEST
using NUnit.Framework;
#else
using TestFixtureAttribute = Microsoft.VisualStudio.TestPlatform.UnitTestFramework.TestClassAttribute;
using TestAttribute = Microsoft.VisualStudio.TestPlatform.UnitTestFramework.TestMethodAttribute;
using SetUpAttribute = Microsoft.VisualStudio.TestPlatform.UnitTestFramework.TestInitializeAttribute;
using TearDownAttribute = Microsoft.VisualStudio.TestPlatform.UnitTestFramework.TestCleanupAttribute;
using TimeoutAttribute = NUnit.Framework.TimeoutAttribute;
using CategoryAttribute = Microsoft.VisualStudio.TestPlatform.UnitTestFramework.TestCategoryAttribute;
using Assert = NUnit.Framework.Assert;
using Is = NUnit.Framework.Is;
using Does = NUnit.Framework.Does;
#endif

namespace MsgPack.Serialization
{
	[TestFixture]
	[Timeout( 60000 )]
	public class <#= testClassName #>
	{
		private static SerializationContext GetSerializationContext()
		{
<#+
	if ( !forIos )
	{
#>
			var context = new SerializationContext { SerializationMethod = SerializationMethod.<#= serializationMethod #> };
			context.SerializerOptions.EmitterFlavor = EmitterFlavor.<#=  emitterFlavor #>;
#if SILVERLIGHT && !SILVERLIGHT_PRIVILEGED
			context.SerializerOptions.DisablePrivilegedAccess = true;
#endif // SILVERLIGHT && !SILVERLIGHT_PRIVILEGED
			return context;
<#+
	}
	else
	{
#>
			var context = PreGeneratedSerializerActivator.CreateContext( SerializationMethod.<#= serializationMethod #>, SerializationContext.Default.CompatibilityOptions.PackerCompatibilityOptions );
			// Register serializers for abstract class testing
			context.Serializers.Register( 
				new EchoKeyedCollection_2MessagePackSerializer<string, string>( context, null ) 
			);
			return context;
<#+
	}
#>
		}

		private static SerializationContext NewSerializationContext()
		{
			return NewSerializationContext( SerializationCompatibilityLevel.Latest );
		}

		private static SerializationContext NewSerializationContext( SerializationCompatibilityLevel compatibilityLevel )
		{
<#+
	if ( !forIos )
	{
#>
			var context = SerializationContext.CreateClassicContext( compatibilityLevel );
			context.SerializationMethod = SerializationMethod.<#= serializationMethod #>;
			context.SerializerOptions.EmitterFlavor = EmitterFlavor.<#= emitterFlavor #>;
#if SILVERLIGHT && !SILVERLIGHT_PRIVILEGED
			context.SerializerOptions.DisablePrivilegedAccess = true;
#endif // SILVERLIGHT && !SILVERLIGHT_PRIVILEGED
			return context;
<#+
	}
	else
	{
#>
			var context =  PreGeneratedSerializerActivator.CreateContext( SerializationMethod.Array, compatibilityLevel );
			// Register serializers for abstract class testing
			context.Serializers.Register( 
				new EchoKeyedCollection_2MessagePackSerializer<string, string>( context, null ) 
			);
			return context;
<#+
	}
#>
		}

		private MessagePackSerializer<T> CreateTarget<T>( SerializationContext context )
		{
			return context.GetSerializer<T>( context );
		}

#if UNITY
		[TestFixtureSetUp]
		public static void SetUpFixture()
		{
			MessagePackSerializer.PrepareCollectionType<byte>();
			MessagePackSerializer.PrepareCollectionType<char>();
			MessagePackSerializer.PrepareCollectionType<int>();
			MessagePackSerializer.PrepareCollectionType<decimal>();
			MessagePackSerializer.PrepareDictionaryType<string, int>();
			MessagePackSerializer.PrepareDictionaryType<int, int>();
			MessagePackSerializer.PrepareDictionaryType<string, DateTimeOffset>();
			MessagePackSerializer.PrepareType<System.Diagnostics.TraceOptions>();
			new ArraySegmentEqualityComparer<byte>().Equals( default( ArraySegment<byte> ), default( ArraySegment<byte> ) );
			new ArraySegmentEqualityComparer<char>().Equals( default( ArraySegment<char> ), default( ArraySegment<char> ) );
			new ArraySegmentEqualityComparer<int>().Equals( default( ArraySegment<int> ), default( ArraySegment<int> ) );
			new ArraySegmentEqualityComparer<decimal>().Equals( default( ArraySegment<decimal> ), default( ArraySegment<decimal> ) );
		}
#endif // UNITY
		
<#+
	if ( !forIos )
	{
#>
		private bool CanDump
		{
			get { return <#= canDump.ToString().ToLowerInvariant() #>; }
		}

#if !SILVERLIGHT && !AOT && !XAMARIN
		[SetUp]
		public void SetUp()
		{
<#+
		if ( emitterFlavor == "ExpressionBased" )
		{
#>
#warning TODO: true async
			SerializerDebugging.IsNaiveAsyncAllowed = true;
<#+
		}
#>

#if !NETSTANDARD1_1 && !NETSTANDARD1_3
			//SerializerDebugging.TraceEnabled = true;
			//SerializerDebugging.DumpEnabled = true;
			if ( SerializerDebugging.TraceEnabled )
			{
				Tracer.Emit.Listeners.Clear();
				Tracer.Emit.Switch.Level = SourceLevels.All;
#if NETSTANDARD2_0
				Tracer.Emit.Listeners.Add( new TextWriterTraceListener( Console.Out ) );
#else // NETSTANDRD2_0
				Tracer.Emit.Listeners.Add( new ConsoleTraceListener() );
#endif // NETSTANDRD2_0
			}

			SerializerDebugging.DependentAssemblyManager = new TempFileDependentAssemblyManager( TestContext.CurrentContext.TestDirectory );
			SerializerDebugging.DeletePastTemporaries();
			SerializerDebugging.OnTheFlyCodeGenerationEnabled = true;

#if NET35
			SerializerDebugging.SetCodeCompiler( CodeDomCodeGeneration.Compile );
#else
			SerializerDebugging.SetCodeCompiler( RoslynCodeGeneration.Compile );
#endif // NET35

			SerializerDebugging.DumpDirectory = TestContext.CurrentContext.TestDirectory;
			SerializerDebugging.AddRuntimeAssembly( typeof( AddOnlyCollection<> ).Assembly.Location );
			if( typeof( AddOnlyCollection<> ).Assembly != this.GetType().Assembly )
			{
				SerializerDebugging.AddRuntimeAssembly( this.GetType().Assembly.Location );
			}
#endif // !NETSTANDARD1_1 && !NETSTANDARD1_3
		}

		[TearDown]
		public void TearDown()
		{
#if !NETSTANDARD1_1 && !NETSTANDARD1_3

			if ( SerializerDebugging.DumpEnabled && this.CanDump )
			{
#if !NETSTANDARD2_0
				try
				{
					SerializerDebugging.Dump();
				}
				catch ( NotSupportedException ex )
				{
					Console.Error.WriteLine( ex );
				}
				finally
				{
					SerializationMethodGeneratorManager.Refresh();
				}
#else // !NETSTANDARD2_0
				SerializationMethodGeneratorManager.Refresh();
#endif // !NETSTANDARD2_0
			}

			SerializerDebugging.Reset();
			SerializerDebugging.OnTheFlyCodeGenerationEnabled = false;
#endif // !NETSTANDARD1_1 && !NETSTANDARD1_3
		}
#endif // !SILVERLIGHT && !AOT && !XAMARIN
<#+
	} // if !forIos
#>

		private void DoKnownCollectionTest<T>( SerializationContext context )
			where T : new()
		{
			using ( var buffer = new MemoryStream() )
			{
				CreateTarget<T>( context ).Pack( buffer, new T() );
			}
		}

		[Test]
		public void TestUnpackTo()
		{
			var target = this.CreateTarget<Int32[]>( GetSerializationContext() );
			using ( var buffer = new MemoryStream() )
			{
				target.Pack( buffer, new[] { 1, 2 } );
				buffer.Position = 0;
				int[] result = new int[ 2 ];
				using ( var unpacker = Unpacker.Create( buffer, false ) )
				{
					unpacker.Read();
					target.UnpackTo( unpacker, result );
					Assert.That( result, Is.EqualTo( new[] { 1, 2 } ) );
				}
			}
		}

		[Test]
		public void TestInt32()
		{
			TestCore( 1, stream => Unpacking.UnpackInt32( stream ), null );
		}

		[Test]
		public void TestInt64()
		{
			TestCore( Int32.MaxValue + 1L, stream => Unpacking.UnpackInt64( stream ), null );
		}

		[Test]
		public void TestString()
		{
			TestCore( "abc", stream => Unpacking.UnpackString( stream ), null );
		}

		[Test]
		public void TestDateTime()
		{
			TestCore(
				DateTime.UtcNow,
				stream => MessagePackSerializer.UnpackMessagePackObject( stream ).AsTimestamp().ToDateTime(),
				( x, y ) => x.Equals( y ),
				context =>
				{
					Assert.That( context.DefaultDateTimeConversionMethod, Is.EqualTo( DateTimeConversionMethod.Timestamp ) );
				}
			);
		}

		[Test]
		public void TestDateTimeOffset()
		{
			TestCore(
				DateTimeOffset.UtcNow,
				stream => MessagePackSerializer.UnpackMessagePackObject( stream ).AsTimestamp().ToDateTimeOffset(),
				( x, y ) => x.Equals( y ),
				context =>
				{
					Assert.That( context.DefaultDateTimeConversionMethod, Is.EqualTo( DateTimeConversionMethod.Timestamp ) );
				}
			);
		}

		[Test]
		public void TestDateTimeLatest()
		{
			TestCore(
				DateTime.UtcNow,
				stream => Timestamp.Decode( Unpacking.UnpackExtendedTypeObject( stream ) ).ToDateTime(),
				( x, y ) => x.Equals( y ),
				context =>
				{
					context.DefaultDateTimeConversionMethod = DateTimeConversionMethod.Timestamp;
				}
			);
		}

		[Test]
		public void TestDateTimeOffsetLatest()
		{
			TestCore(
				DateTimeOffset.UtcNow,
				stream => Timestamp.Decode( Unpacking.UnpackExtendedTypeObject( stream ) ).ToDateTimeOffset(),
				( x, y ) => x.Equals( y ),
				context =>
				{
					context.DefaultDateTimeConversionMethod = DateTimeConversionMethod.Timestamp;
				}
			);
		}

		[Test]
		public void TestDateTimeClassic0_9()
		{
			TestCore(
				DateTime.Now, // Use now because Native mode should serialize its kind
				stream => DateTime.FromBinary( Unpacking.UnpackInt64( stream ) ),
				( x, y ) => x.Equals( y ),
				context =>
				{
					context.DefaultDateTimeConversionMethod = DateTimeConversionMethod.Native;
				}
			);
		}

		[Test]
		public void TestDateTimeOffsetClassic0_9()
		{
			TestCore(
				DateTimeOffset.Now, // Use now because Native mode should serialize its kind
				stream => 
					{
						var array = Unpacking.UnpackArray( stream );
						return new DateTimeOffset( DateTime.FromBinary( array[ 0 ].AsInt64() ), TimeSpan.FromMinutes( array[ 1 ].AsInt16() ) );
					},
				( x, y ) => x.Equals( y ),
				context =>
				{
					context.DefaultDateTimeConversionMethod = DateTimeConversionMethod.Native;
				}
			);
		}

		[Test]
		public void TestDateTimeClassic0_5()
		{
			TestCore(
				DateTime.UtcNow,
				stream => MessagePackConvert.ToDateTime( Unpacking.UnpackInt64( stream ) ),
				CompareDateTime,
				context =>
				{
					context.DefaultDateTimeConversionMethod = DateTimeConversionMethod.UnixEpoc;
				}
			);
		}

		[Test]
		public void TestDateTimeOffsetClassic0_5()
		{
			TestCore(
				DateTimeOffset.UtcNow,
				stream => MessagePackConvert.ToDateTimeOffset( Unpacking.UnpackInt64( stream ) ),
				CompareDateTime,
				context =>
				{
					context.DefaultDateTimeConversionMethod = DateTimeConversionMethod.UnixEpoc;
				}
			);
		}
		
		[Test]
		public void TestDateTimeNullableChangeOnDemand()
		{
			TestCore(
				( DateTime? )DateTime.UtcNow,
				stream => MessagePackConvert.ToDateTime( Unpacking.UnpackInt64( stream ) ),
				CompareDateTime,
				context =>
				{
					context.GetSerializer<DateTime?>();
					context.DefaultDateTimeConversionMethod = DateTimeConversionMethod.UnixEpoc;
				}
			);
		}

		[Test]
		public void TestDateTimeOffsetNullableChangeOnDemand()
		{
			TestCore(
				( DateTimeOffset? )DateTimeOffset.UtcNow,
				stream => MessagePackConvert.ToDateTimeOffset( Unpacking.UnpackInt64( stream ) ),
				CompareDateTime,
				context =>
				{
					context.GetSerializer<DateTimeOffset?>();
					context.DefaultDateTimeConversionMethod = DateTimeConversionMethod.UnixEpoc;
				}
			);
		}

		private static bool CompareDateTime( DateTime x, DateTime y )
		{
			return x.Date == y.Date && x.Hour == y.Hour && x.Minute == y.Minute && x.Second == y.Second && x.Millisecond == y.Millisecond;
		}

		private static bool CompareDateTime( DateTime? x, DateTime? y )
		{
			return CompareDateTime( x.Value, y.Value );
		}

		private static bool CompareDateTime( DateTimeOffset x, DateTimeOffset y )
		{
			return CompareDateTime( x.DateTime, y.DateTime ) && x.Offset == y.Offset;
		}

		private static bool CompareDateTime( DateTimeOffset? x, DateTimeOffset? y )
		{
			return CompareDateTime( x.Value, y.Value );
		}

<#+
	foreach ( var contextSetting in new[] { "Native", "UnixEpoc" } )
	{
		foreach ( var kind in new[] { new { Label = "Local", Property = "Now" }, new { Label = "Utc", Property = "UtcNow" } }
			)
		{
			#>
		[Test]
		public void TestDateTimeMemberAttributes_<#= contextSetting #>Context_<#= kind.Label #>()
		{
			var context = GetSerializationContext();
<#+
			if ( contextSetting == "Navie" )
			{
#>
			Assert.That( context.DefaultDateTimeConversionMethod, Is.EqualTo( DateTimeConversionMethod.<#= contextSetting #> ) );
<#+
			}
			else
			{
#>
			context.DefaultDateTimeConversionMethod = DateTimeConversionMethod.<#= contextSetting #>;
<#+
			}
#>
			var target = this.CreateTarget<AnnotatedDateTimes>( context );
			using ( var buffer = new MemoryStream() )
			{
				var input = new AnnotatedDateTimes( DateTimeOffset.<#= kind.Property #> );
				target.Pack( buffer, input );
				buffer.Position = 0;
				var result = target.Unpack( buffer );
<#+

			foreach ( var memberType in new[] { "Field", "Property" } )
			{
				var suffix = String.Format( CultureInfo.InvariantCulture, "DateTime{0}", memberType );
				if ( contextSetting == "Native" )
				{
#>

				// Kind is preserved.
				Assert.That( result.Vanilla<#= suffix #>, Is.EqualTo( input.Vanilla<#= suffix #> ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Vanilla<#= suffix #>, input.Vanilla<#= suffix #> );
				Assert.That( result.Default<#= suffix #>, Is.EqualTo( input.Default<#= suffix #> ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Default<#= suffix #>, input.Default<#= suffix #> );
<#+
				}
				else
				{
#>

				// UTC is forced.
				Assert.That( CompareDateTime( result.Vanilla<#= suffix #>, input.Vanilla<#= suffix #>.ToUniversalTime() ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Vanilla<#= suffix #>, input.Vanilla<#= suffix #> );
				Assert.That( CompareDateTime( result.Default<#= suffix #>, input.Default<#= suffix #>.ToUniversalTime() ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Default<#= suffix #>, input.Default<#= suffix #> );
<#+
				}
#>
				Assert.That( result.Native<#= suffix #>, Is.EqualTo( input.Native<#= suffix #> ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Native<#= suffix #>, input.Native<#= suffix #> );
				Assert.That( CompareDateTime( result.UnixEpoc<#= suffix #>, input.UnixEpoc<#= suffix #>.ToUniversalTime() ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.UnixEpoc<#= suffix #>, input.UnixEpoc<#= suffix #> );

<#+
				suffix = String.Format( CultureInfo.InvariantCulture, "DateTimeOffset{0}", memberType );
				if ( contextSetting == "Native" )
				{
#>

				// Offset is preserved. 
				Assert.That( result.Vanilla<#= suffix #>, Is.EqualTo( input.Vanilla<#= suffix #> ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Vanilla<#= suffix #>, input.Vanilla<#= suffix #> );
				Assert.That( result.Default<#= suffix #>, Is.EqualTo( input.Default<#= suffix #> ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Default<#= suffix #>, input.Default<#= suffix #> );
<#+
				}
				else if ( kind.Label == "Utc" )
				{
#>

				// UTC == UTC
				Assert.That( CompareDateTime( result.Vanilla<#= suffix #>, input.Vanilla<#= suffix #> ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Vanilla<#= suffix #>, input.Vanilla<#= suffix #> );
				Assert.That( CompareDateTime( result.Default<#= suffix #>, input.Default<#= suffix #> ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Default<#= suffix #>, input.Default<#= suffix #> );
<#+
				}
				else
				{
#>

				// UTC is forced.
				Assert.That( CompareDateTime( result.Vanilla<#= suffix #>, input.Vanilla<#= suffix #>.ToUniversalTime() ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Vanilla<#= suffix #>, input.Vanilla<#= suffix #> );
				Assert.That( CompareDateTime( result.Default<#= suffix #>, input.Default<#= suffix #>.ToUniversalTime() ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Default<#= suffix #>, input.Default<#= suffix #> );
<#+
				}
#>
				Assert.That( result.Native<#= suffix #>, Is.EqualTo( input.Native<#= suffix #> ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.Native<#= suffix #>, input.Native<#= suffix #> );
<#+
				if ( kind.Label == "Utc" )
				{
#>
				// UTC == UTC
				Assert.That( CompareDateTime( result.UnixEpoc<#= suffix #>, input.UnixEpoc<#= suffix #> ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.UnixEpoc<#= suffix #>, input.UnixEpoc<#= suffix #> );
<#+
				}
				else
				{
#>
				// UTC is forced.
				Assert.That( CompareDateTime( result.UnixEpoc<#= suffix #>, input.UnixEpoc<#= suffix #>.ToUniversalTime() ), "{0:O}({0:%K}) == {1:O}({1:%K})", result.UnixEpoc<#= suffix #>, input.UnixEpoc<#= suffix #> );
<#+
				}
			}
#>
			}
		}

<#+
		}
	}
#>

		[Test]
		public void TestUri()
		{
			TestCore( new Uri( "http://www.example.com" ), stream => new Uri( Unpacking.UnpackString( stream ) ), null );
		}

<#+
	if ( !forIos )
	{
		// Not needed because generation itself has been done.
#>
		[Test]
		public void TestComplexObject_WithShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = false;
			try 
			{
				this.TestComplexObjectCore( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		[Test]
		public void TestComplexObject_WithoutShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = true;
			try 
			{
				this.TestComplexObjectCore( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		private void TestComplexObjectCore( SerializationContext context )
		{
			var target = new ComplexType() { Source = new Uri( "http://www.exambple.com" ), TimeStamp = DateTime.Now, Data = new byte[] { 0x1, 0x2, 0x3, 0x4 } };
			target.History.Add( DateTime.Now.Subtract( TimeSpan.FromDays( 1 ) ), "Create New" );
			target.Points.Add( 123 );
			TestCoreWithVerify( target, context );
		}

#if FEATURE_TAP
		[Test]
		public async Task TestComplexObjectAsync_WithShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = false;
			try 
			{
				await this.TestComplexObjectAsyncCore( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		[Test]
		public async Task TestComplexObjectAsync_WithoutShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = true;
			try 
			{
				await this.TestComplexObjectAsyncCore( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		private async Task TestComplexObjectAsyncCore( SerializationContext context )
		{
			var target = new ComplexType() { Source = new Uri( "http://www.exambple.com" ), TimeStamp = DateTime.Now, Data = new byte[] { 0x1, 0x2, 0x3, 0x4 } };
			target.History.Add( DateTime.Now.Subtract( TimeSpan.FromDays( 1 ) ), "Create New" );
			target.Points.Add( 123 );
			await TestCoreWithVerifyAsync( target, context );
		}
#endif // FEATURE_TAP

		[Test]
		public void TestComplexTypeWithoutAnyAttribute_WithShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = false;
			try 
			{
				this.TestComplexTypeWithoutAnyAttribute( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		[Test]
		public void TestComplexTypeWithoutAnyAttribute_WithoutShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = true;
			try 
			{
				this.TestComplexTypeWithoutAnyAttribute( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		private void TestComplexTypeWithoutAnyAttribute( SerializationContext context )
		{
			var target = new ComplexTypeWithoutAnyAttribute() { Source = new Uri( "http://www.exambple.com" ), TimeStamp = DateTime.Now, Data = new byte[] { 0x1, 0x2, 0x3, 0x4 } };
			target.History.Add( DateTime.Now.Subtract( TimeSpan.FromDays( 1 ) ), "Create New" );
			TestCoreWithVerify( target, context );
		}

		[Test]
		public void TestTypeWithMissingMessagePackMemberAttributeMember()
		{
			this.TestTypeWithMissingMessagePackMemberAttributeMemberCore( GetSerializationContext() );
		}

		private void TestTypeWithMissingMessagePackMemberAttributeMemberCore( SerializationContext context )
		{
			var target = new TypeWithMissingMessagePackMemberAttributeMember();
			TestCoreWithVerify( target, context );
		}

		[Test]
		public void TestTypeWithInvalidMessagePackMemberAttributeMember()
		{
			Assert.Throws<SerializationException>( () => this.CreateTarget<TypeWithInvalidMessagePackMemberAttributeMember>( GetSerializationContext() ) );
		}

		[Test]
		public void TestTypeWithDuplicatedMessagePackMemberAttributeMember()
		{
			Assert.Throws<SerializationException>( () => this.CreateTarget<TypeWithDuplicatedMessagePackMemberAttributeMember>( GetSerializationContext() ) );
		}

		[Test]
		public void TestComplexObjectTypeWithDataContract_WithShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = false;
			try 
			{
				this.TestComplexObjectTypeWithDataContractCore( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		[Test]
		public void TestComplexObjectTypeWithDataContract_WithoutShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = true;
			try 
			{
				this.TestComplexObjectTypeWithDataContractCore( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		private void TestComplexObjectTypeWithDataContractCore( SerializationContext context )
		{
			var target = new ComplexTypeWithDataContract() { Source = new Uri( "http://www.exambple.com" ), TimeStamp = DateTime.Now, Data = new byte[] { 0x1, 0x2, 0x3, 0x4 } };
			target.History.Add( DateTime.Now.Subtract( TimeSpan.FromDays( 1 ) ), "Create New" );
#if !NETFX_CORE && !SILVERLIGHT && !NETSTANDARD1_1 && !NETSTANDARD1_3
			target.NonSerialized = new DefaultTraceListener();
#else
			target.NonSerialized = new Stopwatch();
#endif // !NETFX_CORE && !SILVERLIGHT && !NETSTANDARD1_1 && !NETSTANDARD1_3
			TestCoreWithVerify( target, context );
		}

		[Test]
		public void TestComplexTypeWithDataContractWithOrder_WithShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = false;
			try 
			{
				this.TestComplexTypeWithDataContractWithOrderCore( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		[Test]
		public void TestComplexTypeWithDataContractWithOrder_WithoutShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = true;
			try 
			{
				this.TestComplexTypeWithDataContractWithOrderCore( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		private void TestComplexTypeWithDataContractWithOrderCore( SerializationContext context )
		{
			var target = new ComplexTypeWithDataContractWithOrder() { Source = new Uri( "http://www.exambple.com" ), TimeStamp = DateTime.Now, Data = new byte[] { 0x1, 0x2, 0x3, 0x4 } };
			target.History.Add( DateTime.Now.Subtract( TimeSpan.FromDays( 1 ) ), "Create New" );
#if !NETFX_CORE && !SILVERLIGHT && !NETSTANDARD1_1 && !NETSTANDARD1_3
			target.NonSerialized = new DefaultTraceListener();
#else
			target.NonSerialized = new Stopwatch();
#endif // !NETFX_CORE && !SILVERLIGHT && !NETSTANDARD1_1 && !NETSTANDARD1_3
			TestCoreWithVerify( target, context );
		}

		[Test]
		public void TestComplexObjectTypeWithNonSerialized_WithShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = false;
			try 
			{
				this.TestComplexObjectTypeWithNonSerializedCore( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
		}

		[Test]
		public void TestComplexObjectTypeWithNonSerialized_WithoutShortcut()
		{
			SerializerDebugging.AvoidsGenericSerializer = true;
			try 
			{
				this.TestComplexObjectTypeWithNonSerializedCore( GetSerializationContext() );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = false;
			}
	}

		private void TestComplexObjectTypeWithNonSerializedCore( SerializationContext context )
		{
			var target = new ComplexTypeWithNonSerialized() { Source = new Uri( "http://www.exambple.com" ), TimeStamp = DateTime.Now, Data = new byte[] { 0x1, 0x2, 0x3, 0x4 } };
			target.History.Add( DateTime.Now.Subtract( TimeSpan.FromDays( 1 ) ), "Create New" );
#if !NETFX_CORE && !SILVERLIGHT && !NETSTANDARD1_1 && !NETSTANDARD1_3
			target.NonSerialized = new DefaultTraceListener();
#endif // !NETFX_CORE && !SILVERLIGHT && !NETSTANDARD1_1 && !NETSTANDARD1_3
			TestCoreWithVerify( target, context );
		}

		[Test]
		public void TestDataMemberAttributeOrderWithOneBase()
		{
			var context = GetSerializationContext();
			var value = new ComplexTypeWithOneBaseOrder();
			var target = this.CreateTarget<ComplexTypeWithOneBaseOrder>( context );
			using ( var buffer = new MemoryStream() )
			{
				target.Pack( buffer, value );
				buffer.Position = 0;
				var unpacked = target.Unpack( buffer );
				Assert.That( unpacked.One, Is.EqualTo( value.One ) );
				Assert.That( unpacked.Two, Is.EqualTo( value.Two ) );
			}
		}

#if FEATURE_TAP

		[Test]
		public async Task TestDataMemberAttributeOrderWithOneBaseAsync()
		{
			var context = GetSerializationContext();
			var value = new ComplexTypeWithOneBaseOrder();
			var target = this.CreateTarget<ComplexTypeWithOneBaseOrder>( context );
			using ( var buffer = new MemoryStream() )
			{
				await target.PackAsync( buffer, value ).ConfigureAwait( false );
				buffer.Position = 0;
				var unpacked = await target.UnpackAsync( buffer ).ConfigureAwait( false );
				Assert.That( unpacked.One, Is.EqualTo( value.One ) );
				Assert.That( unpacked.Two, Is.EqualTo( value.Two ) );
			}
		}

#endif // FEATURE_TAP

		[Test]
		public void TestDataMemberAttributeOrderWithOneBase_ProtoBufCompatible()
		{
			var context = GetSerializationContext();
			context.CompatibilityOptions.OneBoundDataMemberOrder = true;
			var value = new ComplexTypeWithOneBaseOrder();
			var target = this.CreateTarget<ComplexTypeWithOneBaseOrder>( context );
			using ( var buffer = new MemoryStream() )
			{
				target.Pack( buffer, value );
				buffer.Position = 0;
				var unpacked = target.Unpack( buffer );
				Assert.That( unpacked.One, Is.EqualTo( value.One ) );
				Assert.That( unpacked.Two, Is.EqualTo( value.Two ) );
			}
		}

#if FEATURE_TAP

		[Test]
		public async Task TestDataMemberAttributeOrderWithOneBase_ProtoBufCompatibleAsync()
		{
			var context = GetSerializationContext();
			context.CompatibilityOptions.OneBoundDataMemberOrder = true;
			var value = new ComplexTypeWithOneBaseOrder();
			var target = this.CreateTarget<ComplexTypeWithOneBaseOrder>( context );
			using ( var buffer = new MemoryStream() )
			{
				await target.PackAsync( buffer, value ).ConfigureAwait( false );
				buffer.Position = 0;
				var unpacked = await target.UnpackAsync( buffer ).ConfigureAwait( false );
				Assert.That( unpacked.One, Is.EqualTo( value.One ) );
				Assert.That( unpacked.Two, Is.EqualTo( value.Two ) );
			}
		}

#endif // FEATURE_TAP

		[Test]
		public void TestDataMemberAttributeOrderWithOneBaseDeserialize()
		{
			var context = GetSerializationContext();
			context.SerializationMethod = SerializationMethod.Array;
			var target = this.CreateTarget<ComplexTypeWithOneBaseOrder>( context );
			using ( var buffer = new MemoryStream() )
			{
				buffer.Write( new byte[] { 0x93, 0xff, 10, 20 } );
				buffer.Position = 0;
				var unpacked = target.Unpack( buffer );
				Assert.That( unpacked.One, Is.EqualTo( 10 ) );
				Assert.That( unpacked.Two, Is.EqualTo( 20 ) );
			}
		}

#if FEATURE_TAP

		[Test]
		public async Task TestDataMemberAttributeOrderWithOneBaseDeserializeAsync()
		{
			var context = GetSerializationContext();
			context.SerializationMethod = SerializationMethod.Array;
			var target = this.CreateTarget<ComplexTypeWithOneBaseOrder>( context );
			using ( var buffer = new MemoryStream() )
			{
				buffer.Write( new byte[] { 0x93, 0xff, 10, 20 } );
				buffer.Position = 0;
				var unpacked = await target.UnpackAsync( buffer ).ConfigureAwait( false );
				Assert.That( unpacked.One, Is.EqualTo( 10 ) );
				Assert.That( unpacked.Two, Is.EqualTo( 20 ) );
			}
		}

#endif // FEATURE_TAP

		[Test]
		public void TestDataMemberAttributeOrderWithOneBaseDeserialize_ProtoBufCompatible()
		{
			var context = GetSerializationContext();
			context.SerializationMethod = SerializationMethod.Array;
			context.CompatibilityOptions.OneBoundDataMemberOrder = true;
			var target = this.CreateTarget<ComplexTypeWithOneBaseOrder>( context );
			using ( var buffer = new MemoryStream() )
			{
				buffer.Write( new byte[] { 0x92, 10, 20 } );
				buffer.Position = 0;
				var unpacked = target.Unpack( buffer );
				Assert.That( unpacked.One, Is.EqualTo( 10 ) );
				Assert.That( unpacked.Two, Is.EqualTo( 20 ) );
			}
		}

#if FEATURE_TAP

		[Test]
		public async Task TestDataMemberAttributeOrderWithOneBaseDeserialize_ProtoBufCompatibleAsync()
		{
			var context = GetSerializationContext();
			context.SerializationMethod = SerializationMethod.Array;
			context.CompatibilityOptions.OneBoundDataMemberOrder = true;
			var target = this.CreateTarget<ComplexTypeWithOneBaseOrder>( context );
			using ( var buffer = new MemoryStream() )
			{
				buffer.Write( new byte[] { 0x92, 10, 20 } );
				buffer.Position = 0;
				var unpacked = await target.UnpackAsync( buffer ).ConfigureAwait( false );
				Assert.That( unpacked.One, Is.EqualTo( 10 ) );
				Assert.That( unpacked.Two, Is.EqualTo( 20 ) );
			}
		}

#endif // FEATURE_TAP

		[Test]
		public void TestDataMemberAttributeOrderWithZeroBase_ProtoBufCompatible_Fail()
		{
			var context = GetSerializationContext();
			context.SerializationMethod = SerializationMethod.Array;
			context.CompatibilityOptions.OneBoundDataMemberOrder = true;
			Assert.Throws<NotSupportedException>(
				() => this.CreateTarget<ComplexTypeWithTwoMember>( context )
			);
		}

		[Test]
		public void TestDataMemberAttributeNamedProperties()
		{
			var context = GetSerializationContext();
			if ( context.SerializationMethod == SerializationMethod.Array )
			{
				// Nothing to test.
				return;
			}

			var value = new DataMemberAttributeNamedPropertyTestTarget() { Member = "A Member" };
			var target = this.CreateTarget<DataMemberAttributeNamedPropertyTestTarget>( context );
			using ( var buffer = new MemoryStream() )
			{
				target.Pack( buffer, value );
				buffer.Position = 0;
				var asDictionary = Unpacking.UnpackDictionary( buffer );

				Assert.That( asDictionary[ "Alias" ] == value.Member );

				buffer.Position = 0;

				var unpacked = target.Unpack( buffer );
				Assert.That( unpacked.Member, Is.EqualTo( value.Member ) );
			}
		}
<#+
	} // !forIOS
#>

		[Test]
		public void TestEnum()
		{
#if !SILVERLIGHT
			TestCore( DayOfWeek.Sunday, stream => ( DayOfWeek )Enum.Parse( typeof( DayOfWeek ), Unpacking.UnpackString( stream ) ), ( x, y ) => x == y );
#else
			TestCore( DayOfWeek.Sunday, stream => ( DayOfWeek )Enum.Parse( typeof( DayOfWeek ), Unpacking.UnpackString( stream ), false ), ( x, y ) => x == y );
#endif // !SILVERLIGHT
		}

#if !NETFX_CORE && !SILVERLIGHT
		[Test]
		public void TestNameValueCollection()
		{
			var target = new NameValueCollection();
			target.Add( String.Empty, "Empty-1" );
			target.Add( String.Empty, "Empty-2" );
			target.Add( "1", "1-1" );
			target.Add( "1", "1-2" );
			target.Add( "1", "1-3" );
			target.Add( "null", null ); // This value will not be packed.
			target.Add( "Empty", String.Empty );
			target.Add( "2", "2" );
			var serializer = this.CreateTarget<NameValueCollection>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, target );
				stream.Position = 0;
				NameValueCollection result = serializer.Unpack( stream );
				Assert.That( result.GetValues( String.Empty ), Is.EquivalentTo( new[] { "Empty-1", "Empty-2" } ) );
				Assert.That( result.GetValues( "1" ), Is.EquivalentTo( new[] { "1-1", "1-2", "1-3" } ) );
				Assert.That( result.GetValues( "null" ), Is.Null );
				Assert.That( result.GetValues( "Empty" ), Is.EquivalentTo( new string[] { String.Empty } ) );
				Assert.That( result.GetValues( "2" ), Is.EquivalentTo( new string[] { "2" } ) );
				// null only value is not packed.
				Assert.That( result.Count, Is.EqualTo( target.Count - 1 ) );
			}
		}

		[Test]
		public void TestNameValueCollection_NullKey()
		{
			var target = new NameValueCollection();
			target.Add( null, "null" );
			var serializer = this.CreateTarget<NameValueCollection>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				Assert.Throws<NotSupportedException>( () => serializer.Pack( stream, target ) );
			}
		}
#endif

		[Test]
		public void TestByteArrayContent()
		{
			var serializer = this.CreateTarget<byte[]>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new byte[] { 1, 2, 3, 4 } );
				stream.Position = 0;
				Assert.That( Unpacking.UnpackBinary( stream ).ToArray(), Is.EqualTo( new byte[] { 1, 2, 3, 4 } ) );
			}
		}

		[Test]
		public void TestCharArrayContent()
		{
			var serializer = this.CreateTarget<char[]>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new char[] { 'a', 'b', 'c', 'd' } );
				stream.Position = 0;
				Assert.That( Unpacking.UnpackString( stream ), Is.EqualTo( "abcd" ) );
			}
		}

<#+
	if ( !forIos )
	{
#>
#if !NET35
		[Test]
		public void TestTuple1()
		{
			TestTupleCore( new Tuple<int>( 1 ), 1 );
		}

		[Test]
		public void TestTuple7()
		{
			TestTupleCore( new Tuple<int, string, int, string, int, string, int>( 1, "2", 3, "4", 5, "6", 7 ), 7 );
		}

		[Test]
		public void TestTuple8()
		{
			TestTupleCore(
				new Tuple<
					int, string, int, string, int, string, int,
				Tuple<string>>(
					1, "2", 3, "4", 5, "6", 7,
					new Tuple<string>( "8" )
				),
				8
			);
		}

		[Test]
		public void TestTuple14()
		{
			TestTupleCore(
				new Tuple<
					int, string, int, string, int, string, int,
					Tuple<
						string, int, string, int, string, int, string
					>
				>(
					1, "2", 3, "4", 5, "6", 7,
					new Tuple<string, int, string, int, string, int, string>(
						"8", 9, "10", 11, "12", 13, "14"
					)
				),
				14
			);
		}

		[Test]
		public void TestTuple15()
		{
			TestTupleCore(
				new Tuple<
					int, string, int, string, int, string, int,
					Tuple<
						string, int, string, int, string, int, string,
						Tuple<int>
					>
				>(
					1, "2", 3, "4", 5, "6", 7,
					new Tuple<string, int, string, int, string, int, string, Tuple<int>>(
						"8", 9, "10", 11, "12", 13, "14",
						new Tuple<int>( 15 )
					)
				),
				15
			);
		}

#if !SILVERLIGHT

		[Test]
		public void TestValueTuple0()
		{
			TestTupleCore( new ValueTuple(), 0 );
		}

		[Test]
		public void TestValueTuple1()
		{
			TestTupleCore( new ValueTuple<int>( 1 ), 1 );
		}

		[Test]
		public void TestValueTuple7()
		{
			TestTupleCore( new ValueTuple<int, string, int, string, int, string, int>( 1, "2", 3, "4", 5, "6", 7 ), 7 );
		}

		[Test]
		public void TestValueTuple7Plus0()
		{
			TestTupleCore(
				new ValueTuple<
					int, string, int, string, int, string, int,
				ValueTuple>(
					1, "2", 3, "4", 5, "6", 7,
					new ValueTuple()
				),
				7
			);
		}

		[Test]
		public void TestValueTuple8()
		{
			TestTupleCore(
				new ValueTuple<
					int, string, int, string, int, string, int,
				ValueTuple<string>>(
					1, "2", 3, "4", 5, "6", 7,
					new ValueTuple<string>( "8" )
				),
				8
			);
		}

		[Test]
		public void TestValueTuple14()
		{
			TestTupleCore(
				new ValueTuple<
					int, string, int, string, int, string, int,
					ValueTuple<
						string, int, string, int, string, int, string
					>
				>(
					1, "2", 3, "4", 5, "6", 7,
					new ValueTuple<string, int, string, int, string, int, string>(
						"8", 9, "10", 11, "12", 13, "14"
					)
				),
				14
			);
		}

		[Test]
		public void TestValueTuple14Plus0()
		{
			TestTupleCore(
				new ValueTuple<
					int, string, int, string, int, string, int,
					ValueTuple<
						string, int, string, int, string, int, string,
						ValueTuple
					>
				>(
					1, "2", 3, "4", 5, "6", 7,
					new ValueTuple<string, int, string, int, string, int, string, ValueTuple>(
						"8", 9, "10", 11, "12", 13, "14",
						new ValueTuple()
					)
				),
				14
			);
		}

		[Test]
		public void TestValueTuple15()
		{
			TestTupleCore(
				new ValueTuple<
					int, string, int, string, int, string, int,
					ValueTuple<
						string, int, string, int, string, int, string,
						ValueTuple<int>
					>
				>(
					1, "2", 3, "4", 5, "6", 7,
					new ValueTuple<string, int, string, int, string, int, string, ValueTuple<int>>(
						"8", 9, "10", 11, "12", 13, "14",
						new ValueTuple<int>( 15 )
					)
				),
				15
			);
		}

#endif // !SILVERLIGHT

		private void TestTupleCore<T>( T expected, int arity )
			where T : IStructuralEquatable
		{
			var serializer = this.CreateTarget<T>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, expected );
				stream.Position = 0;
				var mpo = MessagePackSerializer.UnpackMessagePackObject( stream );
				Assert.That( mpo.IsList, Is.True );
				Assert.That( mpo.AsList().Count, Is.EqualTo( arity ) );
				stream.Position = 0;
				Assert.That( serializer.Unpack( stream ), Is.EqualTo( expected ) );
			}
		}

#if FEATURE_TAP
		[Test]
		public async Task TestTuple1Async()
		{
			await TestTupleAsyncCore( new Tuple<int>( 1 ), 1 );
		}

		[Test]
		public async Task TestTuple7Async()
		{
			await TestTupleAsyncCore( new Tuple<int, string, int, string, int, string, int>( 1, "2", 3, "4", 5, "6", 7 ), 7 );
		}

		[Test]
		public async Task TestTuple8Async()
		{
			await TestTupleAsyncCore(
				new Tuple<
				int, string, int, string, int, string, int,
				Tuple<string>>(
					1, "2", 3, "4", 5, "6", 7,
					new Tuple<string>( "8" )
				),
				8
			);
		}

		[Test]
		public async Task TestTuple14Async()
		{
			await TestTupleAsyncCore(
				new Tuple<
				int, string, int, string, int, string, int,
				Tuple<
				string, int, string, int, string, int, string
				>
				>(
					1, "2", 3, "4", 5, "6", 7,
					new Tuple<string, int, string, int, string, int, string>(
						"8", 9, "10", 11, "12", 13, "14"
					)
				),
				14
			);
		}

		[Test]
		public async Task TestTuple15Async()
		{
			await TestTupleAsyncCore(
				new Tuple<
				int, string, int, string, int, string, int,
				Tuple<
				string, int, string, int, string, int, string,
				Tuple<int>
				>
				>(
					1, "2", 3, "4", 5, "6", 7,
					new Tuple<string, int, string, int, string, int, string, Tuple<int>>(
						"8", 9, "10", 11, "12", 13, "14",
						new Tuple<int>( 15 )
					)
				),
				15
			);
		}

		[Test]
		public async Task TestValueTuple0Async()
		{
			await TestTupleAsyncCore( new ValueTuple(), 0 );
		}

		[Test]
		public async Task TestValueTuple1Async()
		{
			await TestTupleAsyncCore( new ValueTuple<int>( 1 ), 1 );
		}

		[Test]
		public async Task TestValueTuple7Async()
		{
			await TestTupleAsyncCore( new ValueTuple<int, string, int, string, int, string, int>( 1, "2", 3, "4", 5, "6", 7 ), 7 );
		}

		[Test]
		public async Task TestValueTuple7Plus0Async()
		{
			await TestTupleAsyncCore(
				new ValueTuple<
					int, string, int, string, int, string, int,
				ValueTuple>(
					1, "2", 3, "4", 5, "6", 7,
					new ValueTuple()
				),
				7
			);
		}

		[Test]
		public async Task TestValueTuple8Async()
		{
			await TestTupleAsyncCore(
				new ValueTuple<
					int, string, int, string, int, string, int,
				ValueTuple<string>>(
					1, "2", 3, "4", 5, "6", 7,
					new ValueTuple<string>( "8" )
				),
				8
			);
		}

		[Test]
		public async Task TestValueTuple14Async()
		{
			await TestTupleAsyncCore(
				new ValueTuple<
					int, string, int, string, int, string, int,
					ValueTuple<
						string, int, string, int, string, int, string
					>
				>(
					1, "2", 3, "4", 5, "6", 7,
					new ValueTuple<string, int, string, int, string, int, string>(
						"8", 9, "10", 11, "12", 13, "14"
					)
				),
				14
			);
		}

		[Test]
		public async Task TestValueTuple14Plus0Async()
		{
			await TestTupleAsyncCore(
				new ValueTuple<
					int, string, int, string, int, string, int,
					ValueTuple<
						string, int, string, int, string, int, string,
						ValueTuple
					>
				>(
					1, "2", 3, "4", 5, "6", 7,
					new ValueTuple<string, int, string, int, string, int, string, ValueTuple>(
						"8", 9, "10", 11, "12", 13, "14",
						new ValueTuple()
					)
				),
				14
			);
		}

		[Test]
		public async Task TestValueTuple15Async()
		{
			await TestTupleAsyncCore(
				new ValueTuple<
					int, string, int, string, int, string, int,
					ValueTuple<
						string, int, string, int, string, int, string,
						ValueTuple<int>
					>
				>(
					1, "2", 3, "4", 5, "6", 7,
					new ValueTuple<string, int, string, int, string, int, string, ValueTuple<int>>(
						"8", 9, "10", 11, "12", 13, "14",
						new ValueTuple<int>( 15 )
					)
				),
				15
			);
		}

		private async Task TestTupleAsyncCore<T>( T expected, int arity )
			where T : IStructuralEquatable
		{
			var serializer = this.CreateTarget<T>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				await serializer.PackAsync( stream, expected );
				stream.Position = 0;
				var mpo = MessagePackSerializer.UnpackMessagePackObject( stream );
				Assert.That( mpo.IsList, Is.True );
				Assert.That( mpo.AsList().Count, Is.EqualTo( arity ) );
				stream.Position = 0;
				Assert.That( await serializer.UnpackAsync( stream ), Is.EqualTo( expected ) );
			}
		}
#endif // FEATURE_TAP
#endif // !NET35
<#+
	}
#>

		[Test]
		public void TestEmptyBytes()
		{
			var context = NewSerializationContext( SerializationCompatibilityLevel.Latest );
			var serializer = this.CreateTarget<byte[]>( context );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new byte[ 0 ] );
				Assert.That( stream.Length, Is.EqualTo( 2 ), BitConverter.ToString( stream.ToArray() ) );
				stream.Position = 0;
				Assert.That( serializer.Unpack( stream ), Is.EqualTo( new byte[ 0 ] ) );
			}
		}

		[Test]
		public void TestEmptyBytes_Classic0_5()
		{
			var context = NewSerializationContext( SerializationCompatibilityLevel.Version0_5 );
			var serializer = this.CreateTarget<byte[]>( context );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new byte[ 0 ] );
				Assert.That( stream.Length, Is.EqualTo( 1 ), BitConverter.ToString( stream.ToArray() ) );
				stream.Position = 0;
				Assert.That( serializer.Unpack( stream ), Is.EqualTo( new byte[ 0 ] ) );
			}
		}

		[Test]
		public void TestEmptyBytes_Classic0_9()
		{
			var context = NewSerializationContext( SerializationCompatibilityLevel.Version0_9 );
			var serializer = this.CreateTarget<byte[]>( context );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new byte[ 0 ] );
				Assert.That( stream.Length, Is.EqualTo( 2 ), BitConverter.ToString( stream.ToArray() ) );
				stream.Position = 0;
				Assert.That( serializer.Unpack( stream ), Is.EqualTo( new byte[ 0 ] ) );
			}
		}

		[Test]
		public void TestEmptyString()
		{
			var serializer = this.CreateTarget<string>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, String.Empty );
				Assert.That( stream.Length, Is.EqualTo( 1 ) );
				stream.Position = 0;
				Assert.That( serializer.Unpack( stream ), Is.EqualTo( String.Empty ) );
			}
		}

		[Test]
		public void TestEmptyIntArray()
		{
			var serializer = this.CreateTarget<int[]>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new int[ 0 ] );
				Assert.That( stream.Length, Is.EqualTo( 1 ) );
				stream.Position = 0;
				Assert.That( serializer.Unpack( stream ), Is.EqualTo( new int[ 0 ] ) );
			}
		}

		[Test]
		public void TestEmptyKeyValuePairArray()
		{
			var serializer = this.CreateTarget<KeyValuePair<string, int>[]>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new KeyValuePair<string, int>[ 0 ] );
				Assert.That( stream.Length, Is.EqualTo( 1 ) );
				stream.Position = 0;
				Assert.That( serializer.Unpack( stream ), Is.EqualTo( new KeyValuePair<string, int>[ 0 ] ) );
			}
		}

		[Test]
		public void TestEmptyMap()
		{
			var serializer = this.CreateTarget<Dictionary<string, int>>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new Dictionary<string, int>() );
				Assert.That( stream.Length, Is.EqualTo( 1 ) );
				stream.Position = 0;
				Assert.That( serializer.Unpack( stream ), Is.EqualTo( new Dictionary<string, int>() ) );
			}
		}

		[Test]
		public void TestNullable()
		{
			var serializer = this.CreateTarget<int?>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, 1 );
				Assert.That( stream.Length, Is.EqualTo( 1 ) );
				stream.Position = 0;
				Assert.That( serializer.Unpack( stream ), Is.EqualTo( 1 ) );

				stream.Position = 0;
				serializer.Pack( stream, null );
				Assert.That( stream.Length, Is.EqualTo( 1 ) );
				stream.Position = 0;
				Assert.That( serializer.Unpack( stream ), Is.EqualTo( null ) );
			}
		}

#if FEATURE_TAP
		[Test]
		public async Task TestNullableAsync()
		{
			var serializer = this.CreateTarget<int?>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				await serializer.PackAsync( stream, 1 );
				Assert.That( stream.Length, Is.EqualTo( 1 ) );
				stream.Position = 0;
				Assert.That( await serializer.UnpackAsync( stream ), Is.EqualTo( 1 ) );

				stream.Position = 0;
				await serializer.PackAsync( stream, null );
				Assert.That( stream.Length, Is.EqualTo( 1 ) );
				stream.Position = 0;
				Assert.That( await serializer.UnpackAsync( stream ), Is.EqualTo( null ) );
			}
		}
#endif // FEATURE_TAP

		[Test]
		public void TestValueType_Success()
		{
			var serializer = this.CreateTarget<TestValueType>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = 
					new TestValueType()
					{ 
						StringField = "ABC", 
						Int32ArrayField = new int[] { 1, 2, 3 }, 
						DictionaryField = 
#if !UNITY
							new Dictionary<int, int>() 
#else
							new Dictionary<int, int>( AotHelper.GetEqualityComparer<int>() ) 
#endif // !UNITY
							{ { 1, 1 } } 
					};
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.StringField, Is.EqualTo( value.StringField ) );
				Assert.That( result.Int32ArrayField, Is.EqualTo( value.Int32ArrayField ) );
				Assert.That( result.DictionaryField, Is.EqualTo( value.DictionaryField ) );
			}
		}

#if FEATURE_TAP
		[Test]
		public async Task TestValueTypeAsync_Success()
		{
			var serializer = this.CreateTarget<TestValueType>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = 
					new TestValueType()
					{ 
						StringField = "ABC", 
						Int32ArrayField = new int[] { 1, 2, 3 }, 
						DictionaryField = 
#if !UNITY
							new Dictionary<int, int>() 
#else
							new Dictionary<int, int>( AotHelper.GetEqualityComparer<int>() ) 
#endif // !UNITY
							{ { 1, 1 } } 
					};
				await serializer.PackAsync( stream, value );
				stream.Position = 0;
				var result = await serializer.UnpackAsync( stream );
				Assert.That( result.StringField, Is.EqualTo( value.StringField ) );
				Assert.That( result.Int32ArrayField, Is.EqualTo( value.Int32ArrayField ) );
				Assert.That( result.DictionaryField, Is.EqualTo( value.DictionaryField ) );
			}
		}
#endif // FEATURE_TAP

		// Issue81
		[Test]
		public void TestMultiDimensionalArray()
		{
			var array = new int [ 2, 2 ];
			array[ 0, 0 ] = 0;
			array[ 0, 1 ] = 1;
			array[ 1, 0 ] = 10;
			array[ 1, 1 ] = 11;

			var serializer = this.CreateTarget<int[,]>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, array );
				stream.Position = 0;

				var result = serializer.Unpack( stream );
				Assert.That( result, Is.TypeOf<int[,]>() );
				Assert.That( result.Rank, Is.EqualTo( 2 ) );
				Assert.That( result.Length, Is.EqualTo( 4 ) );
				Assert.That( result.GetLength( 0 ), Is.EqualTo( 2 ) );
				Assert.That( result.GetLength( 1 ), Is.EqualTo( 2 ) );
				Assert.That( result[ 0, 0 ], Is.EqualTo( 0 ) );
				Assert.That( result[ 0, 1 ], Is.EqualTo( 1 ) );
				Assert.That( result[ 1, 0 ], Is.EqualTo( 10 ) );
				Assert.That( result[ 1, 1 ], Is.EqualTo( 11 ) );
			}
		}

#if FEATURE_TAP
		// Issue81
		[Test]
		public async Task TestMultiDimensionalArrayAsync()
		{
			var array = new int [ 2, 2 ];
			array[ 0, 0 ] = 0;
			array[ 0, 1 ] = 1;
			array[ 1, 0 ] = 10;
			array[ 1, 1 ] = 11;

			var serializer = this.CreateTarget<int[,]>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				await serializer.PackAsync( stream, array );
				stream.Position = 0;

				var result = await serializer.UnpackAsync( stream );
				Assert.That( result, Is.TypeOf<int[,]>() );
				Assert.That( result.Rank, Is.EqualTo( 2 ) );
				Assert.That( result.Length, Is.EqualTo( 4 ) );
				Assert.That( result.GetLength( 0 ), Is.EqualTo( 2 ) );
				Assert.That( result.GetLength( 1 ), Is.EqualTo( 2 ) );
				Assert.That( result[ 0, 0 ], Is.EqualTo( 0 ) );
				Assert.That( result[ 0, 1 ], Is.EqualTo( 1 ) );
				Assert.That( result[ 1, 0 ], Is.EqualTo( 10 ) );
				Assert.That( result[ 1, 1 ], Is.EqualTo( 11 ) );
			}
		}
#endif // FEATURE_TAP

		[Test]
		public void TestMultiDimensionalArrayComprex()
		{
			var array = new int [ 2, 3, 4 ];
			array[ 0, 0, 0 ] = 0;
			array[ 0, 0, 1 ] = 1;
			array[ 0, 0, 2 ] = 2;
			array[ 0, 0, 3 ] = 3;
			array[ 0, 1, 0 ] = 10;
			array[ 0, 1, 1 ] = 11;
			array[ 0, 1, 2 ] = 12;
			array[ 0, 1, 3 ] = 13;
			array[ 0, 2, 0 ] = 20;
			array[ 0, 2, 1 ] = 21;
			array[ 0, 2, 2 ] = 22;
			array[ 0, 2, 3 ] = 23;
			array[ 1, 0, 0 ] = 100;
			array[ 1, 0, 1 ] = 101;
			array[ 1, 0, 2 ] = 102;
			array[ 1, 0, 3 ] = 103;
			array[ 1, 1, 0 ] = 110;
			array[ 1, 1, 1 ] = 111;
			array[ 1, 1, 2 ] = 112;
			array[ 1, 1, 3 ] = 113;
			array[ 1, 2, 0 ] = 120;
			array[ 1, 2, 1 ] = 121;
			array[ 1, 2, 2 ] = 122;
			array[ 1, 2, 3 ] = 123;

			var serializer = this.CreateTarget<int[,,]>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, array );
				stream.Position = 0;

				var result = serializer.Unpack( stream );
				Assert.That( result, Is.TypeOf<int[,,]>() );
				Assert.That( result.Rank, Is.EqualTo( 3 ) );
				Assert.That( result.Length, Is.EqualTo( 24 ) );
				Assert.That( result.GetLength( 0 ), Is.EqualTo( 2 ) );
				Assert.That( result.GetLength( 1 ), Is.EqualTo( 3 ) );
				Assert.That( result.GetLength( 2 ), Is.EqualTo( 4 ) );
				Assert.That( result[ 0, 0, 0 ], Is.EqualTo( 0 ) );
				Assert.That( result[ 0, 0, 1 ], Is.EqualTo( 1 ) );
				Assert.That( result[ 0, 0, 2 ], Is.EqualTo( 2 ) );
				Assert.That( result[ 0, 0, 3 ], Is.EqualTo( 3 ) );
				Assert.That( result[ 0, 1, 0 ], Is.EqualTo( 10 ) );
				Assert.That( result[ 0, 1, 1 ], Is.EqualTo( 11 ) );
				Assert.That( result[ 0, 1, 2 ], Is.EqualTo( 12 ) );
				Assert.That( result[ 0, 1, 3 ], Is.EqualTo( 13 ) );
				Assert.That( result[ 0, 2, 0 ], Is.EqualTo( 20 ) );
				Assert.That( result[ 0, 2, 1 ], Is.EqualTo( 21 ) );
				Assert.That( result[ 0, 2, 2 ], Is.EqualTo( 22 ) );
				Assert.That( result[ 0, 2, 3 ], Is.EqualTo( 23 ) );
				Assert.That( result[ 1, 0, 0 ], Is.EqualTo( 100 ) );
				Assert.That( result[ 1, 0, 1 ], Is.EqualTo( 101 ) );
				Assert.That( result[ 1, 0, 2 ], Is.EqualTo( 102 ) );
				Assert.That( result[ 1, 0, 3 ], Is.EqualTo( 103 ) );
				Assert.That( result[ 1, 1, 0 ], Is.EqualTo( 110 ) );
				Assert.That( result[ 1, 1, 1 ], Is.EqualTo( 111 ) );
				Assert.That( result[ 1, 1, 2 ], Is.EqualTo( 112 ) );
				Assert.That( result[ 1, 1, 3 ], Is.EqualTo( 113 ) );
				Assert.That( result[ 1, 2, 0 ], Is.EqualTo( 120 ) );
				Assert.That( result[ 1, 2, 1 ], Is.EqualTo( 121 ) );
				Assert.That( result[ 1, 2, 2 ], Is.EqualTo( 122 ) );
				Assert.That( result[ 1, 2, 3 ], Is.EqualTo( 123 ) );
			}
		}

#if !SILVERLIGHT

		[Test]
#if UNITY_WORKAROUND
		[Ignore( "Unity's Array.SetValue is buggy for non-SZArray" )]
#endif // UNITY_WORKAROUND
		public void TestNonZeroBoundArray()
		{
			var array = Array.CreateInstance( typeof( int ), new [] { 2 }, new [] { 1 } );
			array.SetValue( 1, 1 );
			array.SetValue( 2, 2 );

			var serializer = GetSerializationContext().GetSerializer( array.GetType() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, array );
				stream.Position = 0;

				var result = ( Array )serializer.Unpack( stream );
#if !SILVERLIGHT 
				Assert.That( result, Is.TypeOf( array.GetType() ) );
#else
				// Silverlight does not support lower bound settings, so sz array will return.
				Assert.That( result, Is.TypeOf<int[]>() );
#endif // !SILVERLIGHT
				Assert.That( result.Rank, Is.EqualTo( 1 ) );
#if !SILVERLIGHT 
				Assert.That( result.Length, Is.EqualTo( 2 ) );
				Assert.That( result.GetLowerBound( 0 ), Is.EqualTo( 1 ) );
#else
				// Silverlight does not support lower bound settings, so lowerBound + length will  be set.
				Assert.That( result.Length, Is.EqualTo( 3 ) );
				Assert.That( result.GetLowerBound( 0 ), Is.EqualTo( 0 ) );
#endif // !SILVERLIGHT
				Assert.That( result.GetValue( 1 ), Is.EqualTo( 1 ) );
				Assert.That( result.GetValue( 2 ), Is.EqualTo( 2 ) );
			}
		}

		[Test]
		public void TestNonZeroBoundMultidimensionalArray()
		{
			var array = Array.CreateInstance( typeof( int ), new [] { 2, 2 }, new [] { 1, 1 } );
			array.SetValue( 11, new [] { 1, 1 } );
			array.SetValue( 12, new [] { 1, 2 } );
			array.SetValue( 21, new [] { 2, 1 } );
			array.SetValue( 22, new [] { 2, 2 } );

			var serializer = GetSerializationContext().GetSerializer( array.GetType() );
			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, array );
				stream.Position = 0;

				var result = ( Array )serializer.Unpack( stream );
				Assert.That( result, Is.TypeOf( array.GetType() ) );
				Assert.That( result.Rank, Is.EqualTo( 2 ) );
#if !SILVERLIGHT 
				Assert.That( result.Length, Is.EqualTo( 4 ) );
				Assert.That( result.GetLowerBound( 0 ), Is.EqualTo( 1 ) );
				Assert.That( result.GetLowerBound( 1 ), Is.EqualTo( 1 ) );
#else
				// Silverlight does not support lower bound settings, so lowerBound + length will  be set.
				Assert.That( result.Length, Is.EqualTo( 9 ) );
				Assert.That( result.GetLowerBound( 0 ), Is.EqualTo( 0 ) );
				Assert.That( result.GetLowerBound( 1 ), Is.EqualTo( 0 ) );
#endif // !SILVERLIGHT
				Assert.That( result.GetValue( 1, 1 ), Is.EqualTo( 11 ) );
				Assert.That( result.GetValue( 1, 2 ), Is.EqualTo( 12 ) );
				Assert.That( result.GetValue( 2, 1 ), Is.EqualTo( 21 ) );
				Assert.That( result.GetValue( 2, 2 ), Is.EqualTo( 22 ) );
			}
		}

#endif // !SILVERLIGHT

<#+
	if ( !forIos )
	{
		// Not needed because generation itself has been done.

		const string testValue = "\"123\"";
		foreach ( var type in
			new []
			{
				new { IsCollection = false,	TestValue = testValue,									DefaultValue = "\"ABC\"" },
				new { IsCollection = true,	TestValue = "new List<string>{ " + testValue + " }",	DefaultValue = "new List<string>()" }, // test value should be appended to default empty collection.
			}
		)
		{
			foreach ( var spec in
				new []
				{
					new { Prefix = "InitOnly",		Suffix = "Field",		Constructor = "Default",	IsPrivilegeRequired = !type.IsCollection,		Exception = ( !type.IsCollection ? "SerializationException" : null ) }, // cannot be deserialized
					new { Prefix = "InitOnly",		Suffix = "Field",		Constructor = "Record",		IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "InitOnly",		Suffix = "Field",		Constructor = "Both",		IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "InitOnly",		Suffix = "Field",		Constructor = "Annotated",	IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "ReadWrite",		Suffix = "Field",		Constructor = "Default",	IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "ReadWrite",		Suffix = "Field",		Constructor = "Record",		IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "ReadWrite",		Suffix = "Field",		Constructor = "Both",		IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "ReadWrite",		Suffix = "Field",		Constructor = "Annotated",	IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "GetOnly",		Suffix = "Property",	Constructor = "Default",	IsPrivilegeRequired = !type.IsCollection,		Exception = ( !type.IsCollection ? "SerializationException" : null ) }, // cannot be deserialized
					new { Prefix = "GetOnly",		Suffix = "Property",	Constructor = "Record",		IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "GetOnly",		Suffix = "Property",	Constructor = "Both",		IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "GetOnly",		Suffix = "Property",	Constructor = "Annotated",	IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "PrivateSetter",	Suffix = "Property",	Constructor = "Default",	IsPrivilegeRequired = !type.IsCollection,		Exception = default( string ) }, // via reflection
					new { Prefix = "PrivateSetter",	Suffix = "Property",	Constructor = "Record",		IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "PrivateSetter",	Suffix = "Property",	Constructor = "Both",		IsPrivilegeRequired = false,					Exception = default( string ) }, // via reflection
					new { Prefix = "PrivateSetter",	Suffix = "Property",	Constructor = "Annotated",	IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "PublicSetter",	Suffix = "Property",	Constructor = "Default",	IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "PublicSetter",	Suffix = "Property",	Constructor = "Record",		IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "PublicSetter",	Suffix = "Property",	Constructor = "Both",		IsPrivilegeRequired = false,					Exception = default( string ) },
					new { Prefix = "PublicSetter",	Suffix = "Property",	Constructor = "Annotated",	IsPrivilegeRequired = false,					Exception = default( string ) },
			}
			)
			{
				var typeName = "Has" + spec.Prefix + ( type.IsCollection ? "AppendableCollection" : String.Empty ) + spec.Suffix + "With" + spec.Constructor + "Constructor";
#>

		[Test]
		public void Test<#= typeName #>_<#= spec.Exception == null ? "Success" : "Fail" #>()
		{
<#+
				if ( spec.Exception != null )
				{
#>
			Assert.Throws<<#= spec.Exception #>>( () => this.CreateTarget<<#= typeName #>>( GetSerializationContext() ) );
<#+
				}
				else
				{
					if ( spec.IsPrivilegeRequired )
					{
#>
#if !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
<#+
					}
#>
			var serializer = this.CreateTarget<<#= typeName #>>( GetSerializationContext() );

			using ( var stream = new MemoryStream() )
			{
<#+
					switch ( spec.Constructor )
					{
						case "Default":
						{
#>
				var value = new <#= typeName #>();
				value.InitializeMember( <#= type.TestValue #> );
<#+
							break;
						}
						case "Record":
						case "Both":
						{
#>
				var value = new <#= typeName #>( <#= type.TestValue #> );
<#+
							break;
						}
						case "Annotated":
						{
#>
				var value = new <#= typeName #>( -1 /* dummy */ );
<#+
							break;
						}
					} // switch ( spec.Constructor )
#>
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
<#+
					switch ( spec.Constructor )
					{
						case "Annotated":
						{
#>
				// dummy annotated constructor does not take the value, so the deserialized value should be "default" of the type.
				Assert.That( result.Member, Is.EqualTo( <#= type.DefaultValue #> ) );
<#+
							break;
						}
						default:
						{
#>
				// check the member value deserialized properly.
				Assert.That( result.Member, Is.EqualTo( <#= type.TestValue #> ) );
<#+
							break;
						}
					} // switch( spec.Constructor )

					switch ( spec.Constructor )
					{
						case "Both":
						{
							if ( spec.Prefix != "PrivateSetter" || type.IsCollection )
							{
								goto case "Annotated";
							}
#>
#if !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
				Assert.That( result.WasProperConstructorUsed() );
#else
				// Parameterized should be called because private setters are completely ignored in non-priviledged mode.
				Assert.That( result.WasProperConstructorUsed(), Is.False );
#endif // !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
<#+
							break;
						}
						case "Annotated":
						{
#>
				Assert.That( result.WasProperConstructorUsed() );
<#+
							break;
						}
					} // switch ( spec.Constructor )
#>
			}
<#+
					if ( spec.IsPrivilegeRequired )
					{
#>
#else
			Assert.Throws<SerializationException>( () => this.CreateTarget<<#= typeName #>>( GetSerializationContext() ) );
#endif // !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
<#+
					}
				} // if ( Exception != null )
#>
		}
<#+
				if ( spec.Exception == null )
				{
#>

		[Test]
		public void Test<#= typeName #>_DeserializeWithMissingMember_Success()
		{
<#+
					if ( spec.IsPrivilegeRequired )
					{
#>
#if !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
<#+
					}
#>
			var serializer = this.CreateTarget<<#= typeName #>>( GetSerializationContext() );

			using ( var stream = new MemoryStream() )
			{
<#+
					if ( serializationMethod == "Array" )
					{
#>
				stream.Write( new byte[]{ 0x90 } );
<#+
					}
					else
					{
#>
				stream.Write( new byte[]{ 0x80 } );
<#+
					} // if ( serializationMethod == "Array" )
#>
				stream.Position = 0;
				var result = serializer.Unpack( stream );
<#+
					if ( type.IsCollection )
					{
						switch ( spec.Constructor )
						{
							case "Default":
							case "Both":
							case "Annotated":
							{
#>
				// Default constructor was called and nothing to be set.
				Assert.That( result.Member, Is.EqualTo( <#= type.DefaultValue #> ) );
<#+
								break;
							}
							case "Record":
							{
#>
				// Set null via deserialization constructor.
				Assert.That( result.Member, Is.Null );
<#+
								break;
							}
						}
					}
					else
					{
						switch ( spec.Constructor )
						{
							case "Default":
							case "Annotated":
							{
#>
				// Default constructor was called and was nothing to be set.
				Assert.That( result.Member, Is.EqualTo( <#= type.DefaultValue #> ) );
<#+
								break;
							}
							case "Record":
							{
#>
				// Set null via deserialization constructor.
				Assert.That( result.Member, Is.Null );
<#+
								break;
							}
							case "Both":
							{
								switch ( spec.Prefix )
								{
									case "PrivateSetter":
									{
										if ( type.IsCollection )
										{
											goto case "PublicSetter";
										}
#>
#if !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
				// Default constructor was called and was nothing to be set.
				Assert.That( result.Member, Is.EqualTo( <#= type.DefaultValue #> ) );
#else
				// Set null via deserialization constructor.
				Assert.That( result.Member, Is.Null );
#endif // !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
<#+
										break;
									}
									case "PublicSetter":
									case "ReadWrite":
									{
#>
				// Default constructor was called and was nothing to be set.
				Assert.That( result.Member, Is.EqualTo( <#= type.DefaultValue #> ) );
<#+
										break;
									}
									default:
									{
#>
				// Set null via deserialization constructor.
				Assert.That( result.Member, Is.Null );
<#+
										break;
									}
								}

								break;
							}
						}
					}
#>
			}
<#+
					if ( spec.IsPrivilegeRequired )
					{
#>
#else
			Assert.Throws<SerializationException>( () => this.CreateTarget<<#= typeName #>>( GetSerializationContext() ) );
#endif // !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
<#+
					}
#>
		}

		[Test]
		public void Test<#= typeName #>_DeseriaizeWithExtraMember_Success()
		{
<#+
					if ( spec.IsPrivilegeRequired )
					{
#>
#if !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
<#+
					}
#>
			var serializer = this.CreateTarget<<#= typeName #>>( GetSerializationContext() );

			using ( var stream = new MemoryStream() )
			{
				using ( var packer = Packer.Create( stream, false ) )
				{
<#+
					if ( serializationMethod == "Array" )
					{
#>
					packer.PackArrayHeader( 2 );
<#+
					}
					else
					{
#>
					packer.PackMapHeader( 2 );
					packer.PackString( "Member" );
<#+
					}

					if ( type.IsCollection )
					{
#>
					packer.PackArrayHeader( 1 );
<#+
					}
#>
					packer.PackString( <#= testValue #> );
<#+
					if ( serializationMethod == "Map" )
					{
#>
					packer.PackString( "Extra" );
<#+
					}
#>
					packer.PackNull();
				}

				stream.Position = 0;
				var result = serializer.Unpack( stream );
<#+
					if ( spec.Constructor == "Annotated" )
					{
#>
				// dummy annotated constructor does not take the value, so the deserialized value should be "default" of the type.
				Assert.That( result.Member, Is.EqualTo( <#= type.DefaultValue #> ) );
<#+
					}
					else
					{
#>
				// check the member value deserialized properly.
				Assert.That( result.Member, Is.EqualTo( <#= type.TestValue #> ) );
<#+
					} // if spec.Constructor == "Annotated"
#>
			}
<#+
					if ( spec.IsPrivilegeRequired )
					{
#>
#else
			Assert.Throws<SerializationException>( () => this.CreateTarget<<#= typeName #>>( GetSerializationContext() ) );
#endif // !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
<#+
					}
#>
		}
<#+
				} // if spec.Exception == null
			} // foreach spec
		} // foreach prefix
#>

		[Test]
		public void TestConstrutorDeserializationWithAnotherNameConstrtor_DifferIsSetDefault()
		{
			var serializer = this.CreateTarget<WithAnotherNameConstructor>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new WithAnotherNameConstructor( 1, 2 );
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.ReadOnlySame, Is.EqualTo( 1 ) );
				Assert.That( result.ReadOnlyDiffer, Is.EqualTo( 0 ) );
			}
		}

		[Test]
		public void TestConstrutorDeserializationWithAnotherTypeConstrtor_DifferIsSetDefault()
		{
			var serializer = this.CreateTarget<WithAnotherTypeConstructor>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new WithAnotherTypeConstructor( 1, 2 );
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.ReadOnlySame, Is.EqualTo( 1 ) );
				Assert.That( result.ReadOnlyDiffer, Is.EqualTo( "0" ) );
			}
		}

		[Test]
		public void TestConstrutorDeserializationWithAttribute_Preferred()
		{
			var serializer = this.CreateTarget<WithConstructorAttribute>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new WithConstructorAttribute( 1, false );
				Assert.That( value.IsAttributePreferred, Is.False );
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.Value, Is.EqualTo( 1 ) );
				Assert.That( result.IsAttributePreferred, Is.True );
			}
		}

		[Test]
		public void TestConstrutorDeserializationWithMultipleAttributes_Fail()
		{
			Assert.Throws<SerializationException>( () => this.CreateTarget<WithMultipleConstructorAttributes>( GetSerializationContext() ) );
		}

<#+
		foreach( var item in constructorParamterSpecs )
		{
#>

		[Test]
		public void TestOptionalConstructor<#= item.Key #>_Success()
		{
			var serializer = this.<#= "CreateTarget<WithOptionalConstructorParameter" + item.Key + ">" #>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				stream.Write( new byte[]{ <#= serializationMethod == "Array" ? "0x90" : "0x80" #> }, 0, 1 );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.Value, Is.EqualTo( <#= item.Value #> ) );
			}
		}
<#+
		}
	}
#>

		// Issue233
		[Test]
		public void TestConstructorDeserializationWithParametersNotInLexicalOrder()
		{
			var endpoints =
				new EndpointList(
					"Test String One",
					new Dictionary<string, string[]>
					{
						{ "ConfigService", new [] { "ur1", "ur2" } },
						{ "TestService", new [] { "ur1", "ur2" } }
					},
					"Test String Two"
				);

			var context = new SerializationContext();
			var ser = context.GetSerializer<EndpointList>();
			var bytes = ser.PackSingleObject( endpoints );
			var endpointsDeser = ser.UnpackSingleObject( bytes );

			Assert.That( endpointsDeser.StringOne, Is.EqualTo( endpoints.StringOne ) );
			Assert.That( endpointsDeser.StringTwo, Is.EqualTo( endpoints.StringTwo ) );
			Assert.That( endpointsDeser.Endpoints, Is.EqualTo( endpoints.Endpoints ) );
		}

		[Test]
		public void TestCollection_Success()
		{
			var serializer = this.CreateTarget<Collection<int>>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new Collection<int>() { 1, 2, 3 };
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.ToArray(), Is.EqualTo( new int[] { 1, 2, 3 } ) );
			}
		}

		[Test]
		public void TestIListValueType_Success()
		{
			var serializer = this.CreateTarget<ListValueType<int>>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new ListValueType<int>( 3 ) { 1, 2, 3 };
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.ToArray(), Is.EqualTo( new int[] { 1, 2, 3 } ) );
			}
		}

		[Test]
		public void TestIDictionaryValueType_Success()
		{
			var serializer = this.CreateTarget<DictionaryValueType<int, int>>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new DictionaryValueType<int, int>( 3 ) { { 1, 1 }, { 2, 2 }, { 3, 3 } };
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.ToArray(), Is.EquivalentTo( Enumerable.Range( 1, 3 ).Select( i => new KeyValuePair<int, int>( i, i ) ).ToArray() ) );
			}
		}

<#+
	if ( !forIos )
	{
		var header = serializationMethod == "Array" ? "0x91" : ( "0x81, 0xAA, " + String.Join( ", ", "Int32Field".Select( c => ( ushort )c ).Select( x => "0x" + x.ToString( "X2" ) ) ) );
		// Not needed because generation itself has been done.
#>
		[Test]
		public void TestPackable_PackToMessageUsed()
		{
			var serializer = this.CreateTarget<JustPackable>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new JustPackable();
				value.Int32Field = 1;
				serializer.Pack( stream, value );
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { 0x91, 0xA1, ( byte )'1' } ) );
				stream.Position = 0;
				Assert.Throws<SerializationException>( () => serializer.Unpack( stream ), "Round-trip should not be succeeded." );

#if FEATURE_TAP
				stream.SetLength( 0 );
				serializer.PackAsync( stream, value, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { <#= header #>, 0x1 } ) );
				stream.Position = 0;
				var result = serializer.UnpackAsync( stream, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( result.Int32Field, Is.EqualTo( value.Int32Field ) );
#endif // FEATURE_TAP
			}
		}

		[Test]
		public void TestUnpackable_UnpackFromMessageUsed()
		{
			var serializer = this.CreateTarget<JustUnpackable>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new JustUnpackable();
				value.Int32Field = 1;
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.Int32Field.ToString(), Is.EqualTo( JustUnpackable.Dummy ) );

#if FEATURE_TAP
				stream.SetLength( 0 );
				serializer.PackAsync( stream, value, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { <#= header #>, 0x1 } ) );
				stream.Position = 0;
				result = serializer.UnpackAsync( stream, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( result.Int32Field, Is.EqualTo( value.Int32Field ) );
#endif // FEATURE_TAP
			}
		}
		
#if FEATURE_TAP

		[Test]
		public void TestAsyncPackable_PackToMessageUsed()
		{
			var serializer = this.CreateTarget<JustAsyncPackable>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new JustAsyncPackable();
				value.Int32Field = 1;
				serializer.Pack( stream, value );
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { <#= header #>, 0x1 } ) );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.Int32Field, Is.EqualTo( value.Int32Field ) );

				stream.SetLength( 0 );
				serializer.PackAsync( stream, value, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { 0x91, 0xA1, ( byte )'1' } ) );
				stream.Position = 0;
				Assert.Throws<SerializationException>( () => serializer.UnpackAsync( stream, CancellationToken.None ).GetAwaiter().GetResult(), "Round-trip should not be succeeded." );
			}
		}

		[Test]
		public void TestAsyncUnpackable_UnpackFromMessageUsed()
		{
			var serializer = this.CreateTarget<JustAsyncUnpackable>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new JustAsyncUnpackable();
				value.Int32Field = 1;
				serializer.Pack( stream, value );
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { <#= header #>, 0x1 } ) );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.Int32Field, Is.EqualTo( value.Int32Field ) );

				stream.SetLength( 0 );
				serializer.PackAsync( stream, value, CancellationToken.None ).GetAwaiter().GetResult();
				stream.Position = 0;
				result = serializer.UnpackAsync( stream, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( result.Int32Field.ToString(), Is.EqualTo( JustAsyncUnpackable.Dummy ) );
			}
		}

#endif // FEATURE_TAP

		[Test]
		public void TestPackableUnpackable_PackToMessageAndUnpackFromMessageUsed()
		{
			var serializer = this.CreateTarget<PackableUnpackable>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new PackableUnpackable();
				value.Int32Field = 1;
				serializer.Pack( stream, value );
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { 0x91, 0xA1, ( byte )'1' } ) );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.Int32Field.ToString(), Is.EqualTo( PackableUnpackable.Dummy ) );

#if FEATURE_TAP
				stream.SetLength( 0 );
				serializer.PackAsync( stream, value, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { <#= header #>, 0x1 } ) );
				stream.Position = 0;
				result = serializer.UnpackAsync( stream, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( result.Int32Field, Is.EqualTo( value.Int32Field ) );
#endif // FEATURE_TAP
			}
		}

#if FEATURE_TAP

		[Test]
		public void TestAsyncPackableUnpackable_PackToMessageAndUnpackFromMessageUsed()
		{
			var serializer = this.CreateTarget<AsyncPackableUnpackable>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new AsyncPackableUnpackable();
				value.Int32Field = 1;
				serializer.Pack( stream, value );
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { <#= header #>, 0x1 } ) );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.Int32Field, Is.EqualTo( value.Int32Field ) );

				stream.SetLength( 0 );
				serializer.PackAsync( stream, value, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { 0x91, 0xA1, ( byte )'1' } ) );
				stream.Position = 0;
				result = serializer.UnpackAsync( stream, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( result.Int32Field.ToString(), Is.EqualTo( AsyncPackableUnpackable.Dummy ) );
			}
		}

		[Test]
		public void TestFullPackableUnpackable_PackToMessageAndUnpackFromMessageUsed()
		{
			var serializer = this.CreateTarget<FullPackableUnpackable>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new FullPackableUnpackable();
				value.Int32Field = 1;
				serializer.Pack( stream, value );
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { 0x91, 0xA1, ( byte )'1' } ) );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.Int32Field.ToString(), Is.EqualTo( FullPackableUnpackable.Dummy ) );

				stream.SetLength( 0 );
				serializer.PackAsync( stream, value, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { 0x91, 0xA1, ( byte )'1' } ) );
				stream.Position = 0;
				result = serializer.UnpackAsync( stream, CancellationToken.None ).GetAwaiter().GetResult();
				Assert.That( result.Int32Field.ToString(), Is.EqualTo( FullPackableUnpackable.Dummy ) );
			}
		}

#endif // FEATURE_TAP

		[Test]
		public void TestBinary_ClassicContext0_5()
		{
			var context = NewSerializationContext( SerializationCompatibilityLevel.Version0_5 );
			var serializer = CreateTarget<byte[]>( context );

			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new byte[] { 1 } );
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { MessagePackCode.MinimumFixedRaw + 1, 1 } ) );
			}
		}

		[Test]
		public void TestBinary_ClassicContext0_9()
		{
			var context = NewSerializationContext( SerializationCompatibilityLevel.Version0_9 );
			var serializer = CreateTarget<byte[]>( context );

			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new byte[] { 1 } );
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { MessagePackCode.Bin8, 1, 1 } ) );;
			}
		}

		[Test]
		public void TestBinary_DefaultContext()
		{
			var context = NewSerializationContext( SerializationCompatibilityLevel.Latest );
			var serializer = CreateTarget<byte[]>( context );

			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new byte[] { 1 } );
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { MessagePackCode.Bin8, 1, 1 } ) );
			}
		}

		[Test]
		public void TestBinary_ContextWithPackerCompatilibyOptionsNone()
		{
			var context = NewSerializationContext( SerializationCompatibilityLevel.Version0_5 );
			context.CompatibilityOptions.PackerCompatibilityOptions = PackerCompatibilityOptions.None;
			var serializer = CreateTarget<byte[]>( context );

			using ( var stream = new MemoryStream() )
			{
				serializer.Pack( stream, new byte[] { 1 } );
				Assert.That( stream.ToArray(), Is.EqualTo( new byte[] { MessagePackCode.Bin8, 1, 1 } ) );
			}
		}
<#+
	}
#>
		[Test]
		public void TestExt_ClassicContext0_5()
		{
			var context = NewSerializationContext( SerializationCompatibilityLevel.Version0_5 );
			context.Serializers.RegisterOverride( new CustomDateTimeSerealizer() );
			var serializer = CreateTarget<DateTime>( context );

			using ( var stream = new MemoryStream() )
			{
				var date = DateTime.UtcNow;
				serializer.Pack( stream, date );
				stream.Position = 0;
				var unpacked = serializer.Unpack( stream );
				Assert.That( unpacked.ToString( "yyyyMMddHHmmssfff" ), Is.EqualTo( date.ToString( "yyyyMMddHHmmssfff" ) ) );
			}
		}

		[Test]
		public void TestExt_ClassicContext0_9()
		{
			var context = NewSerializationContext( SerializationCompatibilityLevel.Version0_9 );
			context.Serializers.Register( new CustomDateTimeSerealizer() );
			var serializer = CreateTarget<DateTime>( context );

			using ( var stream = new MemoryStream() )
			{
				var date = DateTime.UtcNow;
				serializer.Pack( stream, date );
				stream.Position = 0;
				var unpacked = serializer.Unpack( stream );
				Assert.That( unpacked.ToString( "yyyyMMddHHmmssfff" ), Is.EqualTo( date.ToString( "yyyyMMddHHmmssfff" ) ) );
			}
		}

		[Test]
		public void TestExt_DefaultContext()
		{
			var context = NewSerializationContext( SerializationCompatibilityLevel.Latest );
			context.Serializers.Register( new CustomDateTimeSerealizer() );
			var serializer = CreateTarget<DateTime>( context );

			using ( var stream = new MemoryStream() )
			{
				var date = DateTime.UtcNow;
				serializer.Pack( stream, date );
				stream.Position = 0;
				var unpacked = serializer.Unpack( stream );
				Assert.That( unpacked.ToString( "yyyyMMddHHmmssfff" ), Is.EqualTo( date.ToString( "yyyyMMddHHmmssfff" ) ) );
			}
		}

		[Test]
		public void TestExt_ContextWithPackerCompatilibyOptionsNone()
		{
			var context = NewSerializationContext();
			context.Serializers.Register( new CustomDateTimeSerealizer() );
			context.CompatibilityOptions.PackerCompatibilityOptions = PackerCompatibilityOptions.None;
			var serializer = CreateTarget<DateTime>( context );

			using ( var stream = new MemoryStream() )
			{
				var date = DateTime.UtcNow;
				serializer.Pack( stream, date );
				stream.Position = 0;
				var unpacked = serializer.Unpack( stream );
				Assert.That( unpacked.ToString( "yyyyMMddHHmmssfff" ), Is.EqualTo( date.ToString( "yyyyMMddHHmmssfff" ) ) );
			}
		}

		[Test]
		public void TestAbstractTypes_KnownCollections_Default_Success()
		{
			var context = NewSerializationContext();
			var serializer = CreateTarget<WithAbstractInt32Collection>( context );

			using ( var stream = new MemoryStream() )
			{
				var value = new WithAbstractInt32Collection() { Collection = new[] { 1, 2 } };
				serializer.Pack( stream, value );
				stream.Position = 0;
				var unpacked = serializer.Unpack( stream );
				Assert.That( unpacked.Collection, Is.Not.Null.And.InstanceOf<List<int>>() );
				Assert.That( unpacked.Collection[ 0 ], Is.EqualTo( 1 ) );
				Assert.That( unpacked.Collection[ 1 ], Is.EqualTo( 2 ) );
			}
		}

		[Test]
		public void TestAbstractTypes_KnownCollections_WithoutRegistration_Fail()
		{
			var context = NewSerializationContext();
			context.DefaultCollectionTypes.Unregister( typeof( IList<> ) );
			Assert.Throws<NotSupportedException>( () => DoKnownCollectionTest<WithAbstractInt32Collection>( context ) );
		}

		[Test]
		public void TestAbstractTypes_KnownCollections_ExplicitRegistration_Success()
		{
			var context = NewSerializationContext();
			context.DefaultCollectionTypes.Register( typeof( IList<> ), typeof( Collection<> ) );
			var serializer = CreateTarget<WithAbstractInt32Collection>( context );

			using ( var stream = new MemoryStream() )
			{
				var value = new WithAbstractInt32Collection() { Collection = new[] { 1, 2 } };
				serializer.Pack( stream, value );
				stream.Position = 0;
				var unpacked = serializer.Unpack( stream );
				Assert.That( unpacked.Collection, Is.Not.Null.And.InstanceOf<Collection<int>>() );
				Assert.That( unpacked.Collection[ 0 ], Is.EqualTo( 1 ) );
				Assert.That( unpacked.Collection[ 1 ], Is.EqualTo( 2 ) );
			}
		}

		[Test]
		public void TestAbstractTypes_KnownCollections_ExplicitRegistrationForSpecific_Success()
		{
			var context = NewSerializationContext();
			context.DefaultCollectionTypes.Register( typeof( IList<int> ), typeof( Collection<int> ) );
			var serializer1 = CreateTarget<WithAbstractInt32Collection>( context );

			using ( var stream = new MemoryStream() )
			{
				var value = new WithAbstractInt32Collection() { Collection = new[] { 1, 2 } };
				serializer1.Pack( stream, value );
				stream.Position = 0;
				var unpacked = serializer1.Unpack( stream );
				Assert.That( unpacked.Collection, Is.Not.Null.And.InstanceOf<Collection<int>>() );
				Assert.That( unpacked.Collection[ 0 ], Is.EqualTo( 1 ) );
				Assert.That( unpacked.Collection[ 1 ], Is.EqualTo( 2 ) );
			}

			// check other types are not affected
			var serializer2 = CreateTarget<WithAbstractStringCollection>( context );

			using ( var stream = new MemoryStream() )
			{
				var value = new WithAbstractStringCollection() { Collection = new[] { "1", "2" } };
				serializer2.Pack( stream, value );
				stream.Position = 0;
				var unpacked = serializer2.Unpack( stream );
				Assert.That( unpacked.Collection, Is.Not.Null.And.InstanceOf<List<string>>() );
				Assert.That( unpacked.Collection[ 0 ], Is.EqualTo( "1" ) );
				Assert.That( unpacked.Collection[ 1 ], Is.EqualTo( "2" ) );
			}
		}

		[Test]
		public void TestAbstractTypes_NotACollection_Fail()
		{
			var context = NewSerializationContext();
			Assert.Throws<NotSupportedException>( () => DoKnownCollectionTest<WithAbstractNonCollection>( context ) );
		}

#if !NET35 && !UNITY && !SILVERLIGHT

		[Test]
		public void TestReadOnlyCollectionInterfaceDefault()
		{
<#+
	foreach ( var type in new [] { "IReadOnlyCollection", "IReadOnlyList" } )
	{
		var genericArgument = "<" + type + "<int>>";
#>
			TestCollectionInterfaceCore<#= genericArgument #>(
				new byte[] { 0x91, 0x1 },
				result =>
				{
					Assert.That( result, Is.InstanceOf<List<int>>() );
					Assert.That( result.Count, Is.EqualTo( 1 ) );
					Assert.That( result.First(), Is.EqualTo( 1 ) );
				},
				null
			);
<#+
	}

	foreach ( var type in new [] { "IReadOnlyDictionary" } )
	{
		var genericArgument = "<" + type + "<int, int>>";
#>
			TestCollectionInterfaceCore<#= genericArgument #>(
				new byte[] { 0x81, 0x1, 0x2 },
				result =>
				{
					Assert.That( result, Is.InstanceOf<Dictionary<int, int>>() );
					Assert.That( result.Count, Is.EqualTo( 1 ) );
					Assert.That( result.ContainsKey( 1 ) );
					Assert.That( result[ 1 ], Is.EqualTo( 2 ) );
				},
				null
			);
<#+
	}
#>
		}

		[Test]
		public void TestReadOnlyCollectionInterfaceExplicit()
		{
<#+
	foreach ( var type in new [] { new { Interface = "IReadOnlyCollection", Concrete = "AppendableReadOnlyCollection" }, new { Interface = "IReadOnlyList", Concrete = "AppendableReadOnlyList" } } )
	{
		var genericArgument = "<" + type.Interface + "<int>>";
#>
			TestCollectionInterfaceCore<#= genericArgument #>(
				new byte[] { 0x91, 0x1 },
				result =>
				{
					Assert.That( result, Is.InstanceOf<List<int>>() );
					Assert.That( result.Count, Is.EqualTo( 1 ) );
					Assert.That( result.First(), Is.EqualTo( 1 ) );
				},
				context => context.DefaultCollectionTypes.Register( typeof( <#= type.Interface #><int> ), typeof( <#= type.Concrete #><int> ) )
			);
<#+
	}

	foreach ( var type in new [] { new { Interface = "IReadOnlyDictionary", Concrete = "AppendableReadOnlyDictionary" } } )
	{
		var genericArgument = "<" + type.Interface + "<int, int>>";
#>
			TestCollectionInterfaceCore<#= genericArgument #>(
				new byte[] { 0x81, 0x1, 0x2 },
				result =>
				{
					Assert.That( result, Is.InstanceOf<Dictionary<int, int>>() );
					Assert.That( result.Count, Is.EqualTo( 1 ) );
					Assert.That( result.ContainsKey( 1 ) );
					Assert.That( result[ 1 ], Is.EqualTo( 2 ) );
				},
				context => context.DefaultCollectionTypes.Register( typeof( <#= type.Interface #><int, int> ), typeof( <#= type.Concrete #><int, int> ) )
			);
<#+
	}
#>
		}

		private static void TestCollectionInterfaceCore<T>( byte[] data, Action<T> assertion, Action<SerializationContext> registration )
		{
			using ( var buffer = new MemoryStream(data) )
			{
				var serializer = MessagePackSerializer.Get<T>( NewSerializationContext() );
				var result = serializer.Unpack( buffer );
				assertion( result );
			}
		}

#endif // !NET35 && !UNITY && !SILVERLIGHT

		private void TestCore<T>( T value, Func<Stream, T> unpacking, Func<T, T, bool> comparer )
		{
			TestCore( value, unpacking, comparer, null );
		}

		private void TestCore<T>( T value, Func<Stream, T> unpacking, Func<T, T, bool> comparer, Action<SerializationContext> contextAdjuster )
		{
			var safeComparer = comparer ?? EqualityComparer<T>.Default.Equals;
			var context = GetSerializationContext();
			if ( contextAdjuster != null )
			{
				contextAdjuster( context );
			}

			var target = this.CreateTarget<T>( context );
			using ( var buffer = new MemoryStream() )
			{
				target.Pack( buffer, value );
				buffer.Position = 0;
				T intermediate = unpacking( buffer );
				Assert.That( safeComparer( intermediate, value ), "Expected:{1}{0}Actual :{2}", Environment.NewLine, value, intermediate );
				buffer.Position = 0;
				T unpacked = target.Unpack( buffer );
				Assert.That( safeComparer( unpacked, value ), "Expected:{1}{0}Actual :{2}", Environment.NewLine, value, unpacked );
			}
		}

		private void TestCoreWithVerify<T>( T value, SerializationContext context )
			where T : IVerifiable
		{
			var target = this.CreateTarget<T>( context );
			using ( var buffer = new MemoryStream() )
			{
				target.Pack( buffer, value );
				buffer.Position = 0;
				T unpacked = target.Unpack( buffer );
				buffer.Position = 0;
				unpacked.Verify( buffer );
			}
		}

#if FEATURE_TAP

		private async Task TestCoreWithVerifyAsync<T>( T value, SerializationContext context )
			where T : IVerifiable
		{
			var target = this.CreateTarget<T>( context );
			using ( var buffer = new MemoryStream() )
			{
				await target.PackAsync( buffer, value );
				buffer.Position = 0;
				T unpacked = await target.UnpackAsync( buffer );
				buffer.Position = 0;
				unpacked.Verify( buffer );
			}
		}

#endif // FEATURE_TAP

		[Test]
		public void TestIssue25_Plain()
		{
			var hasEnumerable = new HasEnumerable { Numbers = new[] { 1, 2 } };
			var target = CreateTarget<HasEnumerable>( GetSerializationContext() );

			using ( var buffer = new MemoryStream() )
			{
				target.Pack( buffer, hasEnumerable );
				buffer.Position = 0;
				var result = target.Unpack( buffer );
				var resultNumbers = result.Numbers.ToArray();
				Assert.That( resultNumbers.Length, Is.EqualTo( 2 ) );
				Assert.That( resultNumbers[ 0 ], Is.EqualTo( 1 ) );
				Assert.That( resultNumbers[ 1 ], Is.EqualTo( 2 ) );
			}
		}

#if FEATURE_TAP
		[Test]
		public async Task TestIssue25_PlainAsync()
		{
			var hasEnumerable = new HasEnumerable { Numbers = new[] { 1, 2 } };
			var target = CreateTarget<HasEnumerable>( GetSerializationContext() );

			using ( var buffer = new MemoryStream() )
			{
				await target.PackAsync( buffer, hasEnumerable );
				buffer.Position = 0;
				var result = await target.UnpackAsync( buffer );
				var resultNumbers = result.Numbers.ToArray();
				Assert.That( resultNumbers.Length, Is.EqualTo( 2 ) );
				Assert.That( resultNumbers[ 0 ], Is.EqualTo( 1 ) );
				Assert.That( resultNumbers[ 1 ], Is.EqualTo( 2 ) );
			}
		}
#endif // FEATURE_TAP

		[Test]
		public void TestIssue25_SelfComposite()
		{
			SerializationContext serializationContext =
				SerializationContext.Default;
			try
			{

				serializationContext.Serializers.Register( new PersonSerializer() );
				serializationContext.Serializers.Register( new ChildrenSerializer() );

				object[] array = new object[] { new Person { Name = "Joe" }, 3 };

				MessagePackSerializer<object[]> context =
					serializationContext.GetSerializer<object[]>();

				byte[] packed = context.PackSingleObject( array ); 
				object[] unpacked = context.UnpackSingleObject( packed );

				Assert.That( unpacked.Length, Is.EqualTo( 2 ) );
				Assert.That( ( ( MessagePackObject )unpacked[ 0 ] ).AsDictionary()[ "Name" ].AsString(), Is.EqualTo( "Joe" ) );
				Assert.That( ( ( MessagePackObject )unpacked[ 0 ] ).AsDictionary()[ "Children" ].IsNil );
				Assert.That( ( MessagePackObject )unpacked[ 1 ], Is.EqualTo( new MessagePackObject( 3 ) ) );
			}
			finally
			{
				SerializationContext.Default = new SerializationContext();
			}
		}

#region -- ReadOnly / Private Members --

#if !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
		// ReSharper disable UnusedMember.Local
		// member names
		private const string PublicProperty = "PublicProperty";
		private const string PublicReadOnlyProperty = "PublicReadOnlyProperty";
		private const string NonPublicProperty = "NonPublicProperty";
		private const string PublicPropertyPlain = "PublicPropertyPlain";
		private const string PublicReadOnlyPropertyPlain = "PublicReadOnlyPropertyPlain";
		private const string NonPublicPropertyPlain = "NonPublicPropertyPlain";
		private const string CollectionReadOnlyProperty = "CollectionReadOnlyProperty";
		private const string NonPublicCollectionProperty = "NonPublicCollectionProperty";
		private const string NonPublicCollectionField = "NonPublicCollectionField";
		private const string NonPublicCollectionReadOnlyProperty = "NonPublicCollectionReadOnlyProperty";
		private const string NonPublicCollectionReadOnlyField = "NonPublicCollectionReadOnlyField";
		private const string NonPublicDictionaryProperty = "NonPublicDictionaryProperty";
		private const string NonPublicDictionaryField = "NonPublicDictionaryField";
		private const string NonPublicDictionaryReadOnlyProperty = "NonPublicDictionaryReadOnlyProperty";
		private const string NonPublicDictionaryReadOnlyField = "NonPublicDictionaryReadOnlyField";
		private const string NonPublicIDictionaryProperty = "NonPublicIDictionaryProperty";
		private const string NonPublicIDictionaryField = "NonPublicIDictionaryField";
		private const string NonPublicIDictionaryReadOnlyProperty = "NonPublicIDictionaryReadOnlyProperty";
		private const string NonPublicIDictionaryReadOnlyField = "NonPublicIDictionaryReadOnlyField";
		private const string PublicField = "PublicField";
		private const string PublicReadOnlyField = "PublicReadOnlyField";
		private const string NonPublicField = "NonPublicField";
		private const string PublicFieldPlain = "PublicFieldPlain";
		private const string PublicReadOnlyFieldPlain = "PublicReadOnlyFieldPlain";
		private const string NonPublicFieldPlain = "NonPublicFieldPlain";
#if !NETFX_CORE && !SILVERLIGHT
		private const string NonSerializedPublicField = "NonSerializedPublicField";
		private const string NonSerializedPublicReadOnlyField = "NonSerializedPublicReadOnlyField";
		private const string NonSerializedNonPublicField = "NonSerializedNonPublicField";
		private const string NonSerializedPublicFieldPlain = "NonSerializedPublicFieldPlain";
		private const string NonSerializedPublicReadOnlyFieldPlain = "NonSerializedPublicReadOnlyFieldPlain";
		private const string NonSerializedNonPublicFieldPlain = "NonSerializedNonPublicFieldPlain";
#endif // !NETFX_CORE && !SILVERLIGHT
		// ReSharper restore UnusedMember.Local

		[Test]
		public void TestNonPublicWritableMember_PlainOldCliClass()
		{
			var target = new PlainClass();
			target.InitializeCollectionMembers();
			TestNonPublicWritableMemberCore( target, PublicProperty, PublicField, CollectionReadOnlyProperty );
		}

		[Test]
		public void TestNonPublicWritableMember_MessagePackMember()
		{
			var target = new AnnotatedClass();
			target.InitializeCollectionMembers();
#if !NETFX_CORE && !SILVERLIGHT
			TestNonPublicWritableMemberCore(
				target, PublicProperty, NonPublicProperty, PublicField, NonPublicField, NonSerializedPublicField, NonSerializedNonPublicField, CollectionReadOnlyProperty, 
				NonPublicCollectionProperty, NonPublicCollectionField, NonPublicCollectionReadOnlyProperty, NonPublicCollectionReadOnlyField,
				NonPublicDictionaryProperty, NonPublicDictionaryField, NonPublicDictionaryReadOnlyProperty, NonPublicDictionaryReadOnlyField,
				NonPublicIDictionaryProperty, NonPublicIDictionaryField, NonPublicIDictionaryReadOnlyProperty, NonPublicIDictionaryReadOnlyField
			);
#else
			TestNonPublicWritableMemberCore(
				target, PublicProperty, NonPublicProperty, PublicField, NonPublicField, CollectionReadOnlyProperty, 
				NonPublicCollectionProperty, NonPublicCollectionField, NonPublicCollectionReadOnlyProperty, NonPublicCollectionReadOnlyField,
				NonPublicDictionaryProperty, NonPublicDictionaryField, NonPublicDictionaryReadOnlyProperty, NonPublicDictionaryReadOnlyField,
				NonPublicIDictionaryProperty, NonPublicIDictionaryField, NonPublicIDictionaryReadOnlyProperty, NonPublicIDictionaryReadOnlyField
			);
#endif // !NETFX_CORE && !SILVERLIGHT
		}

		[Test]
		public void TestNonPublicWritableMember_DataContract()
		{
			// includes issue33
			var target = new DataMamberClass();
			target.InitializeCollectionMembers();
#if !NETFX_CORE && !SILVERLIGHT
			TestNonPublicWritableMemberCore(
				target, PublicProperty, NonPublicProperty, PublicField, NonPublicField, NonSerializedPublicField, NonSerializedNonPublicField, CollectionReadOnlyProperty, 
				NonPublicCollectionProperty, NonPublicCollectionField, NonPublicCollectionReadOnlyProperty, NonPublicCollectionReadOnlyField,
				NonPublicDictionaryProperty, NonPublicDictionaryField, NonPublicDictionaryReadOnlyProperty, NonPublicDictionaryReadOnlyField,
				NonPublicIDictionaryProperty, NonPublicIDictionaryField, NonPublicIDictionaryReadOnlyProperty, NonPublicIDictionaryReadOnlyField
			 );
#else
			TestNonPublicWritableMemberCore(
				target, PublicProperty, NonPublicProperty, PublicField, NonPublicField, CollectionReadOnlyProperty, 
				NonPublicCollectionProperty, NonPublicCollectionField, NonPublicCollectionReadOnlyProperty, NonPublicCollectionReadOnlyField,
				NonPublicDictionaryProperty, NonPublicDictionaryField, NonPublicDictionaryReadOnlyProperty, NonPublicDictionaryReadOnlyField,
				NonPublicIDictionaryProperty, NonPublicIDictionaryField, NonPublicIDictionaryReadOnlyProperty, NonPublicIDictionaryReadOnlyField
			);
#endif // !NETFX_CORE && !SILVERLIGHT
		}

		private void TestNonPublicWritableMemberCore<T>( T original, params string[] expectedMemberNames )
		{
			var serializer = CreateTarget<T>( GetSerializationContext() );
			using ( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, original );
				buffer.Position = 0;
				var actual = serializer.Unpack( buffer );

				foreach ( var memberName in expectedMemberNames )
				{
					Func<T, Object> getter = null;

					try
					{
#if !NETFX_CORE && !NETSTANDARD1_3
						var property = typeof( T ).GetProperty( memberName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic );
#else
						var property = typeof( T ).GetRuntimeProperties().SingleOrDefault( p => p.Name == memberName );
#endif // !NETFX_CORE && !NETSTANDARD1_3
						if ( property != null )
						{
#if !UNITY
							getter = obj => property.GetValue( obj, null );
#else
							getter = obj => property.GetGetMethod( true ).InvokePreservingExceptionType( obj );
#endif // !UNITY
						}
						else
						{
#if !NETFX_CORE && !NETSTANDARD1_3
							var field =  typeof( T ).GetField( memberName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic );
#else
							var field = typeof( T ).GetRuntimeFields().SingleOrDefault( f => f.Name == memberName );
#endif // !NETFX_CORE && !NETSTANDARD1_3
							if ( field == null )
							{
								Assert.Fail( memberName + " is not found." );
							}

							getter = obj => field.GetValue( obj );
						}
					}
					catch ( MemberAccessException )
					{
#if SILVERLIGHT && !SILVERLIGHT_PRIVILEGED
						Assert.Inconclusive( "Cannot run this test in Silverlight because of CAS" );
#else
						throw;
#endif // SILVERLIGHT && !SILVERLIGHT_PRIVILEGED
					}

					// Naive, but OK
					if ( memberName.Contains( "IDictionary" ) )
					{
						Func<object, Dictionary<string, int>> toDictionary =
							hashTable =>
								( ( System.Collections.IEnumerable )hashTable )
								.OfType<System.Collections.DictionaryEntry>()
								.ToDictionary( 
									de => de.Key.ToString(), 
									de => 
										( de.Value is MessagePackObject )
										? ( int )( MessagePackObject )de.Value
										: ( int )de.Value
								 );

						Assert.That( toDictionary( getter( actual ) ), Is.EqualTo( toDictionary( getter( original ) ) ), typeof(T) + "." + memberName );
					}
					else
					{
						Assert.That( getter( actual ), Is.EqualTo( getter( original ) ), typeof(T) + "." + memberName );
					}
				}
			}
		}
#endif // !SILVERLIGHT || SILVERLIGHT_PRIVILEGED

#endregion -- ReadOnly / Private Members --

#region -- IPackabke/IUnpackable --

		// Issue 150
		[Test]
		public void TestExplicitlyImplementedPackableUnpackable()
		{
			var target = GetSerializationContext().GetSerializer<PackableUnpackableImplementedExplictly>();
			var obj = new PackableUnpackableImplementedExplictly();
			obj.Data = "ABC";

			using ( var buffer = new MemoryStream() )
			{
				target.Pack( buffer, obj );
				buffer.Position = 0;
				var actual = target.Unpack( buffer );
				Assert.That( actual.Data, Is.EqualTo( PackableUnpackableImplementedExplictly.UnpackingPrefix + PackableUnpackableImplementedExplictly.PackingPrefix + obj.Data ) );
			}
		}

		// Issue153

<#+
	if( emitterFlavor == "ExpressionBased" )
	{
							// Should be removed 0.7
#>
#warning Issue 153 tests for ET are not executed because expression based serializer should be removed in 0.7.
<#+
	}

	foreach ( var isAsync in new [] { false, true } )
	{
		foreach ( var kind in new [] 
			{
				"Enumerable", 
				"Collection", 
				"List", 
				"Dictionary",
				"NonGenericEnumerable", 
				"NonGenericCollection", 
				"NonGenericList", 
				"NonGenericDictionary" 
			}
		)
		{
			foreach ( var isUnpackable in new [] { false, true } )
			{
				foreach ( var isPackable in new [] { false, true } )
				{
					if ( !isPackable && !isUnpackable )
					{
						continue;
					}

					var combination = 
						isPackable
							? ( isUnpackable ? "PackableUnpackable" : "Packable" )
							: "Unpackable";

					foreach ( var isPackabilitiesAware in new [] { false, true } )
					{
						if ( isAsync )
						{
#>
#if FEATURE_TAP
<#+
							if( emitterFlavor == "ExpressionBased" )
							{
#>
#pragma restore disable 1998
<#+
							}
						}
#>

		[Test]
		public <#= isAsync ? "async Task" : "void" #> Test<#= kind #>_<#= combination #>_<#= isPackabilitiesAware ? "Aware" : "NotAware" #><#= isAsync ? "Async" : String.Empty #>()
		{
<#+
						if( emitterFlavor == "ExpressionBased" )
						{
							// Should be removed 0.7
#>
			Assert.Inconclusive( "Expression based serializer should be removed in 0.7" );
		}
<#+
							if ( isAsync )
							{
#>
#endif // FEATURE_TAP
#pragma restore warning 1998
<#+
							}
							continue;
						}
#>
			var context = GetSerializationContext();
			// Check compatibility
			Assert.That( context.CompatibilityOptions.IgnorePackabilityForCollection, Is.False );
<#+
						if ( !isPackabilitiesAware )
						{
#>
			context.CompatibilityOptions.IgnorePackabilityForCollection = true;
<#+
						}

						var getSerializerArguments = String.Empty;
						if ( kind.StartsWith( "NonGeneric" ) )
						{
							getSerializerArguments = 
								kind.Contains( "Dictionary" )
								? " PolymorphismSchema.ForContextSpecifiedDictionary( typeof( " + combination + kind + " ), PolymorphismSchema.ForPolymorphicObject( typeof( object ) ), PolymorphismSchema.ForPolymorphicObject( typeof( object ) ) ) "
								: " PolymorphismSchema.ForContextSpecifiedCollection( typeof( " + combination + kind + " ), PolymorphismSchema.ForPolymorphicObject( typeof( object ) ) ) ";
						}
#>
			var obj = new <#= combination #><#= kind #>();
			obj.Initialize( 1, 2, 3 );
			var target = context.GetSerializer<<#= combination #><#= kind #>>(<#= getSerializerArguments #>);
			using ( var buffer = new MemoryStream() )
			{
<#+
						if ( isAsync )
						{
#>
				await target.PackAsync( buffer, obj ).ConfigureAwait( false );
<#+
						}
						else
						{
#>
				target.Pack( buffer, obj );
<#+
						}
#>
				buffer.Position = 0;
				var data = Unpacking.UnpackObject( buffer );
<#+
				if ( !kind.Contains( "Dictionary" ) )
				{
#>
				// <#= isPackable ? "Always 1 because of IPackable" : "As-is" #>
				Assert.That( data.AsList().Count, Is.EqualTo( <#= isPackable ? "1" : "3" #> ) );
<#+
				}
				else
				{
#>
				Assert.That( data.IsDictionary );
				// <#= isPackable ? "Always 1 because of IPackable" : "As-is" #>
				Assert.That( data.AsDictionary().Count, Is.EqualTo( <#= isPackable ? "1" : "3" #> ) );
<#+
				}
#>

<#+
						if ( isPackable )
						{
							if( !isUnpackable )
							{
#>
				// Regular UnpackFrom cannot recognize stream generated by our IPackable, so emit standard value here.
				buffer.SetLength( 0 );
				buffer.Write( new byte[] { <#= kind.Contains( "Dictionary" ) ? "0x80" : "0x90" #> } );
<#+
							}
						}
#>
				buffer.Position = 0;

<#+
						if ( isAsync )
						{
#>
				var actual = await target.UnpackAsync( buffer ).ConfigureAwait( false );
<#+
						}
						else
						{
#>
				var actual = target.Unpack( buffer );
<#+
						}
#>
<#+
						if ( isUnpackable )
						{
#>
				// Capacitized constructor should be called with 0.
				Assert.That( actual.Capacity, Is.EqualTo( 0 ) );

				// Always two zeros because of IUnpackable
				Assert.That( actual.GetValues(), Is.EqualTo( new [] { 0, 0 } ) );
<#+
						}
						else
						{
#>
				// Always empty because of our stream rewriting.
				Assert.That( actual.GetValues(), Is.EqualTo( new int[ 0 ] ) );
<#+
						}
#>
			}

		}

<#+
						if ( isAsync )
						{
#>
#endif // FEATURE_TAP
<#+
						}
					} // foreach isPackabilitiesAware
				} // foreach isPackable
			} // foreach isUnpackable
		} // foreach kind
	} // foreach isAsync
#>

#endregion -- IPackabke/IUnpackable --

<#+
	if ( !forIos )
	{
#>
#region -- Exclusion --

		private void TestIgnoreCore<T>( Action<T> setter, Action<T, T> assertion )
			where T : new()
		{
			var target = GetSerializationContext().GetSerializer<T>();
			var obj = new T();
			setter( obj );
			using ( var buffer = new MemoryStream() )
			{
				target.Pack( buffer, obj );
				buffer.Position = 0;
				var actual = target.Unpack( buffer );
				assertion( obj, actual );
			}
		}

		private void TestIgnoreCore<T, TException>()
			where TException : Exception
		{
			Assert.Throws<TException>( () => GetSerializationContext().GetSerializer<T>() );
		}

		[Test]
		public void TestIgnore_Normal()
		{
			TestIgnoreCore<Excluded>( 
				target => { 
					target.IgnoredField = "ABC";
					target.IgnoredProperty = "ABC";
					target.NotIgnored = "ABC";
				},
				( expected, actual ) =>
				{
					Assert.That( actual.IgnoredField, Is.Null );
					Assert.That( actual.IgnoredProperty, Is.Null );
					Assert.That( actual.NotIgnored, Is.EqualTo( expected.NotIgnored ) );
				}
			);
		}

		[Test]
		public void TestIgnore_ExcludedOnly()
		{
			TestIgnoreCore<OnlyExcluded, SerializationException>();
		}

		[Test]
		public void TestIgnore_ExclusionAndInclusionMixed()
		{
			TestIgnoreCore<ExclusionAndInclusionMixed>( 
				target => { 
					target.IgnoredField = "ABC";
					target.IgnoredProperty = "ABC";
					target.NotMarked = "ABC";
					target.Marked = "ABC";
				},
				( expected, actual ) =>
				{
					Assert.That( actual.IgnoredField, Is.Null );
					Assert.That( actual.IgnoredProperty, Is.Null );
					Assert.That( actual.NotMarked, Is.Null );
					Assert.That( actual.Marked, Is.EqualTo( expected.Marked ) );
				}
			);
		}

		[Test]
		public void TestIgnore_ExclusionAndInclusionSimulatously()
		{
			TestIgnoreCore<ExclusionAndInclusionSimulatously, SerializationException>();
		}


		public class OnlyExcluded
		{
			[MessagePackIgnore]
			public string Ignored { get; set; }
		}

		public class Excluded
		{
			[MessagePackIgnore]
			public string IgnoredField;

			[MessagePackIgnore]
			public string IgnoredProperty { get; set; }

			public string NotIgnored { get; set; }
		}

		public class ExclusionAndInclusionMixed
		{
			[MessagePackIgnore]
			public string IgnoredField;

			[MessagePackIgnore]
			public string IgnoredProperty { get; set; }

			public string NotMarked { get; set; }

			[MessagePackMember( 0 )]
			public string Marked { get; set; }
		}

		public class ExclusionAndInclusionSimulatously
		{
			[MessagePackMember( 0 )]
			public string Marked { get; set; }

			[MessagePackIgnore]
			[MessagePackMember( 1 )]
			public string DoubleMarked { get; set; }
		}

#endregion -- Exclusion --

#if !UNITY
		// Mono 2.7.3 AOT fails when these classes are used...
		// Issue 119
#region -- Generic --
<#+
		foreach( var target in new [] { "Generic", "GenericRecord" } )
		{
			foreach( var type in new [] { "Value", "Reference" } )
			{
#>

		[Test]
		public void Test<#= target #>Derived_<#= type #>_Success()
		{
			var context = NewSerializationContext();
			var target =
<#+
				var field = type == "Value" ? "1" : "\"1\"";
				var property = type == "Value" ? "2" : "\"2\"";
				var defaultValue = type == "Value" ? "0" : "null";
				var targetType = target + type + "Class";

				if( target == "Generic" )
				{
#>
				new <#= targetType #>
				{
					GenericField = <#= field #>,
					GenericProperty = <#= property #>
				};
<#+
				}
				else // GenericRecord
				{
#>
				new <#= targetType #>( <#= field #>, <#= property #> );
<#+
				}
#>
			var serializer = context.GetSerializer<#= "<" + targetType + ">" #>();

			using( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );
				Assert.That( result, Is.Not.Null );
				Assert.That( result.GenericField, Is.EqualTo( target.GenericField ) );
<#+
				if ( target == "Generic" )
				{
#>
#if !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
				Assert.That( result.GenericProperty, Is.EqualTo( target.GenericProperty ) );
#else
				Assert.That( result.GenericProperty, Is.EqualTo( <#= defaultValue #> ) );
#endif // !SILVERLIGHT || SILVERLIGHT_PRIVILEGED
<#+
				}
				else
				{
#>
				Assert.That( result.GenericProperty, Is.EqualTo( target.GenericProperty ) );
<#+
				}
#>
			}
		}
<#+
			}
		}
#>

#endregion -- Generic --

<#+
		// ReflectionBasedSerializers do not support nullable because they don't need it.
		if ( !String.IsNullOrWhiteSpace( builderTypeName ) )
		{
#>
#region -- Nullable --
		// Issue #121
<#+
			foreach( var testCase in 
				new []
				{
					new { Label = "Primitive",	Type = "int",		Value = "DateTime.UtcNow.Millisecond" },
					new { Label = "Complex",	Type = "TimeSpan",	Value = "TimeSpan.FromSeconds( DateTime.UtcNow.Millisecond )" },
					new { Label = "Enum",		Type = "DayOfWeek",	Value = "DayOfWeek.Monday" }
				}
			)
			{
#>

		[Test]
		public void TestNullable_<#= testCase.Label #>_NonNull_Success()
		{
			var context = NewSerializationContext();
			var target = <#= testCase.Value #>;
			var serializer = MessagePackSerializer.CreateInternal<#= "<" + testCase.Type + "?>" #>( context, null );

			using( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );
				Assert.That( result, Is.EqualTo( target ) );
			}
		}

		[Test]
		public void TestNullable_<#= testCase.Label #>_Null_Success()
		{
			var context = NewSerializationContext();
			var target = default( <#= testCase.Type #>? );
			var serializer = MessagePackSerializer.CreateInternal<#= "<" + testCase.Type + "?>" #>( context, null );

			using( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );
				Assert.That( result, Is.EqualTo( target ) );
			}
		}
<#+
			}
#>
#endregion  -- Nullable --
<#+
		}
#>

#endif // !UNITY

<#+
	}
#>

		// Related to issue #62 -- internal types handling is not consistent at first.

		[Test]
		public void TestNonPublicType_Plain_Failed()
		{
			Assert.Throws<SerializationException>( () => this.CreateTarget<NonPublic>( GetSerializationContext() ) );
		}

		[Test]
		public void TestNonPublicType_MessagePackMember_Failed()
		{
			Assert.Throws<SerializationException>( () => this.CreateTarget<NonPublicWithMessagePackMember>( GetSerializationContext() ) );
		}

		[Test]
		public void TestNonPublicType_DataContract_Failed()
		{
			Assert.Throws<SerializationException>( () => this.CreateTarget<NonPublicWithDataContract>( GetSerializationContext() ) );
		}

		// Issue 170
		[Test]
		public void TestStaticMembersDoNotCausePrepareError()
		{
			MessagePackSerializer.Get<ClassHasStaticField>().PackSingleObject( new ClassHasStaticField() );
		}

#pragma warning disable 649
		internal class NonPublic
		{
			public int Value;
		}

		internal class NonPublicWithMessagePackMember
		{
			[MessagePackMember( 0 )]
			public int Value;
		}

		[DataContract]
		internal class NonPublicWithDataContract
		{
			[DataMember]
			public int Value;
		}
#pragma warning restore 649

		// issue #63
		[Test]
		public void TestManyMembers()
		{
			var serializer = this.CreateTarget<WithManyMembers>( GetSerializationContext() );
			var target = new WithManyMembers();
			using ( var buffer = new MemoryStream() )
			{
				serializer.Pack( buffer, target );
				buffer.Position = 0;
				var result = serializer.Unpack( buffer );
				Assert.That( result, Is.EqualTo( target ) );
			}
		}

#pragma warning disable 659
		public class WithManyMembers
		{
			private readonly int[] _backingField = Enumerable.Range( 0, SByte.MaxValue + 2 ).ToArray();

<#+
	for ( var i = 0; i <= SByte.MaxValue + 1; i++ )
	{
#>
			public int Member<#= i #>
			{
				get { return this._backingField[ <#= i #> ]; }
				set { this._backingField[ <#= i #> ] = value; }
			}
<#+

	}
#>

			public override bool Equals( object obj )
			{
				var other = obj as WithManyMembers;
				if ( other == null )
				{
					return false;
				}

				return this._backingField == other._backingField || this._backingField.SequenceEqual( other._backingField );
			}
		}
#pragma warning restore 659

#region issue #169

		[Test]
		public void TestImplementsGenericIEnumerableWithNoAdd_Success()
		{
			var serializer = this.CreateTarget<GenericNonCollectionType>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new GenericNonCollectionType { Property = 123 };
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.Property, Is.EqualTo( 123 ) );
			}
		}

		[Test]
		public void TestImplementsNonGenericIEnumerableWithNoAdd_Success()
		{
			var serializer = this.CreateTarget<NonGenericNonCollectionType>( GetSerializationContext() );
			using ( var stream = new MemoryStream() )
			{
				var value = new NonGenericNonCollectionType { Property = 123 };
				serializer.Pack( stream, value );
				stream.Position = 0;
				var result = serializer.Unpack( stream );
				Assert.That( result.Property, Is.EqualTo( 123 ) );
			}
		}

<#+
	if ( !forIos )
	{
#>
		[Test]
		public void TestImplementsGenericIEnumerableWithNoAdd_ProhibitEnumerableNonCollection_Fail()
		{
			var context = GetSerializationContext();
			context.CompatibilityOptions.AllowNonCollectionEnumerableTypes = false;
			Assert.Throws<SerializationException>( () => this.CreateTarget<GenericNonCollectionType>( context ) );
		}

		[Test]
		public void TestImplementsNonGenericIEnumerableWithNoAdd_ProhibitEnumerableNonCollection_Fail()
		{
			var context = GetSerializationContext();
			context.CompatibilityOptions.AllowNonCollectionEnumerableTypes = false;
			Assert.Throws<SerializationException>( () => this.CreateTarget<GenericNonCollectionType>( context ) );
		}

<#+
	} // if !forIos

	if ( serializationMethod == "Map" && !forIos )
	{
#>
		// Issue #136
		[Test]
		public void TestOmitNullEntryInDictionary()
		{
			var context = GetSerializationContext();
			Assert.That( context.DictionarySerializationOptions.OmitNullEntry, Is.False, "default value" );
			TestOmitNullEntryInDictionaryCore( context, true, false );
			context.DictionarySerializationOptions.OmitNullEntry = true;
			TestOmitNullEntryInDictionaryCore( context, false, false );
		}

#if FEATURE_TAP

		[Test]
		public void TestOmitNullEntryInDictionary_Async()
		{
			var context = GetSerializationContext();
			Assert.That( context.DictionarySerializationOptions.OmitNullEntry, Is.False, "default value" );
			TestOmitNullEntryInDictionaryCore( context, true, true );
			context.DictionarySerializationOptions.OmitNullEntry = true;
			TestOmitNullEntryInDictionaryCore( context, false, true );
		}

#endif // FEATURE_TAP

		[Test]
		public void TestOmitNullEntryInDictionary_BackwordCompatibility()
		{
			SerializerDebugging.UseLegacyNullMapEntryHandling = true;
			try
			{
				var context = GetSerializationContext();
				context.DictionarySerializationOptions.OmitNullEntry = true;
				TestOmitNullEntryInDictionaryCore( context, true, false );
			}
			finally
			{
				SerializerDebugging.UseLegacyNullMapEntryHandling = false;
			}
		}

#if FEATURE_TAP

		[Test]
		public void TestOmitNullEntryInDictionary_BackwordCompatibility_Async()
		{
			SerializerDebugging.UseLegacyNullMapEntryHandling = true;
			try
			{
				var context = GetSerializationContext();
				context.DictionarySerializationOptions.OmitNullEntry = true;
				TestOmitNullEntryInDictionaryCore( context, true, true );
			}
			finally
			{
				SerializerDebugging.UseLegacyNullMapEntryHandling = false;
			}
		}

#endif // FEATURE_TAP

		private static void TestOmitNullEntryInDictionaryCore( SerializationContext context, bool shouldContainNulls, bool isAsync )
		{
			var serializer = context.GetSerializer<SimpleClass>();
			var obj = new SimpleClass { FirstProperty = "foo", SecondProperty = null };
			using ( var buffer = new MemoryStream() )
			{
#if FEATURE_TASK
				if ( isAsync )
				{
					serializer.PackAsync( buffer, obj, CancellationToken.None ).Wait();
				}
				else
				{
#endif // FEATURE_TASK
					serializer.Pack( buffer, obj );
#if FEATURE_TASK
				}
#endif // FEATURE_TASK

				buffer.Position = 0;
				var map = MessagePackSerializer.UnpackMessagePackObject( buffer ).AsDictionary();

				Assert.That( map.ContainsKey( "FirstProperty" ) );
				Assert.That( map.ContainsKey( "SecondProperty" ), Is.EqualTo( shouldContainNulls ) );
				Assert.That( map.ContainsKey( "ThirdProperty" ), Is.EqualTo( shouldContainNulls ) );
				Assert.That( map.ContainsKey( "FourthProperty" ) );
				
				Assert.That( map[ "FirstProperty" ].AsString(), Is.EqualTo( "foo" ) );
				if ( shouldContainNulls )
				{
					Assert.That( map[ "SecondProperty" ].IsNil );
					Assert.That( map[ "ThirdProperty" ].IsNil );
				}
				Assert.That( map[ "FourthProperty" ].AsInt32(), Is.EqualTo( 0 ) );

				buffer.Position = 0;

				SimpleClass deserialized;
#if FEATURE_TASK
				if ( isAsync )
				{
					deserialized = serializer.UnpackAsync( buffer, CancellationToken.None ).Result;
				}
				else
				{
#endif // FEATURE_TASK
					deserialized = serializer.Unpack( buffer );
#if FEATURE_TASK
				}
#endif // FEATURE_TASK

				Assert.That( deserialized.FirstProperty, Is.EqualTo( obj.FirstProperty) );
				Assert.That( deserialized.SecondProperty, Is.EqualTo( obj.SecondProperty) );
				Assert.That( deserialized.ThirdProperty, Is.EqualTo( obj.ThirdProperty) );
				Assert.That( deserialized.FourthProperty, Is.EqualTo( obj.FourthProperty) );
			}
		}

		// Issue #175
		[Test]
		public void TestDictionaryKeyTransformer_Default_AsIs()
		{
			var context = GetSerializationContext();
			Assert.That( context.DictionarySerializationOptions.KeyTransformer, Is.Null, "default value" );
			TestDictionaryKeyCore( context, "FirstProperty", "SecondProperty", "ThirdProperty", "FourthProperty", asIs: true, isAsync: false );
		}

#if FEATURE_TAP

		[Test]
		public void TestDictionaryKeyTransformer_Default_AsIs_Async()
		{
			var context = GetSerializationContext();
			Assert.That( context.DictionarySerializationOptions.KeyTransformer, Is.Null, "default value" );
			TestDictionaryKeyCore( context, "FirstProperty", "SecondProperty", "ThirdProperty", "FourthProperty", asIs: true, isAsync: true );
		}

#endif // FEATURE_TAP

		[Test]
		public void TestDictionaryKeyTransformer_LowerCamel()
		{
			var context = GetSerializationContext();
			context.DictionarySerializationOptions.KeyTransformer = DictionaryKeyTransformers.LowerCamel;
			TestDictionaryKeyCore( context, "firstProperty", "secondProperty", "thirdProperty", "fourthProperty", asIs: false, isAsync: false );
		}

#if FEATURE_TAP

		[Test]
		public void TestDictionaryKeyTransformer_LowerCamel_Async()
		{
			var context = GetSerializationContext();
			context.DictionarySerializationOptions.KeyTransformer = DictionaryKeyTransformers.LowerCamel;
			TestDictionaryKeyCore( context, "firstProperty", "secondProperty", "thirdProperty", "fourthProperty", asIs: false, isAsync: true );
		}

#endif // FEATURE_TAP

		[Test]
		public void TestDictionaryKeyTransformer_Custom()
		{
			var context = GetSerializationContext();
			context.DictionarySerializationOptions.KeyTransformer = 
				key => Regex.Replace( key, "[A-Z]", match => match.Index == 0 ? match.Value.ToLower() : "-" + match.Value.ToLower() );
			TestDictionaryKeyCore( context, "first-property", "second-property", "third-property", "fourth-property", asIs: false, isAsync: false );
		}

#if FEATURE_TAP

		[Test]
		public void TestDictionaryKeyTransformer_Custom_Async()
		{
			var context = GetSerializationContext();
			context.DictionarySerializationOptions.KeyTransformer = 
				key => Regex.Replace( key, "[A-Z]", match => match.Index == 0 ? match.Value.ToLower() : "-" + match.Value.ToLower() );
			TestDictionaryKeyCore( context, "first-property", "second-property", "third-property", "fourth-property", asIs: false, isAsync: true );
		}

#endif // FEATURE_TAP

		private static void TestDictionaryKeyCore( SerializationContext context, string expectedKey1, string expectedKey2, string expectedKey3, string expectedKey4, bool asIs, bool isAsync )
		{
			var serializer = context.GetSerializer<SimpleClass>();
			var obj = new SimpleClass { FirstProperty = "foo", SecondProperty = "bar", ThirdProperty = 3, FourthProperty = 4 };
			using ( var buffer = new MemoryStream() )
			{
#if FEATURE_TAP
				if ( isAsync )
				{
					serializer.PackAsync( buffer, obj, CancellationToken.None ).Wait();
				}
				else
				{
#endif // FEATURE_TAP
					serializer.Pack( buffer, obj );
#if FEATURE_TAP
				}
#endif // FEATURE_TAP

				buffer.Position = 0;
				var map = MessagePackSerializer.UnpackMessagePackObject( buffer ).AsDictionary();

				Assert.That( map.ContainsKey( "FirstProperty" ), Is.EqualTo( asIs ) );
				Assert.That( map.ContainsKey( "SecondProperty" ), Is.EqualTo( asIs ) );
				Assert.That( map.ContainsKey( "ThirdProperty" ), Is.EqualTo( asIs ) );
				Assert.That( map.ContainsKey( "FourthProperty" ), Is.EqualTo( asIs ) );
				Assert.That( map.ContainsKey( expectedKey1 ) );
				Assert.That( map.ContainsKey( expectedKey2 ) );
				Assert.That( map.ContainsKey( expectedKey3 ) );
				Assert.That( map.ContainsKey( expectedKey4 ) );

				buffer.Position = 0;

				SimpleClass deserialized;
#if FEATURE_TAP
				if ( isAsync )
				{
					deserialized = serializer.UnpackAsync( buffer, CancellationToken.None ).Result;
				}
				else
				{
#endif // FEATURE_TAP
					deserialized = serializer.Unpack( buffer );
#if FEATURE_TAP
				}
#endif // FEATURE_TAP

				Assert.That( deserialized.FirstProperty, Is.EqualTo( obj.FirstProperty ) );
				Assert.That( deserialized.SecondProperty, Is.EqualTo( obj.SecondProperty ) );
				Assert.That( deserialized.ThirdProperty, Is.EqualTo( obj.ThirdProperty ) );
				Assert.That( deserialized.FourthProperty, Is.EqualTo( obj.FourthProperty ) );
			}
		}
<#+
	} // if  serializationMethod == "Map" && !forIoS
#>
#endregion issue #169

		#region -- Asymmetric --
<#+
	foreach ( var testCase in
		new []
		{
			new { Type = "NoSettableNoConstructors",		Init = "().Initialize( \"A\" )" },
			new { Type = "NoSettableMultipleConstructors",	Init = "( \"A\", 0 )" },
			new { Type = "NoDefaultConstructor",			Init = "( 'A' )" },
		}
	)
	{
#>
		[Test]
		public void TestAsymmetric_PackOnly_<#= testCase.Type #>_Packable()
		{
			this.TestAsymmetricPackOnlyCore(
				() => new <#= testCase.Type #>ForAsymmetricTest<#= testCase.Init #>,
				SerializerCapabilities.PackTo,
<#+
		if ( serializationMethod == "Map" )
		{
#>
				new byte[] { 0x81, 0xA5, ( byte )'V', ( byte )'a', ( byte )'l', ( byte )'u', ( byte )'e', 0xA1, ( byte )'A' }
<#+
		}
		else
		{
#>
				new byte[] { 0x91, 0xA1, ( byte )'A' }
<#+
		}
#>
			);
		}

<#+
	}
#>

<#+
	foreach ( var testCase in
		new []
		{
			new { Type = "UnconstructableEnumerable",				IsDictionary = false,	Init = "( \"A\" )" },
			new { Type = "UnconstructableCollection",				IsDictionary = false,	Init = "( \"A\" )" },
			new { Type = "UnconstructableList",						IsDictionary = false,	Init = "( \"A\" )" },
			new { Type = "UnconstructableDictionary",				IsDictionary = true,	Init = "( new KeyValuePair<string, string>( \"A\", \"A\" ) )" },
			new { Type = "UnconstructableNonGenericEnumerable",		IsDictionary = false,	Init = "( \"A\" )" },
			new { Type = "UnconstructableNonGenericCollection",		IsDictionary = false,	Init = "( \"A\" )" },
			new { Type = "UnconstructableNonGenericList",			IsDictionary = false,	Init = "( \"A\" )" },
			new { Type = "UnconstructableNonGenericDictionary",		IsDictionary = true,	Init = "( new DictionaryEntry( \"A\", \"A\" ) )" },
			new { Type = "UnappendableEnumerable",					IsDictionary = false,	Init = "( \"A\" )" },
			new { Type = "UnappendableNonGenericEnumerable",		IsDictionary = false,	Init = "( \"A\" )" },
			new { Type = "UnappendableNonGenericCollection",		IsDictionary = false,	Init = "( \"A\" )" }
		}
	)
	{
#>
		[Test]
		public void TestAsymmetric_PackOnly_<#= testCase.Type #>_Packable()
		{
			this.TestAsymmetricPackOnlyCore(
				() => new <#= testCase.Type #>ForAsymmetricTest<#= testCase.Init #>,
				SerializerCapabilities.PackTo,
<#+
		if ( testCase.IsDictionary )
		{
#>
				new byte[] { 0x81, 0xA1, ( byte )'A', 0xA1, ( byte )'A' }
<#+
		}
		else
		{
#>
				new byte[] { 0x91, 0xA1, ( byte )'A' }
<#+
		}
#>
			);
		}

<#+
	}
#>

		[Test]
		public void TestAsymmetric_PackOnly_UnsettableArrayMemberObject_Packable()
		{
			this.TestAsymmetricPackOnlyCore(
				() => new UnsettableArrayMemberObjectForAsymmetricTest(),
				SerializerCapabilities.PackTo,
<#+
		if ( serializationMethod == "Map" )
		{
#>
				new byte[] { 0x82, 0xA5, ( byte )'F', ( byte )'i', ( byte )'e', ( byte )'l', ( byte )'d', 0x91, 0xA1, ( byte )'A', 0xA8, ( byte )'P', ( byte )'r', ( byte )'o', ( byte )'p', ( byte )'e', ( byte )'r', ( byte )'t', ( byte )'y', 0x91, 0xA1, ( byte )'A' }
<#+
		}
		else
		{
#>
				new byte[] { 0x92, 0x91, 0xA1, ( byte )'A', 0x91, 0xA1, ( byte )'A' }
<#+
		}
#>
			);
		}

		private void TestAsymmetricPackOnlyCore<T>( Func<T> factory, SerializerCapabilities expectedCapabilities, byte[] serialized )
		{
			this.TestAsymmetricPackOnlyCore( factory, expectedCapabilities, serialized, true );
			this.TestAsymmetricPackOnlyCore( factory, expectedCapabilities, serialized, false );
		}

		private void TestAsymmetricPackOnlyCore<T>( Func<T> factory, SerializerCapabilities expectedCapabilities, byte[] serialized, bool avoidsGenericSerializer )
		{
			var previousAvoidsGenericSerializer = SerializerDebugging.AvoidsGenericSerializer;
			SerializerDebugging.AvoidsGenericSerializer = avoidsGenericSerializer;
			try 
			{
				var context = GetSerializationContext();
				context.CompatibilityOptions.AllowAsymmetricSerializer = true;
				context.CompatibilityOptions.AllowNonCollectionEnumerableTypes = false;

				var serializer = this.CreateTarget<T>( context );
				Assert.That( serializer.Capabilities, Is.EqualTo( expectedCapabilities ) );

				var obj = factory();
				using ( var buffer = new MemoryStream() )
				{
					if ( ( expectedCapabilities & SerializerCapabilities.PackTo ) != 0 )
					{
						serializer.Pack( buffer, obj );
						Assert.That( buffer.ToArray(), Is.EqualTo( serialized ), "{0} != {1}", BitConverter.ToString( buffer.ToArray() ), BitConverter.ToString( serialized ) );
					}
					else if ( ( expectedCapabilities & SerializerCapabilities.UnpackFrom ) != 0 )
					{
						buffer.Write( serialized, 0, serialized.Length );
						buffer.Position = 0;
						var unpacked = serializer.Unpack( buffer );
						Assert.That( obj, Is.EqualTo( unpacked ) );
					}
				}
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = previousAvoidsGenericSerializer;
			}
		}

		#endregion -- Asymmetric --

		#region -- Object Packing/Unpacking --

		[Test]
		public void TestToFromMessagePackObject_Complex()
		{
			var target = new ComplexType() { Source = new Uri( "http://www.exambple.com" ), TimeStamp = DateTime.Now, Data = new byte[] { 0x1, 0x2, 0x3, 0x4 } };
			target.History.Add( DateTime.Now.Subtract( TimeSpan.FromDays( 1 ) ), "Create New" );
			target.Points.Add( 123 );
			TestToFromMessagePackObjectCore(
				target,
				mpo =>
				{
<#+
	if ( serializationMethod == "Array" )
	{
#>
					Assert.That( mpo.IsArray );
					var asList = mpo.AsList();
					Assert.That( asList.Count, Is.EqualTo( 5 ) );

					Assert.That( asList[ 0 ].IsTypeOf<string>().Value );
					Assert.That( asList[ 0 ].AsString(), Is.EqualTo( target.Source.ToString() ) );

					Assert.That( asList[ 1 ].IsTypeOf<byte[]>().Value );
					Assert.That( asList[ 1 ].AsBinary(), Is.EqualTo( target.Data ) );

					Assert.That( asList[ 2 ].IsTypeOf<MessagePackExtendedTypeObject>().Value );
					var timestamp = asList[ 2 ].AsTimestamp();
					Assert.That( timestamp.ToDateTime(), Is.EqualTo( target.TimeStamp.ToUniversalTime() ) );

					Assert.That( asList[ 3 ].IsDictionary );
					var historyKey = asList[ 3 ].AsDictionary().Single().Key.AsTimestamp();
					Assert.That( historyKey.ToDateTime(), Is.EqualTo( target.History.Single().Key.ToUniversalTime() ) );
					Assert.That( asList[ 3 ].AsDictionary().Single().Value.AsString(), Is.EqualTo( target.History.Single().Value ) );

					Assert.That( asList[ 4 ].IsArray );
					Assert.That( asList[ 4 ].AsList().Single().AsInt32(), Is.EqualTo( target.Points.Single() ) );
<#+
	}
	else
	{
#>
					Assert.That( mpo.IsDictionary );
					var asDictionary = mpo.AsDictionary();
					Assert.That( asDictionary.Count, Is.EqualTo( 5 ) );

					Assert.That( asDictionary[ "Source" ].IsTypeOf<string>().Value );
					Assert.That( asDictionary[ "Source" ].AsString(), Is.EqualTo( target.Source.ToString() ) );

					Assert.That( asDictionary[ "Data" ].IsTypeOf<byte[]>().Value );
					Assert.That( asDictionary[ "Data" ].AsBinary(), Is.EqualTo( target.Data ) );

					Assert.That( asDictionary[ "TimeStamp" ].IsTypeOf<MessagePackExtendedTypeObject>().Value );
					var timestamp = asDictionary[ "TimeStamp" ].AsTimestamp();
					Assert.That( timestamp.ToDateTime(), Is.EqualTo( target.TimeStamp.ToUniversalTime() ) );

					Assert.That( asDictionary[ "History" ].IsDictionary );
					var historyKey = asDictionary[ "History" ].AsDictionary().Single().Key.AsTimestamp();
					Assert.That( historyKey.ToDateTime(), Is.EqualTo( target.History.Single().Key.ToUniversalTime() ) );
					Assert.That( asDictionary[ "History" ].AsDictionary().Single().Value.AsString(), Is.EqualTo( target.History.Single().Value ) );

					Assert.That( asDictionary[ "Points" ].IsArray );
					Assert.That( asDictionary[ "Points" ].AsList().Single().AsInt32(), Is.EqualTo( target.Points.Single() ) );
<#+
	}
#>
				}
			);
		}

		[Test]
		public void TestToFromMessagePackObject_ComplexGenerated()
		{
			var target = new ComplexTypeGenerated();
			target.Initialize();
			// This test does not check packed result -- it is verfied with previous test and seems overkill.
			this.TestToFromMessagePackObjectCore( target, _ => {} );
		}

		private void TestToFromMessagePackObjectCore<T>( T value, Action<MessagePackObject> mpoAssertion )
			where T : IVerifiable<T>
		{
			this.TestToFromMessagePackObjectCore( value, mpoAssertion, true );
			this.TestToFromMessagePackObjectCore( value, mpoAssertion, false );
		}

		private void TestToFromMessagePackObjectCore<T>( T value, Action<MessagePackObject> mpoAssertion, bool avoidsGenericSerializer )
			where T : IVerifiable<T>
		{
			var previousAvoidsGenericSerializer = SerializerDebugging.AvoidsGenericSerializer;
			SerializerDebugging.AvoidsGenericSerializer = avoidsGenericSerializer;
			try 
			{
				var context = GetSerializationContext();
				var serializer = this.CreateTarget<T>( context );
				var mpo = serializer.ToMessagePackObject( value );
				mpoAssertion( mpo );
				var result = serializer.FromMessagePackObject( mpo );
				result.Verify( value );

				var mpoLoose = ( ( MessagePackSerializer )serializer ).ToMessagePackObject( value );
				mpoAssertion( mpoLoose );
				var resultLoose = ( ( MessagePackSerializer )serializer ).FromMessagePackObject( mpoLoose );
				Assert.That( resultLoose, Is.TypeOf<T>() );
				( ( T )resultLoose ).Verify( value );
			}
			finally
			{
				SerializerDebugging.AvoidsGenericSerializer = previousAvoidsGenericSerializer;
			}
		}

		#endregion -- Object Packing/Unpacking --

		#region -- Issue 207 --

		[Test]
		public void TestReadOnlyAndConstructor()
		{
			var context = GetSerializationContext();
			var serializer = context.GetSerializer<ReadOnlyAndConstructor>();
			var item = new ReadOnlyAndConstructor( Guid.NewGuid(), new List<int>() { 5, 11 } );
			var serializedItem = serializer.PackSingleObject( item );
<#+
	if ( serializationMethod == "Array" )
	{
#>
			Assert.That(
				serializedItem,
				Is.EqualTo(
					new byte[] { 0x92, MessagePackCode.Bin8, 0x10 }.Concat( item.Id.ToByteArray() )
					.Concat( new byte[] { 0x92, 5, 11 } ).ToArray()
				)
			);
<#+
	}
	else
	{
#>
			Assert.That(
				serializedItem,
				Is.EqualTo( new byte[] { 0x82, 0xA2 }.Concat( Encoding.UTF8.GetBytes( "Id" ) )
					.Concat( new byte[] { MessagePackCode.Bin8, 0x10 } ).Concat( item.Id.ToByteArray() )
					.Concat( new byte[] { 0xA4 } ).Concat( Encoding.UTF8.GetBytes( "Ints" ) )
					.Concat( new byte[] { 0x92, 5, 11 } ).ToArray()
				)
			);
<#+
	}
#>
			var deserializedItem = serializer.UnpackSingleObject( serializedItem );
			Assert.That( deserializedItem.Id, Is.EqualTo( item.Id ) );
			Assert.That( deserializedItem.Ints, Is.EqualTo( item.Ints ) );
		}

		[Test]
		public void TestGetOnlyAndConstructor()
		{
			var context = GetSerializationContext();
			var serializer = context.GetSerializer<GetOnlyAndConstructor>();
			var item = new GetOnlyAndConstructor( Guid.NewGuid(), new List<int>() { 5, 11 } );
			var serializedItem = serializer.PackSingleObject( item );
<#+
	if ( serializationMethod == "Array" )
	{
#>
			Assert.That(
				serializedItem,
				Is.EqualTo(
					new byte[] { 0x92, MessagePackCode.Bin8, 0x10 }.Concat( item.Id.ToByteArray() )
					.Concat( new byte[] { 0x92, 5, 11 } ).ToArray()
				)
			);
<#+
	}
	else
	{
#>
			Assert.That(
				serializedItem,
				Is.EqualTo( new byte[] { 0x82, 0xA2 }.Concat( Encoding.UTF8.GetBytes( "Id" ) )
					.Concat( new byte[] { MessagePackCode.Bin8, 0x10 } ).Concat( item.Id.ToByteArray() )
					.Concat( new byte[] { 0xA4 } ).Concat( Encoding.UTF8.GetBytes( "Ints" ) )
					.Concat( new byte[] { 0x92, 5, 11 } ).ToArray()
				)
			);
<#+
	}
#>
			var deserializedItem = serializer.UnpackSingleObject( serializedItem );
			Assert.That( deserializedItem.Id, Is.EqualTo( item.Id ) );
			Assert.That( deserializedItem.Ints, Is.EqualTo( item.Ints ) );
		}

		#endregion -- Issue 207 --


		#region -- Issue 202 --

		private static SerializationContext GetSerializationContextWithAsyncEnabled( bool withAsync )
		{
			var context = GetSerializationContext();

#if FEATURE_TAP
			context.SerializerOptions.WithAsync = withAsync;
#endif // FEATURE_TAP

			return context;
		}

		private static void TestNoMembersPackableLikeCore<T>( Func<T> factory, Action<MessagePackSerializer<T>, MemoryStream, T> pack, Func<MessagePackSerializer<T>, MemoryStream, T> unpack, Action<T, T> assertion, bool withAsync )
		{
			var context = GetSerializationContextWithAsyncEnabled( withAsync );
			var serializer = context.GetSerializer<T>();
			using ( var buffer = new MemoryStream() )
			{
				var expected = factory();
				pack( serializer, buffer, expected );
				buffer.Position = 0L;
				var actual = unpack( serializer, buffer );
				assertion( expected, actual );
			}
		}

<#+
	foreach ( var isPackable in new [] { true, false } )
	{
		foreach ( var isUnpackable in new [] { true, false } )
		{
			foreach ( var isAsyncPackable in new [] { true, false } )
			{
				foreach ( var isAsyncUnpackable in new [] { true, false } )
				{
					var considerAsync = isAsyncPackable || isAsyncUnpackable;

					foreach ( var enableAsync in new [] { true, false } )
					{
						if ( !considerAsync && enableAsync )
						{
							// skip
							continue;
						}

						var shouldFail =
							!isPackable
							|| !isUnpackable
							|| ( !isAsyncPackable && enableAsync )
							|| ( !isAsyncUnpackable && enableAsync );

						var suffix =
							( isPackable ? "Packable" : String.Empty ) +
							( isUnpackable ? "Unpackable" : String.Empty ) +
							( isAsyncPackable ? "AsyncPackable" : String.Empty ) +
							( isAsyncUnpackable ? "AsyncUnpackable" : String.Empty );
						var methodSuffix = suffix;
						if ( considerAsync )
						{
							methodSuffix += enableAsync ? "_AsyncEnabled" : "_AsyncDisabled";
						}

						methodSuffix += !shouldFail ? "Success" : "Fail";

						if ( considerAsync )
						{
#>
#if FEATURE_TAP

<#+
						}
#>
		[Test]
		public void TestNoMembers_<#= methodSuffix #>()
		{
<#+
						if ( shouldFail )
						{
#>
			Assert.Throws<SerializationException>( () => GetSerializationContextWithAsyncEnabled( <#= enableAsync.ToString().ToLowerInvariant() #> ).GetSerializer<NoMembers<#= suffix #>>() );
<#+
						}
						else
						{
		#>
			TestNoMembersPackableLikeCore(
				() => new NoMembers<#= suffix #>("ABC"),
<#+
							if ( isPackable )
							{
#>
				( s, b, x ) => s.Pack( b, x ),
<#+
							}
							else if ( isAsyncPackable )
							{
#>
				( s, b, x ) => s.PackAsync( b, x ).GetAwaiter().GetResult(),
<#+
							}
							else
							{
#>
				( s, b, x ) => b.Write( new byte[] { 0x91, 0xA3, ( byte )'A', ( byte )'B', ( byte )'C' }, 0, 5 ),
<#+
							} // isPackable

							if ( isUnpackable )
							{
#>
				( s, b ) => s.Unpack( b ),
<#+
							}
							else if ( isAsyncUnpackable )
							{
#>
				( s, b ) => s.UnpackAsync( b ).GetAwaiter().GetResult(),
<#+
							}
							else
							{
#>
				( s, b ) =>
				{
					Assert.That( b.ToArray(), Is.EqualTo( new byte[] { 0x91, 0xA3, ( byte )'A', ( byte )'B', ( byte )'C' } ) );
					return new Empty<#= suffix #>( Encoding.UTF8.GetString( b.ToArray(), 2, 3 ) );
				},
<#+
							} // isUnpackable
#>
				( expected, actual ) => Assert.That( actual.GetValue(), Is.EqualTo( expected.GetValue() ) ),
				<#= enableAsync.ToString().ToLowerInvariant() #>
			);
<#+
						} // shouldFail
#>
		}

<#+
						if ( considerAsync )
						{
#>
#endif // FEATURE_TAP

<#+
						}
					}
				}
			}
		}
	}
#>

		#endregion -- Issue 202 --

<#+
	GeneratePolymorphismTestParts();
}
#>
