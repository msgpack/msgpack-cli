// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace MsgPack.Internal
{
	partial class MessagePackEncoder
	{
		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override void EncodeString(ReadOnlySpan<char> value, IBufferWriter<byte> buffer, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			buffer = EnsureNotNull(buffer);
			encoding = encoding ?? Utf8EncodingNonBom.Instance;
			if (value.Length == 0)
			{
				buffer.GetSpan(1)[0] = MessagePackCode.MinimumFixedRaw;
				buffer.Advance(1);
				return;
			}

			if (value.Length < 256)
			{
				var valueLength = unchecked((int)value.Length);
				var maxByteLength = encoding.GetMaxByteCount(valueLength);

				if (maxByteLength < 32)
				{
					// stack alloc is fastest
					Span<byte> encodingBuffer = stackalloc byte[maxByteLength];
					var actualLength = encoding.GetBytes(value, encodingBuffer);
					var sink = buffer.GetSpan(actualLength + 1);
					sink[0] = unchecked((byte)(MessagePackCode.MinimumFixedRaw | actualLength));
					encodingBuffer.Slice(actualLength).CopyTo(sink.Slice(1));
					buffer.Advance(sink.Length);
					return;
				}
				else if (maxByteLength < 256)
				{
					// stack alloc is fastest
					Span<byte> encodingBuffer = stackalloc byte[maxByteLength + 3];
					var actualLength = encoding.GetBytes(value, encodingBuffer);
					var sink = buffer.GetSpan(3);
					var headerLength = this.EncodeStringHeader(unchecked((uint)actualLength), sink);
					buffer.Advance(headerLength);
					encodingBuffer.Slice(0, actualLength).CopyTo(buffer.GetSpan(actualLength));
					buffer.Advance(actualLength);
					return;
				}
			}

			this.EncodeStringSlow(value, buffer, encoding);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private void EncodeStringSlow(ReadOnlySpan<char> value, IBufferWriter<byte> buffer, Encoding encoding)
		{
			// Use 1-path logic borrowed from MessagePack C#

			// Get max char bytes. Use 2 for 0 (maybe bug) or 1 (ASCII) to simplify following logic.
			var maxBytesPerChar = Math.Max(encoding.GetMaxByteCount(1), 2);

			// In most case, msgpack uses UTF-8 and clob contains 1 to 3 byte chars,
			// and may charactors are ASCII.
			// So, estimate with 1char is 2bytes is good enough here.
			var estimatedLength = unchecked((uint)value.Length * 2);
			var bufferLength = encoding.GetMaxByteCount(unchecked((int)value.Length)) + 5;

			if (bufferLength <= 0x20_0000) // 2MB
			{
				Memory<byte> sinkMemory = buffer.GetMemory(bufferLength);

				if (MemoryMarshal.TryGetArray<byte>(sinkMemory, out var sinkBufferSegment))
				{
					// We can get single array
					buffer.Advance(this.EncodeLargeString1Path(value, buffer, encoding, estimatedLength, sinkBufferSegment));
				}
				else
				{
					// Memory is not array backend, so use local buffer.
					var encodingBuffer = base.Options.ByteBufferPool.Rent(bufferLength);
					try
					{
						var totalLength = this.EncodeLargeString1Path(value, buffer, encoding, estimatedLength, encodingBuffer);
						buffer.Write(encodingBuffer.AsMemory(0, totalLength).Span);
					}
					finally
					{
						base.Options.ByteBufferPool.Return(encodingBuffer, base.Options.ClearsBuffer);
					}
				}
			}

			this.EncodeHugeString2Path(value, buffer, encoding);
		}

		
		private unsafe int EncodeLargeString1Path(ReadOnlySpan<char> value, IBufferWriter<byte> buffer, Encoding encoding, uint estimatedLength, ArraySegment<byte> sinkBufferSegment)
		{
			ref var head = ref sinkBufferSegment.Array![sinkBufferSegment.Offset];

			Span<byte> sinkBuffer = sinkBufferSegment;
			var estimatedHeaderLength = this.EncodeStringHeader(estimatedLength, sinkBuffer);

			int actualLength;

			try
			{
				actualLength = encoding.GetBytes(value, sinkBuffer.Slice(estimatedHeaderLength));
			}
			catch (OverflowException ex)
			{
				Throw.TooLargeByteLength(ex, encoding.EncodingName);
				return 0;
			}

			var realHeaderLength = this.EncodeStringHeader(unchecked((uint)actualLength), sinkBuffer);

			if (estimatedHeaderLength != realHeaderLength)
			{
				fixed (byte* pSinkBuffer = &head)
				{
					Buffer.MemoryCopy((void*)(pSinkBuffer + estimatedHeaderLength), (void*)(pSinkBuffer + realHeaderLength), actualLength, actualLength);
				}
			}

			return actualLength + realHeaderLength;
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override void EncodeString(in ReadOnlySequence<char> value, IBufferWriter<byte> buffer, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			buffer = EnsureNotNull(buffer);
			encoding = encoding ?? Utf8EncodingNonBom.Instance;
			if (value.Length > UInt32.MaxValue)
			{
				Throw.TooLargeCharLength(value.Length);
				return;
			}

			if (value.Length == 0)
			{
				buffer.GetSpan(1)[0] = MessagePackCode.MinimumFixedRaw;
				buffer.Advance(1);
				return;
			}

			if (value.Length < 256)
			{
				var valueLength = unchecked((int)value.Length);
				var maxByteLength = encoding.GetMaxByteCount(valueLength);

				if (maxByteLength < 32)
				{
					// stack alloc is fastest
					Span<byte> encodingBuffer = stackalloc byte[maxByteLength];
					var actualLength = encoding.GetBytes(value, encodingBuffer);
					var sink = buffer.GetSpan(actualLength + 1);
					sink[0] = unchecked((byte)(MessagePackCode.MinimumFixedRaw | actualLength));
					encodingBuffer.Slice(actualLength).CopyTo(sink.Slice(1));
					buffer.Advance(sink.Length);
					return;
				}
				else if (maxByteLength < 256)
				{
					// stack alloc is fastest
					Span<byte> encodingBuffer = stackalloc byte[maxByteLength + 3];
					var actualLength = encoding.GetBytes(value, encodingBuffer);
					var sink = buffer.GetSpan(3);
					var headerLength = this.EncodeStringHeader(unchecked((uint)actualLength), sink);
					buffer.Advance(headerLength);
					encodingBuffer.Slice(0, actualLength).CopyTo(buffer.GetSpan(actualLength));
					buffer.Advance(actualLength);
					return;
				}
			}

			this.EncodeStringSlow(value, buffer, encoding);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private void EncodeStringSlow(in ReadOnlySequence<char> value, IBufferWriter<byte> buffer, Encoding encoding)
		{
			// Use 1-path logic borrowed from MessagePack C#

			// Get max char bytes. Use 2 for 0 (maybe bug) or 1 (ASCII) to simplify following logic.
			var maxBytesPerChar = Math.Max(encoding.GetMaxByteCount(1), 2);

			// In most case, msgpack uses UTF-8 and clob contains 1 to 3 byte chars,
			// and may charactors are ASCII.
			// So, estimate with 1char is 2bytes is good enough here.
			var estimatedLength = unchecked((uint)value.Length * 2);
			var bufferLength = encoding.GetMaxByteCount(unchecked((int)value.Length)) + 5;

			if (bufferLength <= 0x20_0000) // 2MB
			{
				Memory<byte> sinkMemory = buffer.GetMemory(bufferLength);

				if (MemoryMarshal.TryGetArray<byte>(sinkMemory, out var sinkBufferSegment))
				{
					// We can get single array
					buffer.Advance(this.EncodeLargeString1Path(value, buffer, encoding, estimatedLength, sinkBufferSegment));
				}
				else
				{
					// Memory is not array backend, so use local buffer.
					var encodingBuffer = base.Options.ByteBufferPool.Rent(bufferLength);
					try
					{
						var totalLength = this.EncodeLargeString1Path(value, buffer, encoding, estimatedLength, encodingBuffer);
						buffer.Write(encodingBuffer.AsMemory(0, totalLength).Span);
					}
					finally
					{
						base.Options.ByteBufferPool.Return(encodingBuffer, base.Options.ClearsBuffer);
					}
				}
			}

			this.EncodeHugeString2Path(value, buffer, encoding);
		}

		
		private unsafe int EncodeLargeString1Path(in ReadOnlySequence<char> value, IBufferWriter<byte> buffer, Encoding encoding, uint estimatedLength, ArraySegment<byte> sinkBufferSegment)
		{
			ref var head = ref sinkBufferSegment.Array![sinkBufferSegment.Offset];

			Span<byte> sinkBuffer = sinkBufferSegment;
			var estimatedHeaderLength = this.EncodeStringHeader(estimatedLength, sinkBuffer);

			int actualLength;

			try
			{
				actualLength = encoding.GetBytes(value, sinkBuffer.Slice(estimatedHeaderLength));
			}
			catch (OverflowException ex)
			{
				Throw.TooLargeByteLength(ex, encoding.EncodingName);
				return 0;
			}

			var realHeaderLength = this.EncodeStringHeader(unchecked((uint)actualLength), sinkBuffer);

			if (estimatedHeaderLength != realHeaderLength)
			{
				fixed (byte* pSinkBuffer = &head)
				{
					Buffer.MemoryCopy((void*)(pSinkBuffer + estimatedHeaderLength), (void*)(pSinkBuffer + realHeaderLength), actualLength, actualLength);
				}
			}

			return actualLength + realHeaderLength;
		}

	}
}
