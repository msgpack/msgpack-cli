<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly Name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

#nullable enable

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

<#
var typeName = "MessagePackObject";
var types = 
	new Dictionary<object, bool> // value: isStringOrBinary
	{
		{ typeof(bool),						false },
		{ typeof(byte),						false },
		{ typeof(sbyte),					false },
		{ typeof(short),					false },
		{ typeof(ushort),					false },
		{ typeof(int),						false },
		{ typeof(uint),						false },
		{ typeof(long),						false },
		{ typeof(ulong),					false },
		{ typeof(float),					false },
		{ typeof(double),					false },
		{ typeof(string),					true },
		{ typeof(byte[]),					true },
		{ "ReadOnlyMemory<byte>",			true },
		{ "ReadOnlyMemory<char>",			true },
		{ "MessagePackExtendedTypeObject",	false },
		{ "ExtensionTypeObject",			false },
	};
Func<object, bool> IsNotCLSCompliant =
	input => 		
	{
		var type = (input as Type) ?? typeof(object);
		return 
			type == typeof(sbyte)
			|| type == typeof(ushort)
			|| type == typeof(uint)
			|| type == typeof(ulong);
	};
#>

using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace MsgPack
{
	/// <summary>
	///		Represents deserialized object of MsgPack.
	/// </summary>
	[StructLayout(LayoutKind.Auto)]
	public partial struct <#= typeName #> : IEquatable<<#= typeName #>>
	{
		#region -- Constructors --
<#
foreach (var type in types)
{
	var t = type.Key;
	var isBinary = type.Value;

	if (t == "MessagePackExtendedTypeObject")
	{
#>

#pragma warning disable 0618 // obsolete
<#
	}

	if (isBinary)
	{
#>
		/// <summary>
		///		Initializes a new instance of the <see cref="Byte"/>[] type which wraps <see cref="Byte" />[] instance with specified manner.
		/// </summary>
		/// <param name="value">A bytes array to be wrapped.</param>
		/// <remarks>
		///		This constructor invokes <see cref="<#= typeName #>(Byte[],Boolean)" /> with <c>false</c>, that means if you pass tha bytes array which is valid utf-8, resulting object can be <see cref="String" />,
		///		and its <see cref="UnderlyingType" /> should be <see cref="String" />.
		/// </remarks>
		public <#= typeName #>(<#= GetTypeName(t) #> value)
			: this(value, false) { }

		/// <summary>
		///		Initializes a new instance of the <see cref="Byte"/>[] type which wraps <see cref="Byte" />[] instance with specified manner.
		/// </summary>
		/// <param name="value">A bytes array to be wrapped.</param>
		/// <param name="isBinary"><c>true</c> if <paramref name="value"/> always should be binary; <c>false</c>, otherwise.</param>
		/// <remarks>
		///		When the <paramref name="isBinary" /> is <c>true</c>, then resulting object represents binary even if the <paramref name="value"/> is valid utf-8 sequence,
		///		that is, its <see cref="UnderlyingType" /> should be <see cref="Byte" />[].
		///		On the other hand, when  contrast, the <paramref name="isBinary" /> is <c>false</c>, and if the <paramref name="value"/> is valid utf-8, 
		///		then the resulting object can be <see cref="String" />,
		///		and its <see cref="UnderlyingType" /> should be <see cref="String" />.
		/// </remarks>
		public <#= typeName #>(<#= GetTypeName(t) #> value, bool isBinary)
<#
	}
	else
	{
#>
		/// <summary>
		///		Initializes a new instance of the <see cref="<#= typeName #>"/> type which wraps <see cref="<#= GetTypeName( t ) #>"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="<#= typeName #>"/> value to be wrapped.</param>
<#
		if (IsNotCLSCompliant(t))
		{
#>
		[CLSCompliant(false)]
<#
		}
#>
		public <#= typeName #>(<#= GetTypeName(t) #> value)
<#
	}
#>
		{
<#
	if (t.ToString() == typeof(byte[]).ToString())
	{
#>
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			if (value == null)
			{
				this._handleOrTypeCode = null;
			}
			else
			{
				this._handleOrTypeCode = new MessagePackString(value, isBinary);
			}
<#
	}
	else
	{
		this.GenerateConstructor(typeName, "this", t);
	}
#>
		}
<#
	if (t == "MessagePackExtendedTypeObject")
	{
#>

#pragma warning restore 0618 // obsolete
<#
	}
}
#>

		#endregion -- Constructors --

		#region -- Primitive Type Conversion Methods --
<#
foreach(var t in types.Keys )
{
	if (t == "MessagePackExtendedTypeObject")
	{
#>

#pragma warning disable 0618 // obsolete
<#
	}
#>

		/// <summary>
		///		Convert this instance to <#= t.ToString() == typeof( byte[] ).ToString() ? "<see cref=\"Byte\" />[]" : "<see cref=\"" + GetTypeName( t ) + "\" />" #> instance.
		/// </summary>
		/// <returns><#= t.ToString() == typeof( byte[] ).ToString() ? "<see cref=\"Byte\" />[]" : "<see cref=\"" + GetTypeName( t ) + "\" />" #> instance corresponds to this instance.</returns>
<#
if (IsNotCLSCompliant(t))
{
#>
		[CLSCompliant(false)]
<#
}

var methodName =
	t == typeof(byte[]) ?
	"Binary" :
	t == "ReadOnlyMemory<char>" ?
	"ReadOnlyMemoryOfChar" :
	t == "ReadOnlyMemory<byte>" ?
	"ReadOnlyMemoryOfByte" :
	GetTypeName(t);
#>
		public <#= GetTypeName(t) #><#= GetNullability(t) #> As<#= methodName #>()
		{
<#
	this.GenerateAsT("this", t, false);
#>
		}
<#
	if (t == "MessagePackExtendedTypeObject")
	{
#>

#pragma warning restore 0618 // obsolete
<#
	}

}
#>

		#endregion -- Primitive Type Conversion Methods --

		#region -- Conversion Operator Overloads --

<#
foreach (var t in types.Keys)
{
	if (t == "MessagePackExtendedTypeObject")
	{
#>

#pragma warning disable 0618 // obsolete
<#
	}
#>

		/// <summary>
		///		Convert <#= t.ToString() == typeof(byte[]).ToString() ? "<see cref=\"Byte\" />[]" : "<see cref=\"" + GetTypeName(t) + "\" />" #>instance to <see cref="<#= typeName #>"/> instance.
		/// </summary>
		/// <param name="value"><#= t.ToString() == typeof(byte[]).ToString() ? "<see cref=\"Byte\" />[]" : "<see cref=\"" + GetTypeName(t) + "\" />" #> instance.</param>
		/// <returns><see cref="<#=  typeName #>"/> instance corresponds to <paramref name="value"/>.</returns>
<#
if (IsNotCLSCompliant(t))
{
#>
		[CLSCompliant(false)]
<#
}
#>
		public static implicit operator <#= typeName #>(<#= GetTypeName(t) #> value)
			=> new <#= typeName #>(value);
<#
	if (t == "MessagePackExtendedTypeObject")
	{
#>

#pragma warning restore 0618 // obsolete
<#
	}
}
#>

<#
foreach (var t in types.Keys)
{
	if (t == "MessagePackExtendedTypeObject")
	{
#>

#pragma warning disable 0618 // obsolete
<#
	}
#>

		/// <summary>
		///		Convert this instance to <#= t.ToString() == typeof(byte[]).ToString() ? "<see cref=\"Byte\" />[]" : "<see cref=\"" + GetTypeName(t) + "\" />" #> instance.
		/// </summary>
		/// <param name="value"><see cref="<#= typeName #>"/> instance.</param>
		/// <returns><#= t.ToString() == typeof(byte[]).ToString() ? "<see cref=\"Byte\" />[]" : "<see cref=\"" + GetTypeName(t) + "\" />" #> instance corresponds to <paramref name="value"/>.</returns>
<#
	if (IsNotCLSCompliant(t))
	{
#>
		[CLSCompliant(false)]
<#
	}
#>
		public static explicit operator <#= GetTypeName(t) #><#= GetNullability(t) #>(<#= typeName #> value)
		{
<#
	this.GenerateAsT("value", t, true);
#>
		}
<#
	if (t == "MessagePackExtendedTypeObject")
	{
#>

#pragma warning restore 0618 // obsolete
<#
	}

}
#>

		#endregion -- Conversion Operator Overloads --
	}
}
<#+
private static bool IsExplicitConversionRequired(Type type)
{
	return 
		type == typeof(sbyte)
		|| type == typeof(short)
		|| type == typeof(int)
		|| type == typeof(long);
}

private void GenerateConstructor(string typeName, string val, object typeOrTypeName)
{
	var t = typeOrTypeName as Type;
	var targetTypeName = GetTypeName(typeOrTypeName);
#>
			// trick: Avoid long boilerplate initialization.
			<#= val #> = new <#= typeName #>();
<#+ 
	if (targetTypeName == "MessagePackExtendedTypeObject")
	{
#>
			<#= val #>._value = value.TypeCode;
			<#= val #>._handleOrTypeCode = value.Body;
<#+
		return;
	}
	else if (targetTypeName == "ExtensionTypeObject")
	{
#>
			<#= val #>._value = unchecked((ulong)value.Type.Tag);
			<#= val #>._handleOrTypeCode = value.Body;
<#+
		return;
	}
	else if (t == typeof(byte[]))
	{
		// Only implicit conversion operator
#>
			if (value == null)
			{
				<#= val #>._handleOrTypeCode = null;
			}
			else
			{
				<#= val #>._handleOrTypeCode = new MessagePackString(value, false);
			}
<#+
		return;
	}
	else if (t == typeof(string))
	{
#>
			if (value == null)
			{
				<#= val #>._handleOrTypeCode = null;
			}
			else
			{
				<#= val #>._handleOrTypeCode = new MessagePackString(value);
			}
<#+
		return;
	}
	else if (targetTypeName.EndsWith("<byte>"))
	{
		// Only implicit conversion operator
#>
			<#= val #>._handleOrTypeCode = new MessagePackString(value, false);
<#+
		return;
	}
	else if (targetTypeName.EndsWith("<char>"))
	{
#>
			<#= val #>._handleOrTypeCode = new MessagePackString(value);
<#+
		return;
	}
	
	if (t == typeof(bool))
	{
#>
			<#= val #>._value = value ? (ulong)1 : 0;
<#+ 
	}
	else if (IsExplicitConversionRequired(t))
	{
#>
			<#= val #>._value = unchecked((ulong)value);
<#+ 
	}
	else if (t == typeof(float))
	{
#>
			<#= val #>._value = unchecked((ulong)Binary.ToBits(value));
<#+ 
	}
	else if (t == typeof(double))
	{
#>
			<#= val #>._value = unchecked((ulong)BitConverter.DoubleToInt64Bits(value));
<#+ 
	}
	else
	{
#>
			<#= val #>._value = value;
<#+ 
	}

#>
			<#= val #>._handleOrTypeCode = <#= t.Name #>TypeCode;
<#+
} // GenerateConstructor

private void GenerateAsT(string val, Object typeOrTypeName, bool passParameterName)
{
	var t = typeOrTypeName as Type;
	var typeName = GetTypeName(typeOrTypeName);

	if(t == null || t.IsValueType)
	{
#>
			if(<#= val #>.IsNil)
			{
				ThrowCannotBeNilAs<#= "<" + typeName  + ">" #>();
			}
<#+
	}

	if (typeName == "MessagePackExtendedTypeObject")
	{
#>
			VerifyUnderlyingType<MessagePackExtendedTypeObject>(<#= val #>, <#= passParameterName ? "\"" + val + "\"" : "null" #>);

			return MessagePackExtendedTypeObject.Unpack(unchecked((byte)<#= val #>._value), (<#= val #>._handleOrTypeCode as byte[])!);
<#+
	}
	else if (typeName == "ExtensionTypeObject")
	{
#>
			VerifyUnderlyingType<ExtensionTypeObject>(<#= val #>, <#= passParameterName ? "\"" + val + "\"" : "null" #>);
			Debug.Assert(<#= val #>._handleOrTypeCode != null);

			return new ExtensionTypeObject(new ExtensionType(unchecked((long)<#= val #>._value)), (ReadOnlySequence<byte>)<#= val #>._handleOrTypeCode);
<#+
	}
	else if (t == typeof(byte[]))
	{
#>
			VerifyUnderlyingRawType<byte[]>(<#= val #>, <#= passParameterName ? "\"" + val + "\"" : "null" #>);

			if(<#= val #>._handleOrTypeCode == null)
			{
				// nil
				return null;
			}

			var asString = <#= val #>._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetByteArray();
<#+
	}
	else if (t == typeof(string))
	{
#>
			VerifyUnderlyingRawType<string>(<#= val #>, <#= passParameterName ? "\"" + val + "\"" : "null" #>);

			if(<#= val #>._handleOrTypeCode == null)
			{
				// nil
				return null;
			}

			var asString = <#= val #>._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetString();
<#+
	}
	else if (typeName.EndsWith("<byte>"))
	{
#>
			VerifyUnderlyingRawType<ReadOnlyMemory<byte>>(<#= val #>, <#= passParameterName ? "\"" + val + "\"" : "null" #>);

			var asString = <#= val #>._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetByteMemory();
<#+
	}
	else if (typeName.EndsWith("<char>"))
	{
#>
			VerifyUnderlyingRawType<ReadOnlyMemory<char>>(<#= val #>, <#= passParameterName ? "\"" + val + "\"" : "null" #>);

			var asString = <#= val #>._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetCharMemory();
<#+
	}
	else if (t == typeof(bool))
	{
#>
			var typeCode = <#= val #>._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null || typeCode.TypeCode != MessagePackValueTypeCode.Boolean)
			{
				ThrowInvalidTypeAs<bool>(<#= val #>);
			}

			Debug.Assert(typeCode != null);
			
			return <#= val #>._value != 0;
<#+
	}
	else if (t == typeof(float))
	{
#>
			var typeCode = <#= val #>._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<float>(<#= val #>);
			}
			
			Debug.Assert(typeCode != null);

			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					return (float)(unchecked((long)<#= val #>._value));
				}
				else
				{
					return (float)<#= val #>._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (<#= t.Name #>)BitConverter.Int64BitsToDouble(unchecked((long)<#= val #>._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (<#= t.Name #>)Binary.FromBits(unchecked((int)<#= val #>._value));
			}
			else
			{
				ThrowInvalidTypeAs<float>(<#= val #>);
				return default(float); // Never reaches
			}
<#+
	}
	else if (t == typeof(double))
	{
#>
			var typeCode = <#= val #>._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<double>(<#= val #>);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					return (double)(unchecked((long)<#= val #>._value));
				}
				else
				{
					return (double)<#= val #>._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (<#= t.Name #>)BitConverter.Int64BitsToDouble(unchecked((long)<#= val #>._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (<#= t.Name #>)Binary.FromBits(unchecked((int)<#= val #>._value));
			}
			else
			{
				ThrowInvalidTypeAs<double>(<#= val #>);
				return default(double); // Never reaches
			}
<#+
	}
	else if (t.Name[0] == 'U')
	{
#>
			var typeCode = <#= val #>._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<#= "<" + t.Name + ">" #>(<#= val #>);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
<#+
		if (t == typeof(UInt64))
		{
#>
				if (typeCode.IsSigned)
				{
					if (Int64.MaxValue < <#= val #>._value)
					{
						// Negative.
						ThrowInvalidTypeAs<#= "<" + t.Name + ">" #>(<#= val #>);
					}
				}

				return <#= val #>._value;
<#+
		}
		else
		{
#>
				const ulong maxValue = unchecked((ulong)<#= t.Name #>.MaxValue);
				
				if (maxValue < <#= val #>._value)
				{
					// Overflow or negative.
					ThrowInvalidTypeAs<#= "<" + t.Name + ">" #>(<#= val #>);
				}

				return unchecked((<#= t.Name #> )<#= val #>._value);
<#+
		}
#>
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (<#= t.Name #>)BitConverter.Int64BitsToDouble(unchecked((long)<#= val #>._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (<#= t.Name #>)Binary.FromBits(unchecked((int)<#= val #>._value));
			}
			else
			{
				ThrowInvalidTypeAs<#= "<" + t.Name + ">" #>(<#= val #>);
				return default(<#= t.Name #>); // Never reaches
			}
<#+
	}
	else
	{
#>
			var typeCode = <#= val #>._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<#= "<" + t.Name + ">" #>(<#= val #>);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
<#+
		if (t == typeof(Int64) )
		{
#>
					return unchecked((long)<#= val #>._value);
<#+
		}
		else
		{
#>
					const long minValue = (long)<#= t.Name #>.MinValue;
					const long maxValue = (long)<#= t.Name #>.MaxValue;
					
					long asInt64 = unchecked((long)<#= val #>._value);
					if(asInt64 < minValue || maxValue < asInt64)
					{
						ThrowInvalidTypeAs<#= "<" + t.Name + ">" #>(<#= val #>);
					}

					return unchecked((<#= t.Name #>)asInt64);
<#+
		}
#>
				}
				else
				{
					const ulong maxValue = unchecked((ulong)<#= t.Name #>.MaxValue);
					if(maxValue < <#= val #>._value)
					{
						ThrowInvalidTypeAs<#= "<" + t.Name + ">" #>(<#= val #>);
					}
					
					return (<#= t.Name #>)<#= val #>._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (<#= t.Name #>)BitConverter.Int64BitsToDouble(unchecked((long)<#= val #>._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (<#= t.Name #>)Binary.FromBits(unchecked((int)<#= val #>._value));
			}
			else
			{
				ThrowInvalidTypeAs<#= "<" + t.Name + ">" #>(<#= val #>);
				return default(<#= t.Name #>); // Never reaches
			}
<#+
	}
}

private static string GetTypeName(object typeOrTypeName)
	=> (typeOrTypeName as string) ?? (typeOrTypeName as Type).Name;

private static string GetNullability(object typeOrTypeName)
	=> (typeOrTypeName == typeof(byte[]) || typeOrTypeName == typeof(string)) ? "?" : String.Empty;
#>
